<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kidnet.github.io/"/>
  <updated>2017-09-19T10:24:33.128Z</updated>
  <id>http://kidnet.github.io/</id>
  
  <author>
    <name>Jason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker系列(一)--安装</title>
    <link href="http://kidnet.github.io/2017/09/19/docker-install/"/>
    <id>http://kidnet.github.io/2017/09/19/docker-install/</id>
    <published>2017-09-19T10:04:08.000Z</published>
    <updated>2017-09-19T10:24:33.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。</p><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装:"></a>yum安装:</h2><h3 id="安装docker源"><a href="#安装docker源" class="headerlink" title="安装docker源"></a>安装docker源</h3><p>使用yum安装doucker之前，需要先设置docker的yum源。</p><h4 id="设置源"><a href="#设置源" class="headerlink" title="设置源"></a>设置源</h4><ol><li><p>安装源需要的包: <code>yum-utils</code>, <code>yum-config-manager</code>, <code>device-mapper-persistent-data</code>, <code>lvm21</code>及<code>devicemapper</code>  </p><p>$ yum install -y yum-utils \<br>device-mapper-persistent-data \<br>lvm2</p></li></ol><ol><li><p>安装docker源</p><p>$ yum-config-manager \<br>–add-repo \<br><a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="external">https://download.docker.com/linux/centos/docker-ce.repo</a></p></li></ol><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><ol><li><p>安装最新版本docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install docker-ce</div></pre></td></tr></table></figure></li><li><p>启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl start docker</div></pre></td></tr></table></figure></li><li><p>验证docker是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run hello-world</div></pre></td></tr></table></figure></li></ol><h2 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h2><h3 id="安装静态二进制"><a href="#安装静态二进制" class="headerlink" title="安装静态二进制"></a>安装静态二进制</h3><ol><li>下载静态二进制包。下载地址:<a href="https://download.docker.com/linux/static/stable/x86_64/" target="_blank" rel="external">https://download.docker.com/linux/static/stable/x86_64/</a></li></ol><ol><li><p>解压缩tar包  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -xzvf /path/to/&lt;FILE&gt;.tar.gz</div></pre></td></tr></table></figure></li><li><p>将二进制文件拷贝至系统命令目录，如<code>/usr/bin</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp docker/* /usr/bin/</div></pre></td></tr></table></figure></li><li><p>启动Docker daemon:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dockerd &amp;</div></pre></td></tr></table></figure></li><li><p>验证docker是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run hello-world</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。&lt;/p&gt;
&lt;h2 id=&quot;yum安装&quot;&gt;&lt;a href=&quot;#yum安装
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://kidnet.github.io/2017/09/11/markdown/"/>
    <id>http://kidnet.github.io/2017/09/11/markdown/</id>
    <published>2017-09-11T08:19:20.000Z</published>
    <updated>2017-09-11T08:19:23.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前使用dokuwiki系统做共享文档的平台，接触到了Markdown这种书写格式。最近开始折腾在github上搭建blog，又用到了Markdown，但是好多都忘光了，从头复习一下。Markdown的目标是易读易写，让作者专注于写作，不用太多关心排版的问题,即使不把Markdown格式转化为HTML，可读性依然很强。Markdown格式是可以以纯文档的方式发布，使用标签或是格式指令构成，可以兼容HTML。</p><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>连续的文本组成一个段落，每个段落前后有一个以上的空行。每个段落不能使用空格或制表符来缩进，如果想要缩进只能使用HTML元素，比如：<code>&amp;emsp;</code>/<code>&amp;ensp;</code>/<code>&amp;nbsp;</code>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown格式中可以使用<code>=</code>和<code>-</code>两种底线形式来标注标题，例如：</p><pre><code>这是标题1==========这是标题2----------</code></pre><blockquote><h1 id="这是标题1"><a href="#这是标题1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2"><a href="#这是标题2" class="headerlink" title="这是标题2"></a>这是标题2</h2></blockquote><p>*注:任何数量的<code>=</code>和<code>-</code>都有效果。</p><p>同时，在Markdown格式中，使用1-6个<code>#</code>加一个空格可以标注1-6级的标题，同时可以选择性在最后使用给一个空格加同样数量的<code>#</code>号来闭合。</p><pre><code># 这是标题1## 这是标题2 ######## 这是标题6</code></pre><blockquote><h1 id="这是标题1-1"><a href="#这是标题1-1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2-1"><a href="#这是标题2-1" class="headerlink" title="这是标题2"></a>这是标题2</h2><h6 id="这是标题6"><a href="#这是标题6" class="headerlink" title="这是标题6"></a>这是标题6</h6></blockquote><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>区块引用使用<code>&gt;</code>在每行的开头标记，也可以在每段开头进行标记，在区块引用中可以进行嵌套，例如：</p><pre><code>&gt; 这是一个区块引用的示例，&gt; 在每行的行的行首使用&quot;&gt;&quot;来标记区块。</code></pre><blockquote><p>这是一个区块引用的示例，<br>在每行的行的行首使用”&gt;”来标记区块。</p></blockquote><p>（这里分隔一下示例，看的更清晰一些。）</p><pre><code>&gt; 当然也可以在每段的段的段首标记，本段都是在区块引用中。&gt; &gt; 这是一个嵌套的区块引用。</code></pre><blockquote><p>当然也可以在每段的段的段首标记，<br>本段都是在区块引用中。</p><blockquote><p>这是一个嵌套的区块引用   </p></blockquote></blockquote><p>在区块引用中可以使用其它Markdown语法，包括标题、列表、代码区块等，这些就不在这演示了。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown支持有序列表和无序列表。<br>无序列表使用<code>*</code>、<code>+</code>或<code>-</code>作为标记，例如:</p><pre><code>* 序列内容1* 序列内容2* 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>等同于<code>+</code>:</p><pre><code>+ 序列内容1+ 序列内容2+ 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3   </li></ul></blockquote><p>等同于<code>-</code>:</p><pre><code>- 序列内容1- 序列内容2- 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>有序列表使用数字后加一个<code>.</code>的形式(数字可以不按顺序或是同一个数字):</p><pre><code>1. 排序12. 排序23. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>同一个数字：</p><pre><code>1. 排序11. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序1</li><li>排序1</li></ol></blockquote><p>数字乱序：</p><pre><code>3. 排序19. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>从示例中看到以上三种标记形式达到的效果是一样的，但是为了不转换成HTML时的可读性，还是尽量使用顺序数字标记。</p><p>如果在列表中分段、使用区块引用和代码区块等，需要在这些标记前使用1-3个空格来标记是在列表中，例如:</p><pre><code>* 这是第一个列表中的第一段   这是第一个列表中的第二段* 这是第二个列表   &gt; 这是第二个列表中的区块引用*这是第三个列表        这是第三个列表中的代码区块</code></pre><blockquote><ul><li><p>这是第一个列表中的第一段</p><p>这是第一个列表中的第二段</p></li><li><p>这是第二个列表</p><blockquote><p>这是第二个列表中的区块引用</p></blockquote></li><li><p>这是第三个列表</p><pre><code>&lt;html&gt;这是第三个列表中的代码区块&lt;/html&gt;</code></pre></li></ul></blockquote><p>###代码区块<br>如果想要写程序代码在文档中，直接在代码前加入4个空格就进入了代码区块中，所有代码区块中都会按照输入原样输出，上面已经使用了很多代码区块，这里就不在演示了。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以使用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来插入一个分割线，此行内不能有任何其他的元素，可以在每个符号间插入空格，效果是一样，例如：</p><pre><code>* * **********- - -————————————</code></pre><blockquote><hr></blockquote><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown格式中支持两种形式的链接语法：行内式和参考式。两种形式的链接文字都使用<code>[]</code>来标记。如果想在链接上加入title文字，组要使用<code>&quot;&quot;</code>把title文字包起来，例如：</p><pre><code>这是一个[示例链接](http://test.com/ &quot;test&quot;)有title。[这是一个链接](http://test.com/)没有title。</code></pre><blockquote><p>这是一个<a href="http://test.com/" title="test" target="_blank" rel="external">示例链接</a>有title。<br><a href="http://test.com/" target="_blank" rel="external">这是一个链接</a>没有title。</p></blockquote><p>如果链接本地资源(同一主机下的资源)，可以使用相对路径：</p><pre><code>同一主机下的[资源](/resource/)。</code></pre><blockquote><p>同一主机下的<a href="/resource/">资源</a>。</p></blockquote><p>参考式链接是在链接文字的方括号后再接一个方括号，在第二个方括号里要填入一个辨识链接的标记，然后在文档任意处把这个链接的内容定义出来，例如：</p><pre><code>这是一个参考式的[链接示例][id](可以选择性在链接和标识间加入空格。)[id]: http://test.com/ &quot;Optional Title Here&quot;以下这两种形式与上面这种形式相同：[id]: http://test.com/ &apos;Optional Title Here&apos;[id]: http://test.com/ (Optional Title Here)链接地址可以使用&lt;&gt;括起来：[id]: &lt;http://test.com/&gt; &quot;Optional Title Here&quot;</code></pre><blockquote><p>这是一个参考式的[链接示例]<a href="可以选择性在链接和标识间加入空格。">id</a></p><p>[id]: <a href="http://test.com/" target="_blank" rel="external">http://test.com/</a> “Optional Title Here”</p></blockquote><p>链接辨别标签可以有字母、数字、空白和标点符号，但不区分大小写, 以下两个链接是相同的:</p><pre><code>[link][a][link][A]</code></pre><p>参考式链接还有一种隐式链接功能，可以省略链接标记，这种情况下，链接标记等同于链接文字，使用隐式链接只要在链接文邹后加上<code>[]</code>即可，比如：</p><pre><code>[Link][][Link]: http://test.com/</code></pre><p>使用参考式链接的好处是使得文档结构简单，使阅读文档时更加清晰。可以让文档更像是转换成HTML后的结构，可以以把一些标记相关的元数据转移到文档最后，不但可以增加链接，还可以让阅读文档时不被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown可以使用<code>*</code>和<code>_</code>作为标记强调符号，被<code>*</code>和<code>_</code>包围的字词会被转换为斜体(一个符号)和粗体(两个符号)，例如：</p><pre><code>*em***strong**_em___strong__</code></pre><blockquote><p><em>em</em><br><strong>strong</strong><br><em>em</em><br><strong>strong</strong></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果在一行内标记一小段的代码，可以使用<code>`` </code>括起来，例如:</p><pre><code>使用`&lt;html&gt;`标签时，可以把它变成代码段。</code></pre><blockquote><p>使用<code>&lt;html&gt;</code>标签时，可以把它变成代码段。</p></blockquote><p>如果想标记<code>` </code>为代码段，需要在<code>`` </code>括起来，并在<code>` </code>前后加入空格;如果在<code>`` </code>中可以加文字需要使用<code>`` `` </code>(<code>`test` </code>)，例如：</p><pre><code>如果想标记` ` `为代码段，需要在` `` `括起来，并在` ` `前后加入空格;如果在` `` `中可以加文字需要使用` `` `` `(`` `test` ``)</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown中使用类似标记链接的语法来标记图片，同样可以使用行内式和参考式。<br>行内式的图片语法是:</p><pre><code>![Alt text](/path/img.jpg)![Alt test](/path/img.jpg &quot;Optional title&quot;)</code></pre><p>参考式的图片语法是:</p><pre><code>![Alt test][id][id]: url/path/image &quot;Optional title attribute&quot;</code></pre><h2 id="其它语法"><a href="#其它语法" class="headerlink" title="其它语法"></a>其它语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在Markdown语法中可以使用<code>-</code>、<code>|</code>和<code>:</code>来画出表格，<code>-</code>代表横线，<code>|</code>代表竖线，<code>:-----:</code>代表横线上的内容居中，例如：</p><pre><code>|Title1      |Title2    |Title3 ||------------|:--------:|:-----:||Content1    |Content2  |Content3|</code></pre><blockquote><table><thead><tr><th>Title1</th><th style="text-align:center">Title2</th><th style="text-align:center">Title3</th></tr></thead><tbody><tr><td>Content1</td><td style="text-align:center">Content2</td><td style="text-align:center">Content3</td></tr></tbody></table></blockquote><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown中支持简单的自动链接形式来出来网址和电子邮箱，使用<code>&lt;&gt;</code>括起来即可，Markdown会自动将它装换成链接形式，例如:</p><pre><code>&lt;http://test.com/&gt;&lt;test@test.com&gt;</code></pre><blockquote><p><a href="http://test.com/" target="_blank" rel="external">http://test.com/</a><br><a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x74;&#101;&#x73;&#x74;&#x40;&#x74;&#101;&#x73;&#x74;&#46;&#x63;&#111;&#x6d;">&#x74;&#101;&#x73;&#x74;&#x40;&#x74;&#101;&#x73;&#x74;&#46;&#x63;&#111;&#x6d;</a></p></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown中可以利用<code>\</code>来转义语法中有特殊意义的符号，例如:在文章中就是想加入<code>*</code>，不想进行强调，可以在<code>*</code>前加入<code>\</code>:</p><pre><code>\*只想在文章中加入`*`\*</code></pre><blockquote><p>*只想在文章中加入<code>*</code>*</p></blockquote><p>Markdown中支持以下符号前加<code>\</code>来转义:</p><blockquote><p><code>\</code>     反斜线<br><code>` </code>   反引号<br><code>*</code>     星号<br><code>_</code>     下划线<br><code>{}</code>    花括号<br><code>[]</code>    方括号<br><code>()</code>    圆括号<br><code>+</code>      加号<br><code>-</code>      减号<br><code>.</code>      英文句号<br><code>!</code>      叹号</p></blockquote><h3 id="Markdown书写软件"><a href="#Markdown书写软件" class="headerlink" title="Markdown书写软件"></a>Markdown书写软件</h3><p>Markdown本身是一种标记性语法，上面提到过，即使不转换成HTML语言可读性也很强，所以任何文本工具都可以使用Markdown语法，有些文本工具可以安装一些插件达到语法高亮的效果，这里就不一一细说了。还有一些软件是可以一边使用Markdown语法书写，同时能看到转换为HTML后的效果，即所见即所得，如:MarkdownPad、马克飞象(Chrome浏览器插件)、Mou等，还有许多在线的书写工具。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文是根据<a href="http://wowubuntu.com/markdown" target="_blank" rel="external">wowubuntu</a>文章，并根据自己的一些理解加以修改而编写的, 一切版权问题依照原作者声明。</p><p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown语法项目(英文)地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://kidnet.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>带有超时设置的subprocess</title>
    <link href="http://kidnet.github.io/2017/09/08/subprocess_with_timeout/"/>
    <id>http://kidnet.github.io/2017/09/08/subprocess_with_timeout/</id>
    <published>2017-09-08T07:50:36.000Z</published>
    <updated>2017-09-13T01:54:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频繁调用的定时任务来说，会产生很多卡死的进程(实际中遇到过很多子进程卡死，导致系统资源耗尽，宕机)。为解决这个问题，重新对subprocess封装，加入对调用命令执行超时的处理。</p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><h3 id="重新封装SubWork类"><a href="#重新封装SubWork类" class="headerlink" title="重新封装SubWork类"></a>重新封装SubWork类</h3><p>对subprocess重新封装，定义一些默认属性。</p><pre><code>class SubWork(Object):    def __init__(self):                                                                                                                                           &quot;&quot;&quot;    Default None                                                               &quot;&quot;&quot;                                                                       self._Popen = None                                                         self._pid = None           #子进程PID                                                       self._return_code = None   #执行命令返回值                                               self._cwd = None           #执行目录                                               self._start_time = None    #子进程开始执行的时间戳</code></pre><h3 id="调用命令的内部方法"><a href="#调用命令的内部方法" class="headerlink" title="调用命令的内部方法"></a>调用命令的内部方法</h3><p>这里定义了一个内部方法，用于使用subprocess调用系统命令，并做超时处理。</p><ol><li>subprocess接收命令格式为一个list，所以使用shlex.split()进行命令切分。此方法接收4个参数：命令，标准输出，标准错误和执行目录。</li><li>超时处理，在调用<code>subprocess.Popen()</code>方法后，先获取当前时间戳，然后循环判断，是否程序正常退出(<code>poll()</code>方法获取子进程状态)并且是在超时时间之内，这里用这个循环来代替<code>wait()</code>方法来阻塞进程，并判断超时。如果超过超时时间，方法继续执行，获取进程执行返回的状态(此时可能子进程并未执行完毕)，再次判断子进程是否退出，如在此处还未退出，执行<code>terminate()</code>方法，给子进程发送信号，退出子进程，等待1秒，再次判断进程是否退出，如还未退出证明进程未正常相应<code>terminate()</code>发出的信号，此时使用<code>kill()</code>方法，发出<code>SIGKILL</code>信号，强制退出子进程。</li><li>最终获取子进程退出的状态。</li></ol><p>代码如下:</p><pre><code>def _run(self):    #Run cmd.    #Split command string.    cmd = shlex.split(self._cmd)    self._Popen = subprocess.Popen(args=cmd,                                   stdout=self._stdout_fd,                                   stderr=self._stderr_fd,                                   cwd=self._cwd)    self._pid = self._Popen.pid    self._start_time = time.time()    while (self._Popen.poll() == None and            (time.time() - self._start_time) &lt; self._timeout):        time.sleep(1)    _r_code = self._Popen.poll()    # If child process has not exited yet, terminate it.    if self._Popen.poll() == None:        self._Popen.terminate()        _r_code = 254    # Wait for the child process to exit.    time.sleep(1)    # If child process has not been terminated yet, kill it.    if self._Popen.poll() == None:        self._Popen.kill()        _r_code = 255    self._return_code = _r_code</code></pre><h3 id="对外的方法"><a href="#对外的方法" class="headerlink" title="对外的方法"></a>对外的方法</h3><p>外部调用的方法<code>start()</code>，使用此方法进行执行命令的调用。接收命令，超时时间，标准输入，标准输出，标准错误，是否使用tty(是否将结果输出到终端)，是否使用时间戳(返回结果中打印开始的时间)。此方法主要是调用内部执行命令的方法(_run())，然后对输出进行格式化。</p><pre><code>def start(self,          cmd,          timeout=5*60*60,          stdin=None,          stdout=None,          stderr=None,          tty=False,          timestamp=False):    self._cmd = cmd    self._stdin = stdin    self._stdout = stdout    self._stderr = stderr    self._timeout = timeout    self._is_tty = tty    self._timestamp = timestamp    #Init output.    info = None    err = None    if self._timestamp:        start_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())        file_start = &quot;Start Time: &quot; + start_time + &quot;\n&quot;    else:        file_start = &quot;&quot;        file_end = &quot;&quot;    try:        #Init the file handle of output.        if self._is_tty:            self._stdout_fd = None            self._stderr_fd = None        elif (self._stdout is None or            self._stderr is None or            self._stdout == self._stderr):            self._stdout_fd = tempfile.TemporaryFile()            self._stderr_fd = tempfile.TemporaryFile()        else:            self._stdout_fd = self._create_handler(self._stdout)            self._stderr_fd = self._create_handler(self._stderr)            self._stdout_fd.write(file_start)            self._stdout_fd.flush()            self._stderr_fd.write(file_start)            self._stderr_fd.flush()        self._run()        if self._timestamp:            end_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())            file_end = &quot;End Time: &quot; + end_time + &quot;\n&quot;        #Write and Read output content.        if not self._is_tty:            self._stdout_fd.write(file_end)            self._stderr_fd.write(file_end)            self._stdout_fd.flush()            self._stderr_fd.flush()            self._stdout_fd.seek(0)            self._stderr_fd.seek(0)            info = file_start + self._stdout_fd.read() + file_end            err = file_start + self._stderr_fd.read() + file_end    finally:        #Close file handle.        if not self._is_tty:            self._stdout_fd.close()            self._stderr_fd.close()    return {&quot;code&quot;:self._return_code,            &quot;stdout&quot;:info,            &quot;stderr&quot;:err            }</code></pre><p>  这里输出分为3种类型：</p><ol><li>直接输出到终端，设置tty=True即可，就是直接打印到终端。</li><li>输出到临时文件中，如果tty=False，并且没有输入指定的log文件（stdout和stderr），某块会自动创建一个临时文件来记录日志。</li><li>输出到指定日志中，设置了输出日志，会将命令执行的标准输出和标准错误输出到指定日志文件中（实时输出）。</li></ol><p>*注意: 如果设置使用输出到tty，最终start()方法只会返回命令执行的状态码，不会返回执行结果（已经输出到终端），使用临时文件作为日志或指定输出日志文件，最终start()方法会最终将日志返回给调用的程序。</p><h3 id="对日志处理的方法"><a href="#对日志处理的方法" class="headerlink" title="对日志处理的方法"></a>对日志处理的方法</h3><p>创建日志文件，初始化日志句柄。</p><pre><code>#Create file handle.def _create_handler(self, filename):    if isinstance(filename, file):        return filename    elif isinstance(filename, basestring):        path = os.path.dirname(filename)        timestamp = time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime())        if not os.path.exists(path):            os.makedirs(path)        elif os.path.exists(filename) and not os.path.isfile(filename):            backup_name = filename + timestamp            os.rename(filename, backup_name)        fd = open(filename, &apos;a+b&apos;)        return fd    else:        raise &quot;The type of \&apos;filename\&apos; must be \&apos;file\&apos; or \&apos;basestring\&apos;&quot;</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>SubWork</code>使用方法如下:</p><pre><code>import SubWorkcmd = &quot;/bin/ls /tmp&quot;worker = SubWork()res = worker.start(cmd, 300， &quot;/tmp/stdout.log&quot;, &quot;/tmp/stderr.log&quot;)print res</code></pre><p>这里会执行<code>/bin/ls /tmp</code>命令，超时时间300秒，将执行的标准输出实时输出到<code>/tmp/stdout.log</code>中，将输出的标准错误实时输出到<code>/tmp/stderr.log</code> 中，最终<code>res</code>变量中会有命令执行的状态码和命令执行的输出结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频
      
    
    </summary>
    
      <category term="Python" scheme="http://kidnet.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidnet.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
