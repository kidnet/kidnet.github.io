<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kidnet.github.io/"/>
  <updated>2018-07-12T07:56:39.867Z</updated>
  <id>http://kidnet.github.io/</id>
  
  <author>
    <name>Jason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcpdump实例</title>
    <link href="http://kidnet.github.io/2018/07/09/tcpdump-examples/"/>
    <id>http://kidnet.github.io/2018/07/09/tcpdump-examples/</id>
    <published>2018-07-09T02:15:49.000Z</published>
    <updated>2018-07-12T07:56:39.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://hackertarget.com/tcpdump-examples/" target="_blank" rel="external">https://hackertarget.com/tcpdump-examples/</a></p></blockquote><p>实用的tcpdump实例可以解决你的网络故障和安全问题。 命令和示例并不仅仅是使用<code>tcpdump</code>，而且还是掌了解你的网络的方法。</p><p>了解<code>tcpdump</code>是一项必不可少的技能，可以为系统管理员，网络工程师或者专业的安全人员派上用场。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="分解Tcpdump命令"><a href="#分解Tcpdump命令" class="headerlink" title="分解Tcpdump命令"></a>分解Tcpdump命令</h3><p>以下命令是使用<code>tcpdump</code>时经常能看到的参数。</p><pre><code>:~$ sudo tcpdump -i eth0 -nn -s0 -v port 80</code></pre><p><font color="#348017">-i</font>: 选择在哪个端口上进行捕捉，这通常是一个网卡或者无线适配器，但也可以是一个<code>vlan</code>或某些更不常用的设备。 如果只有一个网络适配器的话，就不需要这参数了。  </p><p><font color="#FFA500">-nn</font>: 单独一个(n)不会解析主机名(直接显示IP)。 两个(n)将不会解析主机名或端口(直接显示IP或端口号)。 这个不仅更方便于查看IP/端口，还可以捕获大量的数据，并且可以大大提高捕获速度，因为名称解析会降低捕获速度。  </p><p><font color="#800000">-s0</font>: 捕获数据的长度，捕获数据包的大小。<code>-s0</code>将大小设置为无限制，如果要捕获所有流量，请使用此选项。 另外，如果你想从网络流量中获取二进制文件或文件，需要使用这个选项。  </p><p><font color="#DC143C">-v</font>: 详细信息，使用(-v)或者(-vv)增加输出的详细信息的信息量，经常是显示更多的协议的特定信息。  </p><p><font color="#0000A0">port 80</font>: 这通常是一个端口过滤器，只捕获80端口上的流量，这个端口当然通常是HTTP。</p><h3 id="显示ASCII字符的文本"><a href="#显示ASCII字符的文本" class="headerlink" title="显示ASCII字符的文本"></a>显示ASCII字符的文本</h3><p>在命令中加入<code>-A</code>参数，会从捕获的输会包含<code>ascii</code>字符。 这样可以很容易的读取并使用<code>grep</code>或其他命令来解析输出。 另外还有个选项<code>-X</code>也可以显示ASCII，并且可以显示十六进制输出。</p><pre><code>:~$ sudo tcpdump -A -s0 port 80</code></pre><h3 id="捕获指定协议"><a href="#捕获指定协议" class="headerlink" title="捕获指定协议"></a>捕获指定协议</h3><p>过滤UDP的流量。 另一种方法是指定协议号<strong>protocol 17</strong>，这就是<code>udp</code>。 以下这两个命令的结果是相同的。 与<code>tcp</code>过滤器相同的是<strong>protocol 6</strong>。</p><pre><code>:~$ sudo tcpdump -i eth0 udp:~$ sudo tcpdump -i eth0 proto 17</code></pre><h3 id="基于IP地址来捕获指定的主机"><a href="#基于IP地址来捕获指定的主机" class="headerlink" title="基于IP地址来捕获指定的主机"></a>基于IP地址来捕获指定的主机</h3><p>使用<code>host</code>过滤器可以捕获到达(目的地)和来自(源)这个IP的流量。</p><pre><code>:~$ sudo tcpdump -i eth0 host 10.10.1.1</code></pre><p>或者，使用<code>src</code>或<code>dst</code>来捕获一个方向的包。</p><pre><code>:~$ sudo tcpdump -i eth0 dst 10.10.1.20</code></pre><h3 id="写入一个捕获文件"><a href="#写入一个捕获文件" class="headerlink" title="写入一个捕获文件"></a>写入一个捕获文件</h3><p>通过一个普通的命令选项就可以写一个标准的<code>pcap</code>文件。 写入的捕获文件可以在Wireshark或者其它的包分析工具中打开。</p><pre><code>:~$ sudo tcpdump -i eth0 -s0 -w test.pcap</code></pre><h3 id="行缓冲模式"><a href="#行缓冲模式" class="headerlink" title="行缓冲模式"></a>行缓冲模式</h3><p>如果没有强制使用行缓冲模式(-l)或者数据包缓冲模式(-C)选项，在<code>tcpdump</code>输出时，通过管道传递给另一个命令(如grep)时，你不过实时获得预期的响应。 通过使用此选项，输出会立即通过管道发送给另一个命令，在排除故障时会立即响应。</p><pre><code>:~$ sudo tcpdump -i eth0 -s0 -l port 80 | grep &apos;Server:&apos;</code></pre><h3 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h3><p>在上面这些示例中，你可以使用以下的标准逻辑来组合不同的过滤器。</p><pre><code>and or &amp;&amp;or or ||not or !</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在下面的例子中，很多都是可以用多种方法来实现相同的结果。 如在一些示例中所见，可以直接捕获包中的各个位。  </p><p>你使用什么方法将取决于你想要的什么样的输出及在线路上的流量。 如在一个流量频繁的千兆链接上，可能会强制你使用特定的低级别的数据包过滤器。  </p><p>当在排障时，你经常是想直接得到结果，这时需要在端口上进行过滤，并且选择<strong>ascii</strong>输出来结合<code>grep</code>, <code>cut</code>或者<code>awk</code>来获得最后结果。如果需要，你可以随时深入挖掘数据包。 </p><p>例如，当捕获HTTP请求和返回时，你可以通过移除<strong>SYN/ACK/FIN</strong>来过滤所有的除了数据之外的数据包，但无论怎样你如果使用<code>grep</code>都可以过滤掉噪音。(Keep it simple.)</p><p>可以在下面的例子中看到，其目的也是以最简单(也是最快）的方式来获得结果。  </p><h3 id="1-提取HTTP的User-Agent"><a href="#1-提取HTTP的User-Agent" class="headerlink" title="1. 提取HTTP的User-Agent"></a>1. 提取HTTP的User-Agent</h3><p>从HTTP请求头中提取User-Agent。</p><pre><code>:~$ sudo tcpdump -nn -A -s1500 -l | grep &quot;User-Agent:&quot;</code></pre><p>通过使用<code>egrep</code>和多匹配项，我们可以获取User-Agent和Host(或者其它的字段)从请求中。</p><pre><code>:~$ sudo tcpdump -nn -A -s1500 -l | egrep -i &apos;User-Agent:|Host:&apos;</code></pre><h3 id="2-只捕获HTTP的GET和POST包"><a href="#2-只捕获HTTP的GET和POST包" class="headerlink" title="2. 只捕获HTTP的GET和POST包"></a>2. 只捕获HTTP的GET和POST包</h3><p>深入的了解了过滤器后，发现我们只能指定匹配GET请求。</p><pre><code>:~$ sudo tcpdump -s 0 -A -vv &apos;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&apos;</code></pre><p>或者我们只能选择匹配POST请求。 注意，这里可能POST的数据没有包含在这个过滤器捕获的数据包中，POST请求可能会被拆分跨多个TCP数据包。</p><pre><code>:~$ sudo tcpdump -s 0 -A -vv &apos;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354&apos;</code></pre><p>上面表达式的中16进制匹配的是GET和POST的ascii码。</p><p><strong>tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]</strong>中首先我们先确定我们需要的<a href="https://security.stackexchange.com/questions/121011/wireshark-tcp-filter-tcptcp121-0xf0-24" target="_blank" rel="external">字节位置</a>(在TCP标头之后的), 然后选择我们希望匹配的4个字节。</p><h3 id="3-提取HTTP请求中的URL"><a href="#3-提取HTTP请求中的URL" class="headerlink" title="3. 提取HTTP请求中的URL"></a>3. 提取HTTP请求中的URL</h3><p>从流量中简单的分析Host和HTTP请求的位置(URL)。 这里不指定80端口，我们可能在任何端口找到HTTP的请求，例如运行在高端口的HTTP服务。</p><pre><code>:~$ sudo tcpdump -s 0 -v -n -l | egrep -i &quot;POST /|GET /|Host:&quot;tcpdump: listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes    POST /wp-login.php HTTP/1.1    Host: dev.example.com    GET /wp-login.php HTTP/1.1    Host: dev.example.com    GET /favicon.ico HTTP/1.1    Host: dev.example.com    GET / HTTP/1.1    Host: dev.example.com</code></pre><h3 id="4-提取POST请求中的HTTP密码"><a href="#4-提取POST请求中的HTTP密码" class="headerlink" title="4. 提取POST请求中的HTTP密码"></a>4. 提取POST请求中的HTTP密码</h3><p>从POST数据中获取密码。 这里提取信息包括”Host:”和请求的位置，以便知道密码的用途。</p><pre><code>:~$ sudo tcpdump -s 0 -A -n -l | egrep -i &quot;POST /|pwd=|passwd=|password=|Host:&quot;tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes11:25:54.799014 IP 10.10.1.30.39224 &gt; 10.10.1.125.80: Flags [P.], seq 1458768667:1458770008, ack 2440130792, win 704, options [nop,nop,TS val 461552632 ecr 208900561], length 1341: HTTP: POST /wp-login.php HTTP/1.1.....s..POST /wp-login.php HTTP/1.1Host: dev.example.com.....s..log=admin&amp;pwd=notmypassword&amp;wp-submit=Log+In&amp;redirect_to=http%3A%2F%2Fdev.example.com%2Fwp-admin%2F&amp;testcookie=1</code></pre><h3 id="5-从服务器端和客户端捕获Cookies"><a href="#5-从服务器端和客户端捕获Cookies" class="headerlink" title="5. 从服务器端和客户端捕获Cookies"></a>5. 从服务器端和客户端捕获Cookies</h3><p>在服务器上通过检索”Set-Cookie:”(服务器端)和”Cookie:”(客户端)来捕获cookies。</p><pre><code>:~$ sudo tcpdump -nn -A -s0 -l | egrep -i &apos;Set-Cookie|Host:|Cookie:&apos;tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytesHost: dev.example.comCookie: wordpress_86be02xxxxxxxxxxxxxxxxxxxc43=admin%7C152xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxfb3e15c744fdd6; _ga=GA1.2.21343434343421934; _gid=GA1.2.927343434349426; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_86be654654645645645654645653fc43=admin%7C15275102testtesttesttestab7a61e; wp-settings-time-1=1527337439</code></pre><h3 id="6-捕获所有ICMP数据包"><a href="#6-捕获所有ICMP数据包" class="headerlink" title="6. 捕获所有ICMP数据包"></a>6. 捕获所有ICMP数据包</h3><p>查看线路上所有的<code>ICMP</code>数据包。</p><pre><code>:~$ sudo tcpdump -n icmptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes11:34:21.590380 IP 10.10.1.217 &gt; 10.10.1.30: ICMP echo request, id 27948, seq 1, length 6411:34:21.590434 IP 10.10.1.30 &gt; 10.10.1.217: ICMP echo reply, id 27948, seq 1, length 6411:34:27.680307 IP 10.10.1.159 &gt; 10.10.1.1: ICMP 10.10.1.189 udp port 59619 unreachable, length 115</code></pre><h3 id="7-显示没有应答-返回的ICMP数据包-标准ping"><a href="#7-显示没有应答-返回的ICMP数据包-标准ping" class="headerlink" title="7. 显示没有应答/返回的ICMP数据包(标准ping)"></a>7. 显示没有应答/返回的ICMP数据包(标准ping)</h3><p>通过过滤<code>icmp</code>类型来选择出非标准的<code>ping</code>数据包的<code>icmp</code>数据包。</p><pre><code>:~$ sudo tcpdump &apos;icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply&apos;tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes11:37:04.041037 IP 10.10.1.189 &gt; 10.10.1.20: ICMP 10.10.1.189 udp port 36078 unreachable, length 156</code></pre><h3 id="8-捕获SMTP-POP3-Email"><a href="#8-捕获SMTP-POP3-Email" class="headerlink" title="8. 捕获SMTP/POP3 Email"></a>8. 捕获SMTP/POP3 Email</h3><p>这样能提取出email邮件体和其他的数据， 在这个例子中我们仅解析出邮件的收件人。</p><pre><code>:~$ sudo tcpdump -nn -l port 25 | grep -i &apos;MAIL FROM\|RCPT TO&apos;</code></pre><h3 id="9-诊断NTP的查询和响应"><a href="#9-诊断NTP的查询和响应" class="headerlink" title="9. 诊断NTP的查询和响应"></a>9. 诊断NTP的查询和响应</h3><p>在这个例子中可以看到NTP的查询和响应。</p><pre><code>:~$ sudo tcpdump dst port 123tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes21:02:19.112502 IP test33.ntp &gt; 199.30.140.74.ntp: NTPv4, Client, length 4821:02:19.113888 IP 216.239.35.0.ntp &gt; test33.ntp: NTPv4, Server, length 4821:02:20.150347 IP test33.ntp &gt; 216.239.35.0.ntp: NTPv4, Client, length 4821:02:20.150991 IP 216.239.35.0.ntp &gt; test33.ntp: NTPv4, Server, length 48</code></pre><h3 id="10-捕获SNMP查询和响应"><a href="#10-捕获SNMP查询和响应" class="headerlink" title="10. 捕获SNMP查询和响应"></a>10. 捕获SNMP查询和响应</h3><p>用<code>onsixtyone</code>快速SNMP协议扫描器来测试一个本地网络的SNMP服务，并且捕获<code>GetRequest</code>和<code>GetResponse</code>。 对于那些有过诊断SNMP故障愉快或不愉快经历的人，这都是一个很好的方法去查看线路上到底发生了什么状况。</p><pre><code>:~$ onesixtyone 10.10.1.10 publicScanning 1 hosts, 1 communities10.10.1.10 [public] Linux test33 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64</code></pre><!-- -->  <pre><code>:~$ sudo tcpdump -n -s0  port 161 and udptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes23:39:13.725522 IP 10.10.1.159.36826 &gt; 10.10.1.20.161:  GetRequest(28)  .1.3.6.1.2.1.1.1.023:39:13.728789 IP 10.10.1.20.161 &gt; 10.10.1.159.36826:  GetResponse(109)  .1.3.6.1.2.1.1.1.0=&quot;Linux testmachine 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64&quot;</code></pre><h3 id="11-捕获FTP凭据和命令"><a href="#11-捕获FTP凭据和命令" class="headerlink" title="11. 捕获FTP凭据和命令"></a>11. 捕获FTP凭据和命令</h3><p>可以直接捕获FTP命令和登录细节。 身份验证之后，FTP的会话可能是<strong>主动(active)</strong>或<strong>被动(passive)</strong>模式，使用的模式将确定会话的数据部分是通过TCP 20端口还是另一个随机端口传输的。 使用以下命令你可以捕获输出中的USER和PASS(可以输出给grep)，以及LIST, CWD和PASSIVE等FTP命令。</p><pre><code>:~$ sudo tcpdump -nn -v port ftp or ftp-data</code></pre><h3 id="12-轮转捕获文件"><a href="#12-轮转捕获文件" class="headerlink" title="12. 轮转捕获文件"></a>12. 轮转捕获文件</h3><p>当捕获大量的流量或者长时间的进行捕获时，采用自动轮转会很有帮助，它会按照固定大小来创建新文件。 使用参数<code>-W</code>, <code>-G</code>和<code>-C</code>来完成自动轮转。</p><p>在下面这个命令中，会每(-G)<strong>3600秒</strong>(1小时)创建文件<strong>capture-(hour).pcap</strong>。 在第二天这些文件将会被重写，最终这个文件应该是<strong>capture-{1-24}.pcap, 如15点，那么新文件就是</strong>/tmp/capture-15.pcap__。</p><pre><code>:~$ tcpdump  -w /tmp/capture-%H.pcap -G 3600 -C 200</code></pre><h3 id="13-捕获IPv6的流量"><a href="#13-捕获IPv6的流量" class="headerlink" title="13. 捕获IPv6的流量"></a>13. 捕获IPv6的流量</h3><p>使用<code>ip6</code>过滤器可以捕获IPv6的流量。 在下面的例子中我们使用<code>proto 6</code>和<code>proto 17</code>指定了TCP和UDP协议。</p><pre><code>tcpdump -nn ip6 proto 6</code></pre><p>可以从之前保存的捕获文件中读取IPv6的UDP协议。</p><pre><code>tcpdump -nr ipv6-test.pcap ip6 proto 17</code></pre><h3 id="14-在网络流量中探测端口扫描"><a href="#14-在网络流量中探测端口扫描" class="headerlink" title="14. 在网络流量中探测端口扫描"></a>14. 在网络流量中探测端口扫描</h3><p>下面这个例子中可以看到这些流量来自一个源到一个目的的。 可以看到标志[S]和[R]与看似随机的一系列目标端口进行匹配。 当SYN在目标系统上发现一个关闭的端口，这些端口会在RESET上被看到。 这是一个典型的被像<a href="https://hackertarget.com/nmap-tutorial/" target="_blank" rel="external">Nmap</a>样的工具进行扫面的行为。  </p><p>这里有另一个<a href="https://hackertarget.com/nmap-tutorial/" target="_blank" rel="external">Nmap的教程</a>, 详细介绍了Wireshark中捕获的端口扫面(<strong>open/close/filtered</strong>)。</p><pre><code>:~$ tcpdump -nn21:46:19.693601 IP 10.10.1.10.60460 &gt; 10.10.1.199.5432: Flags [S], seq 116466344, win 29200, options [mss 1460,sackOK,TS val 3547090332 ecr 0,nop,wscale 7], length 021:46:19.693626 IP 10.10.1.10.35470 &gt; 10.10.1.199.513: Flags [S], seq 3400074709, win 29200, options [mss 1460,sackOK,TS val 3547090332 ecr 0,nop,wscale 7], length 021:46:19.693762 IP 10.10.1.10.44244 &gt; 10.10.1.199.389: Flags [S], seq 2214070267, win 29200, options [mss 1460,sackOK,TS val 3547090333 ecr 0,nop,wscale 7], length 021:46:19.693772 IP 10.10.1.199.389 &gt; 10.10.1.10.44244: Flags [R.], seq 0, ack 2214070268, win 0, length 021:46:19.693783 IP 10.10.1.10.35172 &gt; 10.10.1.199.1433: Flags [S], seq 2358257571, win 29200, options [mss 1460,sackOK,TS val 3547090333 ecr 0,nop,wscale 7], length 021:46:19.693826 IP 10.10.1.10.33022 &gt; 10.10.1.199.49153: Flags [S], seq 2406028551, win 29200, options [mss 1460,sackOK,TS val 3547090333 ecr 0,nop,wscale 7], length 021:46:19.695567 IP 10.10.1.10.55130 &gt; 10.10.1.199.49154: Flags [S], seq 3230403372, win 29200, options [mss  1460,sackOK,TS val 3547090334 ecr 0,nop,wscale 7], length 021:46:19.695590 IP 10.10.1.199.49154 &gt; 10.10.1.10.55130: Flags [R.], seq 0, ack 3230403373, win 0, length 021:46:19.695608 IP 10.10.1.10.33460 &gt; 10.10.1.199.49152: Flags [S], seq 3289070068, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 021:46:19.695622 IP 10.10.1.199.49152 &gt; 10.10.1.10.33460: Flags [R.], seq 0, ack 3289070069, win 0, length 021:46:19.695637 IP 10.10.1.10.34940 &gt; 10.10.1.199.1029: Flags [S], seq 140319147, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 021:46:19.695650 IP 10.10.1.199.1029 &gt; 10.10.1.10.34940: Flags [R.], seq 0, ack 140319148, win 0, length 021:46:19.695664 IP 10.10.1.10.45648 &gt; 10.10.1.199.5060: Flags [S], seq 2203629201, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 021:46:19.695775 IP 10.10.1.10.49028 &gt; 10.10.1.199.2000: Flags [S], seq 635990431, win 29200, options [mss 1460,sackOK,TS val 3547090335 ecr 0,nop,wscale 7], length 021:46:19.695790 IP 10.10.1.199.2000 &gt; 10.10.1.10.49028: Flags [R.], seq 0, ack 635990432, win 0, length 0</code></pre><h3 id="15-展示Nmap-NSE脚本测试的实例"><a href="#15-展示Nmap-NSE脚本测试的实例" class="headerlink" title="15. 展示Nmap NSE脚本测试的实例"></a>15. 展示Nmap NSE脚本测试的实例</h3><p>在这个示例中，展示了Nmap NSE脚本<code>http-enum.nse</code>针对访问HTTP服务有效的URL的测试。</p><p>在Nmap的服务器上:</p><pre><code>:~$ nmap -p 80 --script=http-enum.nse targetip</code></pre><p>在目标服务器上:</p><pre><code>:~$ tcpdump -nn port 80 | grep &quot;GET /&quot;GET /w3perl/ HTTP/1.1GET /w-agora/ HTTP/1.1GET /way-board/ HTTP/1.1GET /web800fo/ HTTP/1.1GET /webaccess/ HTTP/1.1GET /webadmin/ HTTP/1.1GET /webAdmin/ HTTP/1.1</code></pre><h3 id="16-捕获每个非本地主机的开始和结尾的数据包"><a href="#16-捕获每个非本地主机的开始和结尾的数据包" class="headerlink" title="16. 捕获每个非本地主机的开始和结尾的数据包"></a>16. 捕获每个非本地主机的开始和结尾的数据包</h3><p>这个例子是出自<code>tcpdump</code>的man page。 通过筛选<code>tcp-syn</code>和<code>tcp-fin</code>数据包，可以显示每个已经连接的TCP会话，其中包含时间戳，但没有数据。 与许多过滤器一样，这样可以减少噪音，从而更专注于你关心的信息。</p><pre><code>:~$ tcpdump &apos;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet&apos;</code></pre><h3 id="17-捕获DNS请求与响应"><a href="#17-捕获DNS请求与响应" class="headerlink" title="17. 捕获DNS请求与响应"></a>17. 捕获DNS请求与响应</h3><p>在这个捕获中可以看到对外访问Google公共DNS的请求和A记录(ip地址)的响应。</p><pre><code>:~$ sudo tcpdump -i wlp58s0 -s0 port 53tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes14:19:06.879799 IP test.53852 &gt; google-public-dns-a.google.com.domain: 26977+ [1au] A? play.google.com. (44)14:19:07.022618 IP google-public-dns-a.google.com.domain &gt; test.53852: 26977 1/0/1 A 216.58.203.110 (60)</code></pre><h3 id="18-捕获HTTP数据包"><a href="#18-捕获HTTP数据包" class="headerlink" title="18. 捕获HTTP数据包"></a>18. 捕获HTTP数据包</h3><p>在80端口仅捕获HTTP的数据包。 避免捕获TCP的连接(SYN/FIN/ACK)。</p><pre><code>tcpdump &apos;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&apos;</code></pre><h3 id="19-使用tcpdump进行捕获并在Wireshark中查看"><a href="#19-使用tcpdump进行捕获并在Wireshark中查看" class="headerlink" title="19. 使用tcpdump进行捕获并在Wireshark中查看"></a>19. 使用tcpdump进行捕获并在Wireshark中查看</h3><p>使用Wireshark(或tshark)解析与分析完整的应用程序流(如HTTP)比用<code>tcpdump</code>更容易。 通常更实用的事使用<code>tcpdump</code>捕获结果写入文件的选项来捕获远程系统上的流量。 然后拷贝这个<code>pcap</code>文件到本地的工作机，使用Wireshark来分析。 </p><p>除了手动将文件从远程系统移动到本地工作机之外，还可以通过SSH来实时捕获远程系统的流量信息提供给Wireshark。 <strong>别忘了</strong>使用<code>not port 22</code>来过滤掉SSH的流量。</p><pre><code>:~$ ssh root@remotesystem &apos;tcpdump -s0 -c 1000 -nn -w - not port 22&apos; | wireshark -k -i -</code></pre><p>另一个提示，在远程使用<code>tcpdump</code>时使用计数选项<code>-c</code>来允许捕获完成，否则当<code>ctrl-c</code>时不仅会kiil掉<code>tcpdump</code>，还会kill掉Wireshark和正在进行捕获。</p><h3 id="20-根据数据包量的主机排名"><a href="#20-根据数据包量的主机排名" class="headerlink" title="20. 根据数据包量的主机排名"></a>20. 根据数据包量的主机排名</h3><p>列出在一段时间根据数据包量来排名连接的主机。 使用简单的命令行通过字段提取来获取IP地址，对事件进行排序和计数。 别忘记限制捕获数量的选项<code>-c</code>。</p><pre><code>sudo tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d &apos;.&apos; | sort | uniq -c | sort -nr | head -n 20tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes200 packets captured261 packets received by filter0 packets dropped by kernel    108 IP 10.10.211.181     91 IP 10.10.1.30      1 IP 10.10.1.50</code></pre><h3 id="21-捕获所有明文密码"><a href="#21-捕获所有明文密码" class="headerlink" title="21. 捕获所有明文密码"></a>21. 捕获所有明文密码</h3><p>在这个命令中，我们专注于纯文本的协议，并使用<code>grep</code>来找出和用户或密码相关的信息。 通过<code>grep</code>的<code>-B5</code>选项来获得前5行输出，这些行是提供了捕获的密码(主机名, IP地址, 系统)的上下文。</p><pre><code>:~$ sudo tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -l -A | egrep -i -B5 &apos;pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=|pass:|user:|username:|password:|login:|pass |user &apos;</code></pre><h3 id="22-DHCP的例子"><a href="#22-DHCP的例子" class="headerlink" title="22. DHCP的例子"></a>22. DHCP的例子</h3><p>最后一个<code>tcpdump</code>的例子是监控DHCP请求和应答的。 DHCP请求是在<strong>端口67</strong>上，应答是在<strong>端口68</strong>上。 使用<code>-v</code>选项可以看到协议的选项和其它的细节。</p><p>:~$ sudo tcpdump -v -n port 67 or 68</p><pre><code>tcpdump: listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes14:37:50.059662 IP (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)    0.0.0.0.68 &gt; 255.255.255.255.67: BOOTP/DHCP, Request from 00:0c:xx:xx:xx:d5, length 300, xid 0xc9779c2a, Flags [none]      Client-Ethernet-Address 00:0c:xx:xx:xx:d5      Vendor-rfc1048 Extensions        Magic Cookie 0x63825363        DHCP-Message Option 53, length 1: Request        Requested-IP Option 50, length 4: 10.10.1.163        Hostname Option 12, length 14: &quot;test-ubuntu&quot;        Parameter-Request Option 55, length 16:           Subnet-Mask, BR, Time-Zone, Default-Gateway          Domain-Name, Domain-Name-Server, Option 119, Hostname          Netbios-Name-Server, Netbios-Scope, MTU, Classless-Static-Route          NTP, Classless-Static-Route-Microsoft, Static-Route, Option 25214:37:50.059667 IP (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)    0.0.0.0.68 &gt; 255.255.255.255.67: BOOTP/DHCP, Request from 00:0c:xx:xx:xx:d5, length 300, xid 0xc9779c2a, Flags [none]      Client-Ethernet-Address 00:0c:xx:xx:xx:d5      Vendor-rfc1048 Extensions        Magic Cookie 0x63825363        DHCP-Message Option 53, length 1: Request        Requested-IP Option 50, length 4: 10.10.1.163        Hostname Option 12, length 14: &quot;test-ubuntu&quot;        Parameter-Request Option 55, length 16:           Subnet-Mask, BR, Time-Zone, Default-Gateway          Domain-Name, Domain-Name-Server, Option 119, Hostname          Netbios-Name-Server, Netbios-Scope, MTU, Classless-Static-Route          NTP, Classless-Static-Route-Microsoft, Static-Route, Option 25214:37:50.060780 IP (tos 0x0, ttl 64, id 53564, offset 0, flags [none], proto UDP (17), length 339)    10.10.1.1.67 &gt; 10.10.1.163.68: BOOTP/DHCP, Reply, length 311, xid 0xc9779c2a, Flags [none]      Your-IP 10.10.1.163      Server-IP 10.10.1.1      Client-Ethernet-Address 00:0c:xx:xx:xx:d5      Vendor-rfc1048 Extensions        Magic Cookie 0x63825363        DHCP-Message Option 53, length 1: ACK        Server-ID Option 54, length 4: 10.10.1.1        Lease-Time Option 51, length 4: 86400        RN Option 58, length 4: 43200        RB Option 59, length 4: 75600        Subnet-Mask Option 1, length 4: 255.255.255.0        BR Option 28, length 4: 10.10.1.255        Domain-Name-Server Option 6, length 4: 10.10.1.1        Hostname Option 12, length 14: &quot;test-ubuntu&quot;        T252 Option 252, length 1: 10        Default-Gateway Option 3, length 4: 10.10.1.1</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些<code>tcpdump</code>的例子，提示和命令是让你对<code>tcpdump</code>可以有的用途做个基本了解。 根据你要实现的目标，有许多更深入的方法或组合不同的捕获过滤器来满足你的实际需求。  </p><p>将<code>tcpdump</code>和Wireshark结合使用会得到很强的功能，特别是你希望深入了解完整的应用层会话时，因为解释器可以组合完整的流。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://hackertarget.com/tcpdump-examples/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hackertarget.com/tcpdump-e
      
    
    </summary>
    
    
      <category term="network" scheme="http://kidnet.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>采集系统和硬件信息的10个命令</title>
    <link href="http://kidnet.github.io/2018/07/03/10_useful_commands_to_collect_system_and_hardware_information/"/>
    <id>http://kidnet.github.io/2018/07/03/10_useful_commands_to_collect_system_and_hardware_information/</id>
    <published>2018-07-03T06:06:11.000Z</published>
    <updated>2018-07-03T08:03:34.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/" target="_blank" rel="external">https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/</a></p></blockquote><p>了解你运行中的Linux系统的硬件组件是一个很好的习惯，这可以帮助你去处理安装软件包或驱动程序时遇到的兼容性问题。 因此在此篇文章中，我们将看到一些实用的命令，可以帮助你提取有关Linux系统和硬件组件的信息。</p><h2 id="1-如何查看Linux系统信息"><a href="#1-如何查看Linux系统信息" class="headerlink" title="1. 如何查看Linux系统信息"></a>1. 如何查看Linux系统信息</h2><p>如果仅是查看系统名称，可以直接使用uname命令，不需要任何选项，或使用<code>uname -s</code>命令打印系统的内核名称。</p><pre><code>tecmint@tecmint ~ $ unameLinux</code></pre><p>要查看网络主机名，使用uname命令的<code>-n</code>选项，如下所示。</p><pre><code>tecmint@tecmint ~ $ uname -ntecmint.com</code></pre><p>要获取关于内核版本的信息，使用<code>-v</code>选项。</p><pre><code>tecmint@tecmint ~ $ uname -v#64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014</code></pre><p>要获取内核发行版本的信息，使用<code>-r</code>选项。</p><pre><code>tecmint@tecmint ~ $ uname -r3.13.0-37-generic</code></pre><p>打印主机硬件平台的类型，使用<code>-m</code>选项。</p><pre><code>tecmint@tecmint ~ $ uname -mx86_64</code></pre><p>以上所有信息可以使用<code>uname -a</code>命令一次打印出来，如下所示。</p><pre><code>tecmint@tecmint ~ $ uname -aLinux tecmint.com 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="2-如何查看Linux系统硬件信息"><a href="#2-如何查看Linux系统硬件信息" class="headerlink" title="2. 如何查看Linux系统硬件信息"></a>2. 如何查看Linux系统硬件信息</h2><p>在这你可以使用<strong>lshw工具</strong>去收集大部分硬件组件信息，如<strong>cpu</strong>, <strong>磁盘</strong>， <strong>内存</strong>， <strong>usb控制器</strong>等信息。  </p><p><strong>lshw</strong>是一个相对小型的工具，它有一些选项是你在提取信息的时候可以使用的。 这些信息是<strong>lshw</strong>从不同的<strong>/proc</strong>文件中收集的。</p><p><strong><font color="#DC143C">注意</font></strong>: 记住<strong>lshw</strong>命令是通过超级用户(<strong>root</strong>)或者<strong>sudo</strong>用户来执行的。</p><p>运行这个命令来打印Linux系统硬件信息:</p><pre><code>tecmint@tecmint ~ $ sudo lshwtecmint.com               description: Notebookproduct: 20354 (LENOVO_MT_20354_BU_idea_FM_Lenovo Z50-70)vendor: LENOVOversion: Lenovo Z50-70serial: 1037407803441width: 64 bitscapabilities: smbios-2.7 dmi-2.7 vsyscall32configuration: administrator_password=disabled boot=normal chassis=notebook family=IDEAPAD frontpanel_password=disabled keyboard_password=disabled power-on_password=disabled sku=LENOVO_MT_20354_BU_idea_FM_Lenovo Z50-70 uuid=E4B1D229-D237-E411-9F6E-28D244EBBD98*-coredescription: Motherboardproduct: Lancer 5A5vendor: LENOVOphysical id: 0version: 31900059WINserial: YB06377069slot: Type2 - Board Chassis Location*-firmwaredescription: BIOSvendor: LENOVOphysical id: 0version: 9BCN26WWdate: 07/31/2014size: 128KiBcapacity: 4032KiBcapabilities: pci upgrade shadowing cdboot bootselect edd int13floppynec int13floppytoshiba int13floppy360 int13floppy1200 int13floppy720 int13floppy2880 int9keyboard int10video acpi usb biosbootspecification uefi......</code></pre><p>你可以通过<code>-short</code>选项来打印一个硬件信息的总结。</p><pre><code>tecmint@tecmint ~ $ sudo lshw -shortH/W path       Device      Class          Description=====================================================system         20354 (LENOVO_MT_20354_BU_idea_FM_Lenovo Z50-70)/0                         bus            Lancer 5A5/0/0                       memory         128KiB BIOS/0/4                       processor      Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz/0/4/b                     memory         32KiB L1 cache/0/4/c                     memory         256KiB L2 cache/0/4/d                     memory         3MiB L3 cache/0/a                       memory         32KiB L1 cache/0/12                      memory         8GiB System Memory/0/12/0                    memory         DIMM [empty]/0/12/1                    memory         DIMM [empty]/0/12/2                    memory         8GiB SODIMM DDR3 Synchronous 1600 MHz (0.6 ns)/0/12/3                    memory         DIMM [empty]/0/100                     bridge         Haswell-ULT DRAM Controller/0/100/2                   display        Haswell-ULT Integrated Graphics Controller/0/100/3                   multimedia     Haswell-ULT HD Audio Controller...</code></pre><p>如果你想生成一个输出作为html文件，你可以使用<code>-html</code>选项。</p><pre><code>tecmint@tecmint ~ $ sudo lshw -html &gt; lshw.html</code></pre><p><img src="Generate-Linux-Hardware-Information.png" alt="Generate-Linux-Hardware-Information"></p><h2 id="3-如何显示CPU信息"><a href="#3-如何显示CPU信息" class="headerlink" title="3. 如何显示CPU信息"></a>3. 如何显示CPU信息</h2><p>要显示CPU的信息，使用lscpu命令，它会显示出你CPU的架构信息，如CPU的数量，cores，CPU系列型号，CPU的缓存，线程等，这些信息都是<strong>lscpu</strong>命令从<strong>sysfs</strong>和<strong>/proc/cpuinfo</strong>获取的。</p><pre><code>tecmint@tecmint ~ $ lscpuArchitecture:          x86_64CPU op-mode(s):        32-bit, 64-bitByte Order:            Little EndianCPU(s):                4On-line CPU(s) list:   0-3Thread(s) per core:    2Core(s) per socket:    2Socket(s):             1NUMA node(s):          1Vendor ID:             GenuineIntelCPU family:            6Model:                 69Stepping:              1CPU MHz:               768.000BogoMIPS:              4788.72Virtualization:        VT-xL1d cache:             32KL1i cache:             32KL2 cache:              256KL3 cache:              3072KNUMA node0 CPU(s):     0-3</code></pre><h2 id="4-如何收集Linux块设备信息"><a href="#4-如何收集Linux块设备信息" class="headerlink" title="4. 如何收集Linux块设备信息"></a>4. 如何收集Linux块设备信息</h2><p>块设备是存储设备，如硬盘，闪存等。 <strong>lsblk</strong>命令是用于生成块设备报告的命令，如下：</p><pre><code>tecmint@tecmint ~ $ lsblkNAME    MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTsda       8:0    0 931.5G  0 disk ├─sda1    8:1    0  1000M  0 part ├─sda2    8:2    0   260M  0 part /boot/efi├─sda3    8:3    0  1000M  0 part ├─sda4    8:4    0   128M  0 part ├─sda5    8:5    0 557.1G  0 part ├─sda6    8:6    0    25G  0 part ├─sda7    8:7    0  14.7G  0 part ├─sda8    8:8    0     1M  0 part ├─sda9    8:9    0 324.5G  0 part /└─sda10   8:10   0   7.9G  0 part [SWAP]sr0      11:0    1  1024M  0 rom</code></pre><p>如果你想查看所有你系统中的块设备，使用<code>-a</code>选项。</p><pre><code>tecmint@tecmint ~ $ lsblk -aNAME    MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTsda       8:0    0 931.5G  0 disk ├─sda1    8:1    0  1000M  0 part ├─sda2    8:2    0   260M  0 part /boot/efi├─sda3    8:3    0  1000M  0 part ├─sda4    8:4    0   128M  0 part ├─sda5    8:5    0 557.1G  0 part ├─sda6    8:6    0    25G  0 part ├─sda7    8:7    0  14.7G  0 part ├─sda8    8:8    0     1M  0 part ├─sda9    8:9    0 324.5G  0 part /└─sda10   8:10   0   7.9G  0 part [SWAP]sdb       8:16   1         0 disk sr0      11:0    1  1024M  0 rom  ram0      1:0    0    64M  0 disk ram1      1:1    0    64M  0 disk ram2      1:2    0    64M  0 disk ram3      1:3    0    64M  0 disk ram4      1:4    0    64M  0 disk ram5      1:5    0    64M  0 disk ram6      1:6    0    64M  0 disk ram7      1:7    0    64M  0 disk ram8      1:8    0    64M  0 disk ram9      1:9    0    64M  0 disk loop0     7:0    0         0 loop loop1     7:1    0         0 loop loop2     7:2    0         0 loop loop3     7:3    0         0 loop loop4     7:4    0         0 loop loop5     7:5    0         0 loop loop6     7:6    0         0 loop loop7     7:7    0         0 loop ram10     1:10   0    64M  0 disk ram11     1:11   0    64M  0 disk ram12     1:12   0    64M  0 disk ram13     1:13   0    64M  0 disk ram14     1:14   0    64M  0 disk ram15     1:15   0    64M  0 disk </code></pre><h2 id="5-如何打印USB控制器的信息"><a href="#5-如何打印USB控制器的信息" class="headerlink" title="5. 如何打印USB控制器的信息"></a>5. 如何打印USB控制器的信息</h2><p><strong>lsusb</strong>命令可以生成USB控制器及所有连接到控制设备的信息报告。</p><pre><code>tecmint@tecmint ~ $ lsusbBus 001 Device 002: ID 8087:8000 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 003 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 002 Device 005: ID 0bda:b728 Realtek Semiconductor Corp. Bus 002 Device 004: ID 5986:0249 Acer, Inc Bus 002 Device 003: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader ControllerBus 002 Device 002: ID 045e:00cb Microsoft Corp. Basic Optical Mouse v2.0Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</code></pre><p>你还可以使用<code>-v</code>选项来生成每个USB设备的详细信息。</p><pre><code>tecmint@tecmint ~ $ lsusb -v</code></pre><h2 id="6-如何打印PCI设备的信息"><a href="#6-如何打印PCI设备的信息" class="headerlink" title="6. 如何打印PCI设备的信息"></a>6. 如何打印PCI设备的信息</h2><p>PCI设备可能包括usb端口，显卡，网络适配器等。 <strong>lspci</strong>工具用于生成关于所有安装在系统上的设备及连接他们的设备的PCI控制器的信息。</p><p>运行以下命令打印关于PCI设备的信息。</p><pre><code>tecmint@tecmint ~ $ lspci00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b)00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b)00:03.0 Audio device: Intel Corporation Haswell-ULT HD Audio Controller (rev 0b)00:14.0 USB controller: Intel Corporation Lynx Point-LP USB xHCI HC (rev 04)00:16.0 Communication controller: Intel Corporation Lynx Point-LP HECI #0 (rev 04)00:1b.0 Audio device: Intel Corporation Lynx Point-LP HD Audio Controller (rev 04)00:1c.0 PCI bridge: Intel Corporation Lynx Point-LP PCI Express Root Port 3 (rev e4)00:1c.3 PCI bridge: Intel Corporation Lynx Point-LP PCI Express Root Port 4 (rev e4)00:1c.4 PCI bridge: Intel Corporation Lynx Point-LP PCI Express Root Port 5 (rev e4)00:1d.0 USB controller: Intel Corporation Lynx Point-LP USB EHCI #1 (rev 04)00:1f.0 ISA bridge: Intel Corporation Lynx Point-LP LPC Controller (rev 04)00:1f.2 SATA controller: Intel Corporation Lynx Point-LP SATA Controller 1 [AHCI mode] (rev 04)00:1f.3 SMBus: Intel Corporation Lynx Point-LP SMBus Controller (rev 04)01:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 10)02:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8723BE PCIe Wireless Network Adapter03:00.0 3D controller: NVIDIA Corporation GM108M [GeForce 840M] (rev a2)</code></pre><p>使用<code>-t</code>参数产生一个树形格式的输出。</p><pre><code>tecmint@tecmint ~ $ lspci -t-[0000:00]-+-00.0+-02.0+-03.0+-14.0+-16.0+-1b.0+-1c.0-[01]----00.0+-1c.3-[02]----00.0+-1c.4-[03]----00.0+-1d.0+-1f.0+-1f.2\-1f.3</code></pre><p>使用<code>-v</code>参数产生每个连接设备的详细信息。</p><pre><code>tecmint@tecmint ~ $ lspci -v00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b)Subsystem: Lenovo Device 3978Flags: bus master, fast devsel, latency 0Capabilities: 00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b) (prog-if 00 [VGA controller])Subsystem: Lenovo Device 380dFlags: bus master, fast devsel, latency 0, IRQ 62Memory at c3000000 (64-bit, non-prefetchable) [size=4M]Memory at d0000000 (64-bit, prefetchable) [size=256M]I/O ports at 6000 [size=64]Expansion ROM at  [disabled]Capabilities: Kernel driver in use: i915.....</code></pre><h2 id="7-如何打印SCSI设备的信息"><a href="#7-如何打印SCSI设备的信息" class="headerlink" title="7. 如何打印SCSI设备的信息"></a>7. 如何打印SCSI设备的信息</h2><p>使用<strong>lsscsi</strong>命令显示所有scsi/sata设备。如果系统中没有安装此命令，运行如下命令来安装它。</p><pre><code>$ sudo apt-get install lsscsi        [on Debian derivatives]# yum install lsscsi                 [On RedHat based systems]# dnf install lsscsi                 [On Fedora 21+ Onwards]</code></pre><p>安装之后，像如下所示来运行<strong>lsscsi</strong>命令:</p><pre><code>tecmint@tecmint ~ $ lsscsi[0:0:0:0]    disk    ATA      ST1000LM024 HN-M 2BA3  /dev/sda [1:0:0:0]    cd/dvd  PLDS     DVD-RW DA8A5SH   RL61  /dev/sr0 [4:0:0:0]    disk    Generic- xD/SD/M.S.       1.00  /dev/sdb </code></pre><p>使用<code>-s</code>参数显示设备容量。</p><pre><code>tecmint@tecmint ~ $ lsscsi -s[0:0:0:0]    disk    ATA      ST1000LM024 HN-M 2BA3  /dev/sda   1.00TB[1:0:0:0]    cd/dvd  PLDS     DVD-RW DA8A5SH   RL61  /dev/sr0        -[4:0:0:0]    disk    Generic- xD/SD/M.S.       1.00  /dev/sdb        -</code></pre><h2 id="8-如何打印关于SATA设备的信息"><a href="#8-如何打印关于SATA设备的信息" class="headerlink" title="8. 如何打印关于SATA设备的信息"></a>8. 如何打印关于SATA设备的信息</h2><p>如下所示，使用<strong>hdparm</strong>工具可以找到你系统中sata设备的一些信息。 在下面这个例子中， 我们用了系统中块设备<strong>/dev/sda1</strong>。</p><pre><code>tecmint@tecmint ~ $ sudo hdparm /dev/sda1/dev/sda1:multcount     =  0 (off)IO_support    =  1 (32-bit)readonly      =  0 (off)readahead     = 256 (on)geometry      = 56065/255/63, sectors = 2048000, start = 2048</code></pre><p>要打印关于设备的柱面，磁头，扇区，大小和设备的起始偏移信息等，使用<code>-g</code>参数。</p><pre><code>tecmint@tecmint ~ $ sudo hdparm -g /dev/sda1/dev/sda1:geometry      = 56065/255/63, sectors = 2048000, start = 2048</code></pre><h2 id="9-如何打印Linux文件系统的信息"><a href="#9-如何打印Linux文件系统的信息" class="headerlink" title="9. 如何打印Linux文件系统的信息"></a>9. 如何打印Linux文件系统的信息</h2><p>使用<strong>fdisk</strong>命令来获取文件系统的分区信息。 尽管<strong>fdisk</strong>命令的主要功能是修改文件系统分区，但它也可以用于去显示在系统中不同分区的信息。</p><pre><code>tecmint@tecmint ~ $ sudo fdisk -lWARNING: GPT (GUID Partition Table) detected on &apos;/dev/sda&apos;! The util fdisk doesn&apos;t support GPT. Use GNU Parted.Disk /dev/sda: 1000.2 GB, 1000204886016 bytes255 heads, 63 sectors/track, 121601 cylinders, total 1953525168 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisk identifier: 0xcee8ad92Device Boot      Start         End      Blocks   Id  System/dev/sda1               1  1953525167   976762583+  ee  GPTPartition 1 does not start on physical sector boundary.</code></pre><h2 id="10-如何提取硬件组件的信息"><a href="#10-如何提取硬件组件的信息" class="headerlink" title="10. 如何提取硬件组件的信息"></a>10. 如何提取硬件组件的信息</h2><p>你可以使用<strong>dmidecode_</strong>程序通过从DMI表中读取数据来提取硬件信息。</p><p>要打印关于内存信息，运行以下命令，并且要以超级管理员的权限运行。</p><pre><code>tecmint@tecmint ~ $ sudo dmidecode -t memory# dmidecode 2.12# SMBIOS entry point at 0xaaebef98SMBIOS 2.7 present.Handle 0x0005, DMI type 5, 24 bytesMemory Controller InformationError Detecting Method: NoneError Correcting Capabilities:NoneSupported Interleave: One-way InterleaveCurrent Interleave: One-way InterleaveMaximum Memory Module Size: 8192 MBMaximum Total Memory Size: 32768 MBSupported Speeds:OtherSupported Memory Types:OtherMemory Module Voltage: UnknownAssociated Memory Slots: 40x00060x00070x00080x0009Enabled Error Correcting Capabilities:None...</code></pre><p>运行以下命令打印系统相关信息。</p><pre><code>tecmint@tecmint ~ $ sudo dmidecode -t system# dmidecode 2.12# SMBIOS entry point at 0xaaebef98SMBIOS 2.7 present.Handle 0x0001, DMI type 1, 27 bytesSystem InformationManufacturer: LENOVOProduct Name: 20354Version: Lenovo Z50-70Serial Number: 1037407803441UUID: 29D2B1E4-37D2-11E4-9F6E-28D244EBBD98Wake-up Type: Power SwitchSKU Number: LENOVO_MT_20354_BU_idea_FM_Lenovo Z50-70Family: IDEAPAD...</code></pre><p>运行以下命令打印BIOS相关信息。</p><pre><code>tecmint@tecmint ~ $ sudo dmidecode -t bios# dmidecode 2.12# SMBIOS entry point at 0xaaebef98SMBIOS 2.7 present.Handle 0x0000, DMI type 0, 24 bytesBIOS InformationVendor: LENOVOVersion: 9BCN26WWRelease Date: 07/31/2014Address: 0xE0000Runtime Size: 128 kBROM Size: 4096 kBCharacteristics:PCI is supportedBIOS is upgradeableBIOS shadowing is allowedBoot from CD is supportedSelectable boot is supportedEDD is supportedJapanese floppy for NEC 9800 1.2 MB is supported (int 13h)Japanese floppy for Toshiba 1.2 MB is supported (int 13h)5.25&quot;/360 kB floppy services are supported (int 13h)5.25&quot;/1.2 MB floppy services are supported (int 13h)3.5&quot;/720 kB floppy services are supported (int 13h)3.5&quot;/2.88 MB floppy services are supported (int 13h)8042 keyboard services are supported (int 9h)CGA/mono video services are supported (int 10h)ACPI is supportedUSB legacy is supportedBIOS boot specification is supportedTargeted content distribution is supportedUEFI is supportedBIOS Revision: 0.26Firmware Revision: 0.26...</code></pre><p>运行以下命令打印关于处理器的信息。</p><pre><code>tecmint@tecmint ~ $ sudo dmidecode -t processor# dmidecode 2.12# SMBIOS entry point at 0xaaebef98SMBIOS 2.7 present.Handle 0x0004, DMI type 4, 42 bytesProcessor InformationSocket Designation: U3E1Type: Central ProcessorFamily: Core i5Manufacturer: Intel(R) CorporationID: 51 06 04 00 FF FB EB BFSignature: Type 0, Family 6, Model 69, Stepping 1Flags:...</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了以上的命令，还有很多方法可以来获取系统硬件组件信息。 大部分的命令是从<strong>/proc</strong>目录下的文件来提取的系统信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/&quot; target=&quot;_blank&quot; rel=&quot;e
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://kidnet.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Netdata监控Nginx性能</title>
    <link href="http://kidnet.github.io/2018/07/02/netdata/"/>
    <id>http://kidnet.github.io/2018/07/02/netdata/</id>
    <published>2018-07-02T02:32:11.000Z</published>
    <updated>2018-07-02T04:16:10.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.tecmint.com/monitor-nginx-performance-using-netdata-on-centos-7/" target="_blank" rel="external">https://www.tecmint.com/monitor-nginx-performance-using-netdata-on-centos-7/</a></p></blockquote><p><strong>Netdata</strong>是一款开源软件，可扩展，自适应，可定制，是通过收集并可视化Linux系统的指标进行实时性健康监测的工具，功能强大。可以工作于各种设备。</p><p>这款系统健康监测工具，可以让你了解系统，应用程序或服务(如Web服务)的运行状况，以及分析它们为什么会有性能问题或一些异常问题。它能有效并高效的利用CPU及其它系统资源。</p><p>在本篇文章中我们将会说明如何使用<strong>Netdata</strong>在CentOS 7或者RHEL 7的发行版上监控Nginx HTTP web server的性能。</p><p>通过本文，最后可以看到利用<strong>Netdata</strong>可以可视化的监控Nginx Web服务的连接，请求，状态和连接速率。</p><h2 id="第一步-安装Nginx"><a href="#第一步-安装Nginx" class="headerlink" title="第一步: 安装Nginx"></a>第一步: 安装Nginx</h2><p><strong>1.</strong> 首先安装EPEL库，然后使用YUM从EPEL库中安装Nginx HTTP服务。</p><pre><code># yum install epel-release# yum install nginx</code></pre><p><strong>2.</strong> 检查安装好的Nginx版本，它应该通过”--with-http_stub_status_module”配置参数编译了<strong>stub_status</strong>模块, 如下面截屏所示。</p><pre><code># nginx -v</code></pre><p><img src="check-nginx-version.png" alt="Check Nginx Version"></p><p><strong>3.</strong> Nginx安装成功后，启动并且设置自动启动，在系统启动后确保Nginx启动并运行。</p><pre><code># systemctl status nginx# systemctl enable nginx# systemctl status nginx</code></pre><p><strong>4.</strong> 如果你使用<code>firwalld</code>动态防火墙，你需要开放web服务器监听的<strong>80(HTTP)</strong>和<strong>443(HTTPS)</strong>端口，允许客户端的连接请求。</p><pre><code># firewall-cmd --permanent --add-port=80/tcp# firewall-cmd --permanent --add-port=443/tcp# firewall-cmd --reload </code></pre><h2 id="第二步-启用Nginx-Stub-Status模块"><a href="#第二步-启用Nginx-Stub-Status模块" class="headerlink" title="第二步: 启用Nginx Stub_Status模块"></a>第二步: 启用Nginx Stub_Status模块</h2><p><strong>5.</strong> 现在启用netdata从Nginx Web服务中手机指标的<strong>stab_status</strong>模块。</p><pre><code># vim /etc/nginx/nginx.conf</code></pre><p>拷贝并粘贴以下<strong>location</strong>配置到你的server配置段中，如下面截屏所示。</p><pre><code>location /stub_status {stub_status;allow 127.0.0.1;    #only allow requests from localhostdeny all;        #deny all other hosts    }</code></pre><p><img src="enable-nginx_status-module.png" alt="Enable Nginx Status Module"></p><p><strong>6.</strong> 接下来，测试新的nginx配置是否有错误，并且重启nginx服务使改动的配置生效。</p><pre><code># nginx -t# systemctl restart nginx</code></pre><p><strong>7.</strong> 然后，使用命令行工具<code>curl</code>测试nginx状态页。</p><pre><code># curl http://127.0.0.1/stub_status</code></pre><p><img src="Check-Nginx-Status-Page.png" alt="Check Nginx Status Page"></p><h2 id="第三步-安装Netdata"><a href="#第三步-安装Netdata" class="headerlink" title="第三步: 安装Netdata"></a>第三步: 安装Netdata</h2><p><strong>8.</strong> 在这你可以使用一行shell命令来通这个项目在github仓库中的脚本来安装netdata。这行命令本将下载一个脚本去检测你Linux的发行版并安装构建netdata所需的系统软件包，然后，抓取最新的netdata源码，构建并且安装它。</p><p>使用下面的命令去启动kickstart脚本，<code>all</code>这个选项表示允许所有netdata的插件安装必需的软件包，包括Nginx的所有软件包。</p><pre><code># bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh) all</code></pre><p>如果你不是以root身份访问系统，系统会提示你输入<code>sudo</code>命令的用户密码，并且你还需要按<strong>[Enter]</strong>键确认某些操作。</p><p><img src="Install-Netdata-on-CentOS-7.png" alt="Install Netdata on CentOS-7"></p><p><strong>8.</strong> 构建并安装netdata之后，这个脚本将自动通过<strong>systemd</strong>启动netdata服务，并开启随系统启动后自动启动。默认Netdata监听在<strong>19999</strong>端口。</p><p><img src="Netdata-Installation-Summary.png" alt="Netdata Installation Summary"></p><p><strong>9.</strong> 接着，在防火墙开启访问netdata web UI的端口<strong>19999</strong>。</p><pre><code># firewall-cmd --permanent --add-port=19999/tcp# firewall-cmd --reload</code></pre><h2 id="第四步-配置Netdata监控Nginx性能"><a href="#第四步-配置Netdata监控Nginx性能" class="headerlink" title="第四步: 配置Netdata监控Nginx性能"></a>第四步: 配置Netdata监控Nginx性能</h2><p><strong>9.</strong> Nginx插件的netdata配置文件在<strong>/etc/netdata/python.d/nginx.conf</strong>, 以_YaML格式编写。</p><pre><code># vim /etc/netdata/python.d/nginx.conf</code></pre><p>这个默认的配置已经可以满足你去监控Nginx web服务的需求。</p><p><img src="Netdata-Nginx-Configuration.png" alt="Netdata Nginx Configuration"></p><p>在实际中请在阅读文档后，去修改netdata的配置文件，并在修改后重启netdata服务使修改生效。</p><pre><code># systemctl restart netdata</code></pre><h2 id="第五步-使用Netdata监控Nginx性能"><a href="#第五步-使用Netdata监控Nginx性能" class="headerlink" title="第五步: 使用Netdata监控Nginx性能"></a>第五步: 使用Netdata监控Nginx性能</h2><p><strong>10.</strong> 现在打开一个web浏览器并且使用下面的URL去访问netdata的web UI。</p><pre><code>http://domain_name:19999ORhttp://SERVER_IP:19999</code></pre><p>从右侧的插件列表中，点击”<strong>nginx local</strong>“查看你监控的Nginx web服务。 你会看到一个如下图所示的可视化的活动连接数，请求数，状态和连接速率。</p><p><img src="monitor-nginx-web-server-using-netdata.png" alt="monitor nginx web server using netdata"></p><p><strong>Netdata的Github仓库</strong>: <a href="https://github.com/firehol/netdata" target="_blank" rel="external">https://github.com/firehol/netdata</a></p><p>最后，Netdata是一个针对Linux系统的实时分布式性能和健康监测的工具。 在本文中，我们已经展示了如何在CentOS 7上使用netdata监控Nginx Web服务器的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://www.tecmint.com/monitor-nginx-performance-using-netdata-on-centos-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
      
    
    </summary>
    
    
      <category term="web server" scheme="http://kidnet.github.io/tags/web-server/"/>
    
  </entry>
  
  <entry>
    <title>ngxtop：Linux中实时监控Nginx Log</title>
    <link href="http://kidnet.github.io/2018/06/27/ngxtop/"/>
    <id>http://kidnet.github.io/2018/06/27/ngxtop/</id>
    <published>2018-06-27T02:59:11.000Z</published>
    <updated>2018-06-27T07:20:38.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.tecmint.com/ngxtop-monitor-nginx-log-files-in-real-time-in-linux" target="_blank" rel="external">https://www.tecmint.com/ngxtop-monitor-nginx-log-files-in-real-time-in-linux</a></p></blockquote><p>ngxtop是一个免费的开源工具，简单，灵活，可配置的，并且易于使用，类似于top一样，是对Nginx服务进行实时监控的工具。它通过分析nginx access log来获取数据(默认路径是/var/log/nginx/access.log)并且显示对于你的nginx服务器有用的一些指标（如:访问量，访问流量，http各个状态的统计等）。</p><h2 id="在Linux中的安装和使用"><a href="#在Linux中的安装和使用" class="headerlink" title="在Linux中的安装和使用"></a>在Linux中的安装和使用</h2><p>ngxtop是使用python语言开发的一个工具，安装ngxtop，首先需要安装pip（或其他python包的安装工具，或者直接下载源码包进行安装），如果你已经安装pip在你的系统上，你可以使用以下的命令安装ngxtop。</p><pre><code>$ sudo pip install ngxtop</code></pre><h2 id="监控Nginx服务的请求状态"><a href="#监控Nginx服务的请求状态" class="headerlink" title="监控Nginx服务的请求状态"></a>监控Nginx服务的请求状态</h2><p>现在你已经安装好了ngxtop，最简单的方法来运行它，不需要任何参数。它将会解析/var/log/nginx/access.log并且默认运行在实时模式下(会监控新写入access log的每一行)。</p><pre><code>$ sudo ngxtop</code></pre><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><pre><code>running for 411 seconds, 64332 records processed: 156.60 req/secSummary:|   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx ||---------+------------------+-------+-------+-------+-------||   64332 |         2775.251 | 61262 |  2994 |    71 |     5 |Detailed:| request_path                             |   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx ||------------------------------------------+---------+------------------+-------+-------+-------+-------|| /abc/xyz/xxxx                            |   20946 |          434.693 | 20935 |     0 |    11 |     0 || /xxxxx.json                              |    5633 |         1483.723 |  5633 |     0 |     0 |     0 || /xxxxx/xxx/xxxxxxxxxxxxx                 |    3629 |         6835.499 |  3626 |     0 |     3 |     0 || /xxxxx/xxx/xxxxxxxx                      |    3627 |        15971.885 |  3623 |     0 |     4 |     0 || /xxxxx/xxx/xxxxxxx                       |    3624 |         7830.236 |  3621 |     0 |     3 |     0 || /static/js/minified/utils.min.js         |    3031 |         1781.155 |  2104 |   927 |     0 |     0 || /static/js/minified/xxxxxxx.min.v1.js    |    2889 |         2210.235 |  2068 |   821 |     0 |     0 || /static/tracking/js/xxxxxxxx.js          |    2594 |         1325.681 |  1927 |   667 |     0 |     0 || /xxxxx/xxx.html                          |    2521 |          573.597 |  2520 |     0 |     1 |     0 || /xxxxx/xxxx.json                         |    1840 |          800.542 |  1839 |     0 |     1 |     0 |</code></pre><p>使用<code>Ctrl+C</code>退出。</p><h2 id="解析不同的访问日志"><a href="#解析不同的访问日志" class="headerlink" title="解析不同的访问日志"></a>解析不同的访问日志</h2><p>你可以使用<code>-l</code>参数解析不同的访问日志，如特定的网站或Web应用程序，如下所示。</p><pre><code>$ sudo ngxtop -l /var/log/nginx/site1/access.log</code></pre><h3 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h3><pre><code>running for 20 seconds, 3215 records processed: 159.62 req/sectop remote_addr| remote_addr     |   count ||-----------------+---------|| 118.173.177.161 |      20 || 110.78.145.3    |      16 || 171.7.153.7     |      16 || 180.183.67.155  |      16 || 183.89.65.9     |      16 || 202.28.182.5    |      16 || 1.47.170.12     |      15 || 119.46.184.2    |      15 || 125.26.135.219  |      15 || 125.26.213.203  |      15 |</code></pre><h2 id="使用特殊的Log格式"><a href="#使用特殊的Log格式" class="headerlink" title="使用特殊的Log格式"></a>使用特殊的Log格式</h2><p>要使用nginx配置文件中的log_format指定的日志格式，用参数<code>-f</code>来指定，如下所示</p><pre><code>$ sudo ngxtop -f main -l /var/log/nginx/site1/access.log</code></pre><h2 id="从远程服务器解析Apache的Log"><a href="#从远程服务器解析Apache的Log" class="headerlink" title="从远程服务器解析Apache的Log"></a>从远程服务器解析Apache的Log</h2><p>使用通用格式从远程服务器来解析Apache的log文件，用类似以下的命令(指定你的用户名和远程服务器的IP)。</p><pre><code>$ ssh user@remote_server tail -f /var/log/apache2/access.log | ngxtop -f common</code></pre><h3 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h3><pre><code>running for 20 seconds, 1068 records processed: 53.01 req/secSummary:|   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx ||---------+------------------+-------+-------+-------+-------||    1068 |        28026.763 |  1029 |    20 |    19 |     0 |Detailed:| request_path                             |   count |   avg_bytes_sent |   2xx |   3xx |   4xx |   5xx ||------------------------------------------+---------+------------------+-------+-------+-------+-------|| /xxxxxxxxxx                              |     199 |        55150.402 |   199 |     0 |     0 |     0 || /xxxxxxxx/xxxxx                          |     167 |        47591.826 |   167 |     0 |     0 |     0 || /xxxxxxxxxxxxx/xxxxxx                    |      25 |         7432.200 |    25 |     0 |     0 |     0 || /xxxx/xxxxx/x/xxxxxxxxxxxxx/xxxxxxx      |      22 |          698.727 |    22 |     0 |     0 |     0 || /xxxx/xxxxx/x/xxxxxxxxxxxxx/xxxxxx       |      19 |         7431.632 |    19 |     0 |     0 |     0 || /xxxxx/xxxxx/                            |      18 |         7840.889 |    18 |     0 |     0 |     0 || /xxxxxxxx/xxxxxxxxxxxxxxxxx              |      15 |         7356.000 |    15 |     0 |     0 |     0 || /xxxxxxxxxxx/xxxxxxxx                    |      15 |         9978.800 |    15 |     0 |     0 |     0 || /xxxxx/                                  |      14 |            0.000 |     0 |    14 |     0 |     0 || /xxxxxxxxxx/xxxxxxxx/xxxxx               |      13 |        20530.154 |    13 |     0 |     0 |     0 |</code></pre><p>更多的使用选项，请使用下面的命令来查看ngxtop的帮助信息。</p><pre><code>$ ngxtop -h</code></pre><p><strong>ngxtop项目Github的地址: <a href="https://github.com/lebinh/ngxtop" target="_blank" rel="external">https://github.com/lebinh/ngxtop</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://www.tecmint.com/ngxtop-monitor-nginx-log-files-in-real-time-in-linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
      
    
    </summary>
    
    
      <category term="web server" scheme="http://kidnet.github.io/tags/web-server/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像中开启SSH</title>
    <link href="http://kidnet.github.io/2018/03/02/docker-sshd/"/>
    <id>http://kidnet.github.io/2018/03/02/docker-sshd/</id>
    <published>2018-03-02T09:23:32.000Z</published>
    <updated>2018-03-02T09:43:56.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有需求在镜像中需要开启SSH服务，本文介绍如何在将SSH服务器安装到镜像中。</p><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>先选择一个基础镜像，然后安装systemd及openssh服务(注意要清理安装遗留的一些问文件，尽量减小镜像尺寸)。</p><p>1、 Dockerfile:</p><p>要启动SSH需要挂载本地系统的<code>/sys/fs/cgroup</code>，及启动时需要使用<code>init</code>启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">FROM centos</div><div class="line">MAINTAINER “Yourname&quot; &lt;youremail@address.com&gt;</div><div class="line">ENV container docker</div><div class="line">RUN yum -y update \</div><div class="line">&amp;&amp; yum -y install openssh-server \</div><div class="line">&amp;&amp; yum -y install openssh-client \</div><div class="line">&amp;&amp; yum -y install systemd \ </div><div class="line">&amp;&amp; yum clean all \</div><div class="line">&amp;&amp; (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == systemd-tmpfiles-setup.service ] || rm -f $i; done) \</div><div class="line">&amp;&amp; rm -f /lib/systemd/system/multi-user.target.wants/* \</div><div class="line">&amp;&amp; rm -f /etc/systemd/system/*.wants/* \</div><div class="line">&amp;&amp; rm -f /lib/systemd/system/local-fs.target.wants/* \</div><div class="line">&amp;&amp; rm -f /lib/systemd/system/sockets.target.wants/*udev* \</div><div class="line">&amp;&amp; rm -f /lib/systemd/system/sockets.target.wants/*initctl* \</div><div class="line">&amp;&amp; rm -f /lib/systemd/system/basic.target.wants/* \</div><div class="line">&amp;&amp; rm -f /lib/systemd/system/anaconda.target.wants/*</div><div class="line">RUN systemctl enable sshd</div><div class="line">RUN echo &quot;your root password&quot; | passwd --stdin root</div><div class="line">VOLUME [ &quot;/sys/fs/cgroup&quot; ]</div><div class="line">CMD [ &quot;/usr/sbin/init&quot; ]</div></pre></td></tr></table></figure><p>2、 制作镜像:<br>通过Docker生成新的镜像.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build --rm -t centos-sshd:7.3 - &lt; [Dockerfile name]</div></pre></td></tr></table></figure><p>3、 启动容器:</p><p>启动容器需要使用<code>--privileged</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$  docker run --privileged -ti -e container=docker -p 127.0.0.1:30022:22 centos-sshd:7.3</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;有需求在镜像中需要开启SSH服务，本文介绍如何在将SSH服务器安装到镜像中。&lt;/p&gt;
&lt;h2 id=&quot;镜像制作&quot;&gt;&lt;a href=&quot;#镜像制
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(七):Harbor(二)</title>
    <link href="http://kidnet.github.io/2017/12/13/docker-harbor-https/"/>
    <id>http://kidnet.github.io/2017/12/13/docker-harbor-https/</id>
    <published>2017-12-13T02:23:32.000Z</published>
    <updated>2017-12-13T06:32:43.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Harbor并没有搭载任何的证书，所以默认只提供HTTP的服务。但，在生产环境中强烈建议使用HTTPS。 Harbor有一个Nginx实例给所有的服务做反向代理，你可以使用<code>prepare</code>脚本去配置Nginx开启https。</p><h2 id="获取一张证书"><a href="#获取一张证书" class="headerlink" title="获取一张证书"></a>获取一张证书</h2><p>假设你的仓库的配置的<strong>hostname</strong>是<strong>reg.yourdomain.com</strong>, 并且它的DNS记录指向了运行Harbor的主机。 首先，需要有一张从CA签发的证书， 这张证书通常包含a.crt文件和a.key文件，例如: <strong>yourdomain.com.crt</strong>和<strong>yourdomain.com.key</strong>。</p><p>在一个测试或者开发环境中，你可能选择使用自签发的证书来替代从一个CA签发的证书。 下面的命令可以生成一张你自己的证书:</p><ol><li>创建自己的CA证书:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ openssl req \</div><div class="line">  -newkey rsa:4096 -nodes -sha256 -keyout ca.key \</div><div class="line">  -x509 -days 365 -out ca.crt</div></pre></td></tr></table></figure><ol><li>生成一个证书签名请求:</li></ol><p>如果你使用像<strong>reg.yourdomain.com</strong>这样的FQDN去访问你仓库，你就必须使用<strong>reg.yourdomain.com</strong>作为CN(Common Name)。 否则， 如果你使用IP去连接仓库的主机， CN可以任意填写，例如：你的名字等等:</p><pre><code>$ openssl req \    -newkey rsa:4096 -nodes -sha256 -keyout yourdomain.com.key \    -out yourdomain.com.csr</code></pre><ol><li>生成你仓库的主机的证书:</li></ol><p>如果你使用像<strong>reg.yourdomain.com</strong>这样的FQDN去访问你的仓库，运行下面的命令去生成你仓库的主机的证书:</p><pre><code>$ openssl x509 -req -days 365 \    -in yourdomain.com.csr -CA ca.csr -CAKey ca.key -CAcreateserial \    -out yourdomain.com.crt</code></pre><p>如果是使用IP地址(如:192.168.1.101)去访问你的仓库， 你需要使用下面的命令:</p><pre><code>$ echo &quot;subjectAltName = IP:192.168.1.101&quot; &gt; extfile.cnf$ openssl x509 -req -days 365 \    -in yourdomain.com.csr -CA ca.crt -CAKey ca.key -CAcreateserial -extfile extfile.cn \    -out yourdomain.com.crt</code></pre><h2 id="配置并安装"><a href="#配置并安装" class="headerlink" title="配置并安装"></a>配置并安装</h2><p>得到<strong>yourdomain.com.crt</strong>和<strong>yourdoman.com.key</strong>文件后，你可以把他们放入指定的文件夹，如: <code>/root/cert/</code>:</p><pre><code>$ cp yourdomain.com.csr /root/cert/$ cp yourdomain.com.key /root/cert/</code></pre><p>接下来，编辑<code>make/harbor.cfg</code>文件， 更新<code>hostname</code>和<code>protocol</code>， 并更新属性<code>ssl_cert</code>和<code>ssl_cert_key</code>:</p><pre><code>#set hostnamehostname = reg.yourdomain.com#set ui_url_protocolui_url_protocol = https......#The path of cert and key files for nginx, they are applied only the protocol is set to https ssl_cert = /root/cert/yourdomain.com.crtssl_cert_key = /root/cert/yourdomain.com.key</code></pre><p>生成Harbor的配置文件:</p><pre><code>$ ./prepare</code></pre><p>如果Harbor已经正在运行，先停止并移除所有存在的实例。 你的image数据会保留在文件系统中。</p><pre><code>$ docker-compose down -v</code></pre><p>最后，重启Harbor:</p><pre><code>$ docker-compose up -d</code></pre><p>在配置好Harbor HTTPS后，可以通过以下几步进行验证:</p><ol><li>打开浏览器，并输入<a href="https://reg.yourdomain.com。" target="_blank" rel="external">https://reg.yourdomain.com。</a> 应该会显示Harbor的界面。</li><li>在安装了Docker的主机上，并确认没有配置”-insecure-registry”。 将以上步骤生成的ca.crt拷贝到这个Docker主机的<code>/etc/docker/certs.d/reg.yourdomain.com</code>(或者是你仓库主机的IP)目录, 如果这个目录不存在，需要手动创建一下。如果仓库的nginx监听端口(443)改为其它端口，需要更改这个目录的名字为<code>/etc/docker/certs.d/reg.yourdomain.com:port</code>(或者仓库主机IP:port)。然后运行docker命令去进行验证:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker login reg.yourdomain.com</div></pre></td></tr></table></figure><p>如果你已经更改nginx的监听端口，需要在登录时将端口添加上，如下:</p><pre><code>$ docker login reg.yourdomain.com:port</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Harbor并没有搭载任何的证书，所以默认只提供HTTP的服务。但，在生产环境中强烈建议使用HTTPS。 Harbor有一个Nginx实例给
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(六):Harbor(一)</title>
    <link href="http://kidnet.github.io/2017/11/29/docker-harbor/"/>
    <id>http://kidnet.github.io/2017/11/29/docker-harbor/</id>
    <published>2017-11-29T03:06:22.000Z</published>
    <updated>2017-12-13T06:32:35.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Registry只能通过API进行管理，然而第三方开发了一些开源的平台来作为私有镜像库管理(类似于github)，可以对用户、权限、镜像库及镜像进行管理，并且有图形化的界面，方便使用。</p><h2 id="开源管理平台"><a href="#开源管理平台" class="headerlink" title="开源管理平台"></a>开源管理平台</h2><p>开源的私有库的管理平台不是很多(可能是我没找到)，主要看到2个，一个是SUSE的<a href="http://port.us.org" target="_blank" rel="external">Portus</a>，另一个是VMWare的<a href="https://vmware.github.io/harbor" target="_blank" rel="external">Harbor</a>。这里只介绍Harbor的部署及应用。</p><h2 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h2><p>Harbor是用于存储和分发Docker镜像的企业级Registry服务器，具有以下功能和特性: </p><ul><li>基于角色的权限控制: 用户和docker镜像库通过”项目”关联在一起，一个用户在同一个命名空间下可以有不同的权限。</li><li>镜像复制: 多个Registry实例之间可以进行镜像复制，可以用于负载均衡，高可用及混合多用的场景。</li><li>用户图形化接口: 用户可以通过图形化界面更轻松的浏览和搜索docker仓库，管理项目和命名空间。</li><li>支持AD/LDAP： Harbor支持商业的AD/LDAP的用户认证及管理。</li><li>审计: 所有对于镜像库的操作都是可以被追踪的并可以被审计。</li><li>国际化: 已经支持英语、中文、德语、日语和俄语。</li><li>RESTful API: Harbor大部分的管理操作已经提供了RESTful API。</li><li>部署方便: 提供了在线和离线的安装方式。</li></ul><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><ul><li>在线安装包: 在线安装包会从Docker公共库下载Harbor的镜像，因此在线安装包会很小。</li><li>离线安装包: 如果主机无法连接到互联网，可以使用离线安装包，离线安装包包含了每一个镜像的构建，所以这个安装包会很大。</li></ul><p><a href="https://github.com/vmware/harbor/releases" target="_blank" rel="external">官方安装包下载地址</a></p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>Harbor是使用镜像通过Docker容器部署的，因此需要系统支持Docker。主机需要Python，Docker及Docker Compose。</p><ul><li>Python版本需要2.7版本或更高版本。</li><li>Dockery引擎需要1.10或更高版本。(<a href="https://kidnet.github.io/2017/09/19/docker-install/">Docker安装</a>)</li><li>Docker Compose需要1.6.0或更高版本。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装过程为以下几步:</p><ul><li>下载安装包；</li><li>配置<code>harbor.cfg</code>;</li><li>运行<code>install.sh</code>安装并运行Harbor;</li></ul><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h3><p>从官方发布地址下载安装包，选择在线或离线的安装包。使用<code>tar</code>命令解压缩这个包。(本文档都是使用离线包进行安装。)</p><p>在线包:</p><pre><code>$ tar -xzvf harbor-online-installer-&lt;version&gt;.tgz</code></pre><p>离线包:</p><pre><code>$ tar -xzvf harbor-offline-installer-&lt;version&gt;.tgz</code></pre><h3 id="2-配置Harbor"><a href="#2-配置Harbor" class="headerlink" title="2. 配置Harbor"></a>2. 配置Harbor</h3><p><code>harbor.cfg</code>中包含了配置项。</p><p>在<code>harbor.cfg</code>中有2部分配置项，必须配置和可选配置。</p><ul><li>必须配置: 这些配置是必须在配置文件中进行配置的。如果用户更新<code>harbor.cfg</code>中的这些配置将且运行<code>install.sh</code>脚本的时候会重新安装Harbor，这些配置将会立即生效。</li><li>可选配置: 这些配置是可选的，用户可以使用这些默认的配置，也可以在启动Harbor后通过Web UI进行配置。如果可选配置在<code>harbor.cfg</code>中更新了，这些配置只在Harbor第一次启动的时候生效。之后在<code>harbor.cfg</code>中更新这些配置就不会生效了。</li></ul><p><strong>注意</strong>: 如果选择通过UI来配置可选项，需要确认Harbor已经启动后，再去进行配置。在可选配置中，有一个特殊的配置项，<code>auth_mode</code>必须在注册用户或创建新用户之前配置成需要的认证模式。如果系统中已经存在用户(admin用户除外)，<code>auth_mode</code>是不能被修改的。</p><h4 id="必须配置项"><a href="#必须配置项" class="headerlink" title="必须配置项:"></a>必须配置项:</h4><ul><li><strong>hostname</strong>: 运行Harbor的服务器的hostname，用于访问UI和提供Registry服务。 这个配置可以是IP地址或者是域名，<code>10.0.100.2</code>或者<code>test-harbor.test.com</code>。不要使用<code>localhost</code>或者<code>127.0.0.1</code>，因为Registry服务需要被其它客户端访问。</li><li><strong>ui_url_protocol</strong>: (值可以是<strong>http</strong>或者<strong>https</strong>，默认为<strong>http</strong>)这个协议用于访问UI和token/notification服务。如果认证被启用，这个配置必须是<em>https</em>。设置https协议后面会有文档详细说明。</li><li><strong>db_passwd</strong>: MySQL数据库root的密码，用于<strong>db_auth</strong>。</li><li><strong>max_job_wokers</strong>: (默认值为3) 这个作业服务器启动复制进程的数量。 每个镜像的复制作业会有1个进程同步1个库的所有标签到远程目标。 增加这个数值可以启动多个进程同时进行复制作业。但是，因为每个进程会消耗一定的网络/CPU/IO资源，请根据主机硬件资源谨慎设置这个配置。</li><li><strong>customize_crt</strong>：(<strong>on</strong> 或者 <strong>off</strong>, 默认为<strong>on</strong>) 当这个配置项为 <strong>on</strong>时，安装脚本会创建用于生成/验证库的<code>token</code>的私钥和根证书。 当私钥和根证书是通过其它来源提供时(从第三方机构购买的证书)设置此配置项为 <strong>off</strong> 。</li><li><strong>ssl_cert</strong>: SSL证书(<code>cert</code>）的路径, 仅当协议设置为<code>https</code>时这个配置项会被应用。</li><li><strong>ssl_cert_key</strong>: SSL私钥(<code>key</code>)的路径, 仅当协议设置为<code>https</code>时这个配置项会被应用。</li><li><strong>secretkey_path</strong>: 在复制规则中用于加解密一个远程库的密码的私钥(<code>key</code>)的路径。</li><li><strong>log_rotate_count</strong>: 日志文件被轮转 <strong>log_rotate_count</strong> 次后被删除。 如果这个配置项是<code>0</code>，旧的日志不会被轮转，而是直接删除。 </li><li><strong>log_rotate_size</strong>: 只有当日志文件增长到大于 <strong>log_rotate_size</strong> (字节)时，日志文件才会被轮转。如果这个值后面跟随<code>k</code>，这个值被认为是<code>KB</code>; 如果是<code>M</code>， 就被认为是<code>MB</code>;如果是<code>G</code>，就被认为是<code>GB</code>。所以，这个值是<code>100</code>、 <code>100K</code>、 <code>100M</code>和<code>100G</code>都是合法的。</li></ul><h4 id="可选配置项"><a href="#可选配置项" class="headerlink" title="可选配置项:"></a>可选配置项:</h4><ul><li><strong>Email settings</strong>: 这个配置项用于给用户发送密码重置邮件。注意，SSL连接默认是不启用的，如果你的SMTP服务器需要SSL，并且不支持<code>STARTTLS</code>，需要通过设置 <strong>email_ssl = true</strong> 来支持SSL。如果email服务器使用了一个自签名证书或者未授权的证书，需要配置 <strong>email_insecure = true</strong> 。 对于”email_identity”的详细描述请查看<a href="https://tools.ietf.org/rfc/rfc2595.txt" target="_blank" rel="external">rfc2595</a>。</li></ul><p>例:</p><pre><code>email_server = smtp.mydomain.comemail_server_port = 25email_identity =email_username = sample_admin@mydomain.comemail_password = abcemail_from = admin sample_admin@mydomain.comemail_ssl = falseemail_insecure = falseemail_server = smtp.mydomain.comemail_server_port = 25email_identity =email_username = sample_admin@mydomain.comemail_password = abcemail_from = admin sample_admin@mydomain.comemail_ssl = falseemail_insecure = false</code></pre><ul><li><strong>harbor_admin_password</strong> : 管理员初始密码。 这个密码仅仅是第一次安装并启动Harbor时有效。 之后再次启动时这个配将会被忽略，管理员密码在UI中可以被修改。注意， 默认的用户名/密码是 <strong>admin/Harbor12345</strong>。</li><li><strong>auth_mode</strong>: 认证模式。默认为 <strong>db_auth</strong> , 认证信息存储到数据库中。对于LDAP认证， 需要设置 <strong>ldap_auth</strong> 。</li></ul><p><strong>注意</strong>: 当升级已有的Harbor实例的时候，在升级启动新版本的Harbor之前确认 <strong>auth_mode</strong> 配置与<code>harbor.cfg</code>中的配置相同。否者，已有用户无法在升级后登录系统。</p><ul><li><strong>ldap_url</strong>: LDAP服务的URL(如: <code>ldaps://ldap.yourdomain.com</code>)。 仅当 <strong>auth_mode</strong> 选项被设置为ldap_auth时，此配置项生效。</li><li><strong>ldap_searchdn</strong>: 一个有搜索LDAP/AD服务器权限的用户的DN(如: `uid=admin,ou=people,dc=yourdomain,dc=com)。</li><li><strong>ldap_search_pwd</strong>: <strong>ldap_searchdn</strong>配置指定的用户的密码。</li><li><strong>ldap_basedn</strong>: 查找用户的基础DN，如: <code>ou=people,dc=yourdomain,dc=com</code>。仅当 <strong>auth_mode</strong> 选项被设置为ldap_auth时，此配置项生效。</li><li><strong>ldap_filter</strong>: 用于搜索用户的查询过滤器(如: <code>objectClass=person</code>)。</li><li><strong>ldap_uid</strong>: 这个属性用于在LDAP检索过程中去匹配用户，可以是uid, cn, email或者其它的属性。</li><li><strong>ldap_scope</strong>: 搜索用户的范围，值及含义为: 1-LDAP_SCOPE_BASE, 2-LDAP_SCOPE_NOLEVEL, 3-LDAP_SCOPE_SUBTREE。默认为3。</li><li><strong>self_registration</strong>: (<strong>on</strong> 或 <strong>off</strong>。默认为 <strong>on</strong>) 是否允许用户自己进行注册。当不允许用户自助注册时， 新用户只能由管理员来创建， 在Harbor中只有一个管理员可以创建新用户。 _注意:当 <strong>atuh_mode</strong>被设置为 <strong>ldap_auth</strong> 时，用户自助注册的功能会自动被关闭，这个配置项将被忽略。_</li><li><strong>token_expiration</strong>: token服务创建的token超时的时间(分钟), 默认为30分钟。</li><li><strong>project_creation_restriction</strong>: 这个配置项控制用户是否有权限去创建项目。默认每个人都可以创建项目，设置为”adminonly”为只有管理员可以创建项目。</li></ul><h4 id="配置存储-可选项"><a href="#配置存储-可选项" class="headerlink" title="配置存储(可选项)"></a>配置存储(可选项)</h4><p>默认情况下，Harbor会将镜像存储到本地文件系统。 但在某些环境中，你可能考虑使用其他的后端存储来代替本地文件系统，比如: S3, OpenStack Swift, Ceph等。 你可以通过更新配置文件<code>common/templates/registry/config.yml</code>中<code>storage</code>这个配置段来更改后端存储。例如，你使用OpenStack Swift作为你后端的存储，这个配置段的配置如下：</p><pre><code>storage:  swift:    username: admin    password: ADMIN_PASS    authurl: http://keystone_addr:35357/v3/auth    tenant: admin    domain: default    region: regionOne    container: docker_images</code></pre><p><em>注意: 对于镜像库的后端存储的详细信息请参见: <a href="https://docs.docker.com/registry/configuration/" target="_blank" rel="external">Docker Registry配置说明</a></em></p><h4 id="完成安装并启动Harbor"><a href="#完成安装并启动Harbor" class="headerlink" title="完成安装并启动Harbor"></a>完成安装并启动Harbor</h4><p>完成 <strong>harbor.cfg</strong> 与存储配置(可选配置项)的配置， 使用<code>install.sh</code>脚本完成安装并启动。注意，对于在线安装可能要花费一些时间从Docker hub下载镜像。 Harbor需要使用Docker Compose启动，请在运行<code>install.sh</code>脚本前安装，请参考: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="external">Docker Compose安装说明</a>。</p><pre><code>$ ./install.sh[Step 0]: checking installation environment ...Note: docker version: 17.06.2Note: docker-compose version: 1.17.0[Step 1]: loading Harbor images ...c5c1f3d43c8b: Loading layer [==================================================&gt;]  135.4MB/135.4MB62f93b2c84e5: Loading layer [==================================================&gt;]  72.99MB/72.99MB72842e5a36df: Loading layer [==================================================&gt;]  3.584kB/3.584kB478e65478cba: Loading layer [==================================================&gt;]  3.072kB/3.072kB59b789abf78f: Loading layer [==================================================&gt;]  4.096kB/4.096kB004c30d5e900: Loading layer [==================================================&gt;]  3.584kB/3.584kB30c3b4c78f76: Loading layer [==================================================&gt;]  10.24kB/10.24kBLoaded image: vmware/harbor-log:v1.3.0-rc1454c81edbd3b: Loading layer [==================================================&gt;]  135.2MB/135.2MBbab81b4d4981: Loading layer [==================================================&gt;]  463.7MB/463.7MB5735a75e540c: Loading layer [==================================================&gt;]  9.216kB/9.216kB44394f38b0c9: Loading layer [==================================================&gt;]  9.216kB/9.216kB13775ef23512: Loading layer [==================================================&gt;]   7.68kB/7.68kB9d8d34eb8c97: Loading layer [==================================================&gt;]  1.536kB/1.536kB94af0237e276: Loading layer [==================================================&gt;]  9.216kB/9.216kBf1a95e05d345: Loading layer [==================================================&gt;]   2.56kB/2.56kB3ca7ba769253: Loading layer [==================================================&gt;]  3.072kB/3.072kBLoaded image: vmware/harbor-db:v1.3.0-rc1e4813ce65d72: Loading layer [==================================================&gt;]  23.21MB/23.21MB3491428eff72: Loading layer [==================================================&gt;]  18.33MB/18.33MB22355de6ca70: Loading layer [==================================================&gt;]  18.33MB/18.33MBLoaded image: vmware/harbor-jobservice:v1.3.0-rc111a7546bc950: Loading layer [==================================================&gt;]  90.74MB/90.74MBcd2cb03dfead: Loading layer [==================================================&gt;]  12.16MB/12.16MBfdcb5fa28b07: Loading layer [==================================================&gt;]   17.3MB/17.3MBeef410f82bbe: Loading layer [==================================================&gt;]  15.87kB/15.87kB938e5e2a4bad: Loading layer [==================================================&gt;]  3.072kB/3.072kB558c91f2870a: Loading layer [==================================================&gt;]  3.072kB/3.072kBLoaded image: vmware/notary-photon:server-0.5.10e1b40dbb3d2: Loading layer [==================================================&gt;]  10.95MB/10.95MB58127bdab8e5: Loading layer [==================================================&gt;]   17.3MB/17.3MB2e3e9ac4492d: Loading layer [==================================================&gt;]  15.87kB/15.87kBbd6c57401b0f: Loading layer [==================================================&gt;]  3.072kB/3.072kB08a6f4315b6a: Loading layer [==================================================&gt;]  3.072kB/3.072kBLoaded image: vmware/notary-photon:signer-0.5.1e99db1275091: Loading layer [==================================================&gt;]  395.4MB/395.4MB051e4ee23882: Loading layer [==================================================&gt;]  9.216kB/9.216kB6cca4437b6f6: Loading layer [==================================================&gt;]  9.216kB/9.216kB1d48fc08c8bc: Loading layer [==================================================&gt;]   7.68kB/7.68kB0419724fd942: Loading layer [==================================================&gt;]  1.536kB/1.536kB92ce53616a73: Loading layer [==================================================&gt;]  599.2MB/599.2MB2004244b53a2: Loading layer [==================================================&gt;]  74.24kB/74.24kBLoaded image: vmware/harbor-db-migrator:1.3c116153f561a: Loading layer [==================================================&gt;]  23.21MB/23.21MBd82c9a7f1bce: Loading layer [==================================================&gt;]  7.071MB/7.071MB75e273c18f2a: Loading layer [==================================================&gt;]  7.071MB/7.071MBLoaded image: vmware/harbor-adminserver:v1.3.0-rc1Loaded image: vmware/photon:1.0Loaded image: vmware/mariadb-photon:10.2.10eecd294cdc4d: Loading layer [==================================================&gt;]  23.21MB/23.21MB848ebb86cbdd: Loading layer [==================================================&gt;]  22.71MB/22.71MB75c57475cadf: Loading layer [==================================================&gt;]  7.168kB/7.168kB3dd4619c78ff: Loading layer [==================================================&gt;]  5.381MB/5.381MB757114e3e191: Loading layer [==================================================&gt;]   22.7MB/22.7MBLoaded image: vmware/harbor-ui:v1.3.0-rc1cd0c2ef5af40: Loading layer [==================================================&gt;]  72.46MB/72.46MBLoaded image: vmware/nginx-photon:1.11.137280dd18d4e6: Loading layer [==================================================&gt;]  90.74MB/90.74MB29de07437cda: Loading layer [==================================================&gt;]  2.048kB/2.048kBbf435791a668: Loading layer [==================================================&gt;]  2.048kB/2.048kBea6923ed1a8e: Loading layer [==================================================&gt;]  2.048kB/2.048kBb39969acb12a: Loading layer [==================================================&gt;]  3.072kB/3.072kBa07efc1d5b07: Loading layer [==================================================&gt;]   22.8MB/22.8MBLoaded image: vmware/registry:2.6.2-photonfe75aea3eba7: Loading layer [==================================================&gt;]  221.3MB/221.3MB 50b4cd38d514: Loading layer [==================================================&gt;]  10.75MB/10.75MB5ffc09e42afb: Loading layer [==================================================&gt;]  2.048kB/2.048kBee0b77dfb8f1: Loading layer [==================================================&gt;]  48.13kB/48.13kBf1f5fc6c106a: Loading layer [==================================================&gt;]   10.8MB/10.8MBLoaded image: vmware/clair:v2.0.1-photon418e636d0b27: Loading layer [==================================================&gt;]  161.5MB/161.5MBfb804e98cb47: Loading layer [==================================================&gt;]  6.656kB/6.656kBd961645df25c: Loading layer [==================================================&gt;]  6.656kB/6.656kBLoaded image: vmware/postgresql:9.6.5-photon[Step 2]: preparing environment ...Generated and saved secret to file: /data/secretkeyGenerated configuration file: ./common/config/nginx/nginx.confGenerated configuration file: ./common/config/adminserver/envGenerated configuration file: ./common/config/ui/envGenerated configuration file: ./common/config/registry/config.ymlGenerated configuration file: ./common/config/db/envGenerated configuration file: ./common/config/jobservice/envGenerated configuration file: ./common/config/log/logrotate.conf Generated configuration file: ./common/config/jobservice/app.confGenerated configuration file: ./common/config/ui/app.confGenerated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crtThe configuration files are ready, please use docker-compose to start the service.[Step 3]: checking existing instance of Harbor ...[Step 4]: starting Harbor ...Creating network &quot;harbor_harbor&quot; with the default driverCreating harbor-log ... Creating harbor-log ... doneCreating harbor-adminserver ... Creating registry ... Creating harbor-db ... Creating harbor-adminserverCreating harbor-dbCreating registry ... doneCreating harbor-db ... doneCreating harbor-ui ... doneCreating harbor-jobservice ... Creating nginx ... Creating harbor-jobserviceCreating nginx ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://reg.youerdomain.com. For more details, please visit https://github.com/vmware/harbor .</code></pre><p>如果所有组件都已经开始工作，你可以启动浏览器访问管理页面”<a href="http://reg.yourdomain.com" target="_blank" rel="external">http://reg.yourdomain.com</a>“ 。 注意，默认的管理员用户名/密码是admin/Harbor12345。</p><p>登录到管理页面并创建一个新的工程，如<code>myproject</code>。之后可用用docker命令登录并推送image(默认的Registry的服务监听在80端口)。</p><p>具体登录及推送过程和使用Docker Registry一样，不再具体演示了。</p><h3 id="3-管理Harbor"><a href="#3-管理Harbor" class="headerlink" title="3. 管理Harbor"></a>3. 管理Harbor</h3><p>可以使用docker-compose管理Harbor启停。 下面列出一些常用的命令(必须在与<code>docker-compose.yml</code>同级目录下运行)。</p><p>停止Harbor:</p><pre><code>$ docker-compose stopStopping nginx ... doneStopping harbor-jobservice ... doneStopping harbor-ui ... doneStopping harbor-db ... doneStopping registry ... doneStopping harbor-log ... done</code></pre><p>重新再启动Harbor:</p><pre><code>$ docker-compose startStarting log ... doneStarting ui ... doneStarting mysql ... doneStarting jobservice ... doneStarting registry ... doneStarting proxy ... done</code></pre><p>如果需要改变Harbor的配置，先停止已经存在的实例，然后更新<code>harbor.cfg</code>。 运行<code>prepare</code>脚本去更改配置文件。 最后重建并启动Harbor实例：</p><pre><code>$ docker-compose down -v  #-v 参数是停止容器后直接删除容器$ vim harbor.cfg$ ./prepare$ docker-compose up -d  #-d 是通过分离(后台)模式启动</code></pre><p>只删除Harbor系统的容器，保留镜像数据及Harbor的数据库文件:</p><pre><code>$ docker-compose down -v</code></pre><p>删除Harbor的数据及镜像文件(用于清理后重新安装):</p><pre><code>$ rm -rf /data/database$ rm -rf /data/registry</code></pre><p><strong>注意:</strong>如重新安装，建议将/data目录下所有文件清空，有些配置保存在<code>/data/config</code>中，并不会随重新安装而改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Registry只能通过API进行管理，然而第三方开发了一些开源的平台来作为私有镜像库管理(类似于github)，可以对用户、权限、镜像库及
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(五):私有仓库(二)</title>
    <link href="http://kidnet.github.io/2017/11/28/docker-registry-management/"/>
    <id>http://kidnet.github.io/2017/11/28/docker-registry-management/</id>
    <published>2017-11-28T07:31:02.000Z</published>
    <updated>2017-11-28T09:10:46.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一篇讲了使用Registry搭建私有的镜像库，对Registry的管理暂时只能是有API来进行，本篇来介绍使用API管理Registry镜像库。</p><h2 id="Registry镜像的管理"><a href="#Registry镜像的管理" class="headerlink" title="Registry镜像的管理"></a>Registry镜像的管理</h2><h3 id="1-镜像查询"><a href="#1-镜像查询" class="headerlink" title="1. 镜像查询"></a>1. 镜像查询</h3><p>前面已经说到过Registry v2需要通过API进行查询, 对于需要证书及鉴权的Registry通过以下方式查询:</p><pre><code>$ curl --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/_catalog  {&quot;repositories&quot;:[&quot;registry&quot;]}</code></pre><p>可以查看每个镜像的详细信息：</p><pre><code>$ curl -i -X GET -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/registry/manifests/2HTTP/1.1 200 OKContent-Length: 1364Content-Type: application/vnd.docker.distribution.manifest.v2+jsonDocker-Content-Digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6Docker-Distribution-Api-Version: registry/2.0Etag: &quot;sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6&quot;Date: Thu, 09 Nov 2017 22:09:42 GMT{   &quot;schemaVersion&quot;: 2,   &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,   &quot;config&quot;: {      &quot;mediaType&quot;: &quot;application/vnd.docker.container.image.v1+json&quot;,      &quot;size&quot;: 3165,      &quot;digest&quot;: &quot;sha256:a07e3f32a779aa924fd47f6797d4d5c93061c50c0eb97d464f08365a3a30200b&quot;   },   &quot;layers&quot;: [      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 2385012,         &quot;digest&quot;: &quot;sha256:49388a8c9c86a6f56d228954eede699c64fce6c671a989e3e21c391859694645&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 2027027,         &quot;digest&quot;: &quot;sha256:e4d43608dd22de7d12f17ae419ce146094e047e1a739d644e3fcb647f9379bdb&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 6265374,         &quot;digest&quot;: &quot;sha256:3a41740f900cbba03b223c025f03632db1284d85a696677bca8d6375cdf6040b&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 371,         &quot;digest&quot;: &quot;sha256:e16ef4b766841014d6a902f034f0f67698bcbebc1b4c36ff3574d3730e79e2ee&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 213,         &quot;digest&quot;: &quot;sha256:65f212f7c77805418cb85461d93a522c1bf4eebac73009ccd23ac2159ac33dad&quot;      }   ]}</code></pre><p>对于2.3或之前的版本，要使用:指定<code>Accept: application/vnd.docker.distribution.manifest.v2+json</code>头。</p><h3 id="2-镜像删除"><a href="#2-镜像删除" class="headerlink" title="2. 镜像删除"></a>2. 镜像删除</h3><p>对于Registry库中镜像的删除，通过API只能删除镜像的信息，具体的镜像的Layer实际还存在。</p><pre><code>$ curl -i -X DELETE -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \   https://10.0.2.15:5000/v2/registry/manifests/sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6   HTTP/1.1 202 AcceptedDocker-Distribution-Api-Version: registry/2.0Date: Fri, 10 Nov 2017 03:46:09 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8</code></pre><p>这时查看镜像信息显示为未知镜像:</p><pre><code>$ curl -i -X GET -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/registry/manifests/2                                                                            HTTP/1.1 404 Not FoundContent-Type: application/json; charset=utf-8Docker-Distribution-Api-Version: registry/2.0Date: Fri, 10 Nov 2017 03:47:51 GMTContent-Length: 91{&quot;errors&quot;:[{&quot;code&quot;:&quot;MANIFEST_UNKNOWN&quot;,&quot;message&quot;:&quot;manifest unknown&quot;,&quot;detail&quot;:{&quot;Tag&quot;:&quot;2&quot;}}]}</code></pre><p>但再次上传相同镜像的时候，所有Layer提示已经存在:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Layer already exists a2717186d7dd: Layer already exists 656c7684d0bd: Layer already exists 7683d4fcdf4e: Layer already exists ef763da74d91: Layer already exists 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>Docker官方文档中描述的API删除镜像其实是软删除，只是解除信息关联，并没有在真正删除镜像，建议调用API删除成功后到镜像存储目录直接删除该镜像所有信息。</p><p>调用删除API之前，在<code>config.yml</code>中需要增加允许删除的配置:</p><pre><code>$ vim /etc/docker-distribution/registry/config.yml... ...storage:    ... ...    delete:        enabled: true</code></pre><p>增加配置后重启服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;上一篇讲了使用Registry搭建私有的镜像库，对Registry的管理暂时只能是有API来进行，本篇来介绍使用API管理Registry镜
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(四):私有仓库(一)</title>
    <link href="http://kidnet.github.io/2017/11/23/docker-registry/"/>
    <id>http://kidnet.github.io/2017/11/23/docker-registry/</id>
    <published>2017-11-23T07:30:45.000Z</published>
    <updated>2017-11-28T06:38:09.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些私有镜像不方便传输到公共镜像库中，或者内网环境，可以搭建一个私有Registry作为镜像仓库。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>Registry是用于存储和交付Docker镜像的系统。 和本地镜像管理中存储的镜像一样，可以使用不同的标签版本。</p><h3 id="1-使用docker-distribution启动Registry"><a href="#1-使用docker-distribution启动Registry" class="headerlink" title="1. 使用docker-distribution启动Registry"></a>1. 使用<code>docker-distribution</code>启动Registry</h3><p>可以直接安装docker组件distribution来启动Registry。</p><ul><li>安装</li></ul><p>对于CentOS系统，直接使用<code>yum</code>安装即可:</p><pre><code>$ yum install docker-distribution</code></pre><ul><li>启动</li></ul><p>通过<code>systemctl</code>启动Registry服务:</p><pre><code>$ systemctl start docker-distribution</code></pre><ul><li>配置说明</li></ul><p>安装好后的Registry的配置文件可以正常启动应用，修改<code>/etc/docker-distrbution/registry/config.yml</code>文件来修改默认配置:</p><pre><code>version: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registry  #镜像文件存储的目录http:    addr: :5000 #对外服务的端口</code></pre><p>后面会继续说明一些用到的配置。</p><h3 id="2-使用已有的镜像启动Registry"><a href="#2-使用已有的镜像启动Registry" class="headerlink" title="2. 使用已有的镜像启动Registry"></a>2. 使用已有的镜像启动Registry</h3><p>官方文档都是通过下载已经配置好的Registry的镜像，通过容器启动此镜像，来提供Registry的服务。</p><ul><li>下载官方镜像</li></ul><p>直接拉取官方镜像:</p><pre><code>$ docker pull registry:22: Pulling from library/registry49388a8c9c86: Pull complete e4d43608dd22: Pull complete 3a41740f900c: Pull complete e16ef4b76684: Pull complete 65f212f7c778: Pull complete Digest: sha256:d837de65fd9bdb81d74055f1dc9cc9154ad5d8d5328f42f57f273000c402c76dStatus: Downloaded newer image for registry:2</code></pre><ul><li>通过镜像启动Registry服务</li></ul><p>通过官方镜像启动容器:</p><pre><code>$ docker run -d -p 5000:5000 --name registry registry:24199973ca1c7511fd608da534570375023fa69715948b13f4d9b3a3c277d3536$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES4199973ca1c7        registry:2          &quot;/entrypoint.sh /e...&quot;   5 seconds ago       Up 4 seconds        0.0.0.0:5000-&gt;5000/tcp   registry</code></pre><p>其实启动容器时如果没有对应的镜像，会自动下载:</p><pre><code>$ docker run -d -p 5000:5000 --name registry registry:2Unable to find image &apos;registry:2&apos; locally #提示在本地镜像库中没有找到镜像2: Pulling from library/registry          #开始从公共镜像库下载镜像49388a8c9c86: Pull complete e4d43608dd22: Pull complete 3a41740f900c: Pull complete e16ef4b76684: Pull complete 65f212f7c778: Pull complete Digest: sha256:d837de65fd9bdb81d74055f1dc9cc9154ad5d8d5328f42f57f273000c402c76dStatus: Downloaded newer image for registry:2  #镜像下载完成6dabd62f77e8e2079bed029599aea96b65a551bcdb517a4adb24630828dea761 #启动容器$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEregistry            2                   a07e3f32a779        5 days ago          33.3MB$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES6dabd62f77e8        registry:2          &quot;/entrypoint.sh /e...&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:5000-&gt;5000/tcp   registry</code></pre><p>使用容器启动Registry时注意将存储镜像的目录挂载到本地硬盘，如果存储镜像在容器中，容器销毁时，所有镜像也一起销毁:</p><pre><code>$ docker run -d -p 5000:5000 --name registry -v /mnt/registry:/var/lib/registry registry:2</code></pre><h3 id="3-访问无验证的Registry"><a href="#3-访问无验证的Registry" class="headerlink" title="3. 访问无验证的Registry"></a>3. 访问无验证的Registry</h3><p>默认的docker client访问无认证的Registry可能会出现错误：</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: http: server gave HTTP response to HTTPS client</code></pre><p>docker client客户端默认需要访问<code>https</code>的地址，需要增加配置，重启docker:</p><pre><code>$ echo &quot;{\&quot;insecure-registries\&quot;:[\&quot;10.0.2.15:5000\&quot;]}&quot; &gt;&gt; /etc/docker/daemon.json$ systemctl restart docker</code></pre><p>重启后重新推送镜像: </p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Pushed a2717186d7dd: Pushed 656c7684d0bd: Pushed 7683d4fcdf4e: Pushed ef763da74d91: Pushed 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>如果是通过二进制程序启动的docker，直接在启动时增加参数即可:</p><pre><code>$ dockerd --insecure-registry 10.0.2.15:5000 &amp; #如已启动docker，请先停止已启动的进程</code></pre><h3 id="4-查看私有库中的镜像"><a href="#4-查看私有库中的镜像" class="headerlink" title="4. 查看私有库中的镜像"></a>4. 查看私有库中的镜像</h3><p>Registry没有图形界面，只能通过命令访问接口:</p><pre><code>$ curl http://10.0.2.15/v2/_catalog{&quot;repositories&quot;:[&quot;registry&quot;]}</code></pre><h3 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h3><p>以上2种配置启动Registry的方法，对比来说第一种方法(直接安装<code>docker-distribution</code>包)更为方便简洁，后期也较好维护(官网只有第二种方法，根据情况选择适合自己的方法来启动Registry)。</p><h2 id="安全的Registry"><a href="#安全的Registry" class="headerlink" title="安全的Registry"></a>安全的Registry</h2><p>Docker官方是推荐采用带有认证的Registry，传输采用tls。</p><h3 id="1-制作自签署证书"><a href="#1-制作自签署证书" class="headerlink" title="1. 制作自签署证书"></a>1. 制作自签署证书</h3><p>制作证书前需要在<code>openssl.cnf</code>配置中加入证书绑定的域名(或主机名或IP)。否则推送镜像时会差生以下错误:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: x509: cannot validate certificate for 10.0.2.15 because it doesn&apos;t contain any IP SANs</code></pre><p>修改配置文件，加入IP:</p><pre><code>$ cp /etc/pki/tls/openssl.cnf /tmp/$ vim /tmp/openssl.cnf......[v3_ca]subjectAltName = IP: 10.0.2.15</code></pre><p>修改后保存退出即可。继续使用<code>openssl</code>来制作自签署的证书，注意需要指定刚才修改的<code>openssl.cnf</code>配置文件:</p><pre><code>$ mkdir /etc/docker-distribution/registry/certs$ cd /etc/docker-distribution/registry/certs$ openssl req -newkey rsa:2048 -nodes -sha256 -keyout domain.key -x509 -days 365 -out domain.crt -config /tmp/openssl.cnfGenerating a 2048 bit RSA private key.............+++...............................+++writing new private key to &apos;domain.key&apos;-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:BJLocality Name (eg, city) [Default City]:BJOrganization Name (eg, company) [Default Company Ltd]:ZLOrganizational Unit Name (eg, section) []:ZLCommon Name (eg, your name or your server&apos;s hostname) []:registryEmail Address []:$ lsdomain.crt  domain.key</code></pre><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>修改Registry的配置文件，添加<code>tls</code>证书:</p><pre><code>$ vim /etc/docker-distribution/registry/config.ymlversion: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registryhttp:    addr: :5000    #增加以下tls的配置    tls:        certificate: /etc/docker-distribution/registry/certs/domain.crt        key: /etc/docker-distribution/registry/certs/domain.key</code></pre><p>重启Registry服务:</p><pre><code>$ systemctl restart docker-distribution</code></pre><h3 id="3-客户端证书配置"><a href="#3-客户端证书配置" class="headerlink" title="3. 客户端证书配置"></a>3. 客户端证书配置</h3><p>Registry服务配置好后，需要将证书配置到客户端，否则会产生以下错误：</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: x509: cannot validate certificate for 10.0.2.15 because it doesn&apos;t contain any IP SANs</code></pre><p>将证书配置到客户端，并重启客户端:</p><pre><code>$ mkdir -p /etc/docker/certs.d/10.0.2.15:5000# 注意，本文档测试时客户端与私有库是同一台服务器，以下这个证书应该是拷贝到真实的客户端服务器中。$ cp /etc/docker-distribution/registry/certs/domain.crt /etc/docker/certs.d/10.0.2.15\:5000/ca.crt$ systemctl restart docker</code></pre><p>测试是否正常访问私有镜像库:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Pushed a2717186d7dd: Pushed 656c7684d0bd: Pushed 7683d4fcdf4e: Pushed ef763da74d91: Pushed 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><h2 id="Registry鉴权管理"><a href="#Registry鉴权管理" class="headerlink" title="Registry鉴权管理"></a>Registry鉴权管理</h2><p>Registry提供了基础的鉴权方式，可以像公有镜像库一样先登录，再提交镜像。</p><h3 id="1-生成鉴权密码文件"><a href="#1-生成鉴权密码文件" class="headerlink" title="1. 生成鉴权密码文件"></a>1. 生成鉴权密码文件</h3><p>在Registry服务器上，增加一个<code>admin</code>用户，密码为<code>admin123</code>:</p><pre><code>$ mkdir /etc/docker-distribution/registry/auth$ docker run --entrypoint htpasswd registry:2 -Bbn admin admin123 &gt; /etc/docker-distribution/registry/auth/htpasswd</code></pre><h3 id="2-修改配置并重启服务"><a href="#2-修改配置并重启服务" class="headerlink" title="2. 修改配置并重启服务"></a>2. 修改配置并重启服务</h3><p>增加对应配置:</p><pre><code>$ vim /etc/docker-distribution/registry/config.ymlversion: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registryhttp:    addr: :5000    tls:        certificate: /etc/docker-distribution/registry/certs/domain.crt        key: /etc/docker-distribution/registry/certs/domain.key#增加以下配置:    auth:    htpasswd:        realm: basic-realm        path: /etc/docker-distribution/registry/auth/htpasswd</code></pre><p>重启服务:</p><pre><code>$ systemctl restart docker-distribution</code></pre><p>测试推送镜像:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2                                                                                 The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Preparing a2717186d7dd: Preparing 656c7684d0bd: Preparing 7683d4fcdf4e: Preparing ef763da74d91: Preparing no basic auth credentials</code></pre><p>推送失败，尝试登录后再次推送:</p><pre><code>$ docker login 10.0.2.15:5000Username: adminPassword: Login Succeeded$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Layer already exists a2717186d7dd: Layer already exists 656c7684d0bd: Layer already exists 7683d4fcdf4e: Layer already exists ef763da74d91: Layer already exists 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>成功登录后，推送镜像成功(因之前已推送过此镜像，所以提示镜像已存在)。</p><h2 id="使用容器启动的Registry的安全和鉴权配置"><a href="#使用容器启动的Registry的安全和鉴权配置" class="headerlink" title="使用容器启动的Registry的安全和鉴权配置"></a>使用容器启动的Registry的安全和鉴权配置</h2><p>使用容器启动的Registry可以通过多种方法进行配置：</p><ul><li>使用Dockerfile将修改好的配置文件、证书及密码文件打入启动镜像。</li></ul><p>如Dockerfile加入下列几行后重新制作镜像:    </p><pre><code>COPY config.yml /etc/docker/registry/config.ymlCOPY domain.crt /etc/docker/registry/domain.crtCOPY domain.key /etc/docker/registry/domain.keyCOPY htpasswd /etc/docker/registry/htpasswd</code></pre><ul><li>将修改好的配置文件、证书及密码文件的目录挂载到镜像对应目录。</li></ul><p>启动镜像时将配置目录重新挂载:</p><pre><code>$ docker run -d -p 5000:5000 --name registry \  -v /mnt/registry:/var/lib/registry \  -v /config:/etc/docker/registry \  registry:2</code></pre><ul><li>启动容器时使用特定环境变量指定修改。</li></ul><p>启动容器是通过环境变量也可以修改Registry的配置: </p><pre><code>$ docker run -d -p 5000:5000 --restart=always --name registry \-v `pwd`/auth:/auth \-e &quot;REGISTRY_AUTH=htpasswd&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \-v `pwd`/data:/var/lib/registry \-v `pwd`/certs:/certs \-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \-e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \registry:2</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;有些私有镜像不方便传输到公共镜像库中，或者内网环境，可以搭建一个私有Registry作为镜像仓库。&lt;/p&gt;
&lt;h2 id=&quot;Docker-R
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(三):容器管理</title>
    <link href="http://kidnet.github.io/2017/11/22/docker-container-management/"/>
    <id>http://kidnet.github.io/2017/11/22/docker-container-management/</id>
    <published>2017-11-22T02:59:11.000Z</published>
    <updated>2017-11-28T06:06:53.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前已经介绍了镜像管理，有了镜像，就可以使用镜像来启动容器(应用环境)。</p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>Docker容器基于已有的镜像启动，下面介绍对于容器的管理。</p><h3 id="1-容器启动"><a href="#1-容器启动" class="headerlink" title="1. 容器启动"></a>1. 容器启动</h3><p>选择好镜像后就可以启动容器，启动容器时可以选择多种参数，也可以将需要的参数(部分)定义到Dockerfile，直接打入镜像(但启动时使用的参数会覆盖镜像中已定义好的参数。)。</p><ul><li>使用参数启动容器</li></ul><p>使用<code>docker run [Options] image_name[:image_tag] [CMD]</code>基于选定镜像启动容器: </p><pre><code>$ docker images #Display imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB$ docker run -d centos-sshd /sbin/init #Start containerc7dc163219834374a02e4ee7c91da202a12c847dc3e51a741762af12c7fca919</code></pre><p>这样就使用<code>centos-sshd</code>镜像启动了一个容器。</p><ul><li>常用参数说明</li></ul><p>以下是启动容器时经常使用的一些参数:</p><pre><code>-p 端口映射，&lt;local_ip&gt;:&lt;local_port&gt;:&lt;container_port&gt;-v 挂载本地目录, &lt;local_path&gt;:&lt;container_path&gt;-d 以分离模式(detached mode)启动（简单理解为后台运行）-t 分配一个伪终端(pseudo-tty)-i 打开STDIN(没用-a指定的话)-e 在container中增加一个环境变量(ENV)--privileged 允许container访问所有device(例如 cgruop)--rm 退出容器时自动删除(销毁)容器--name 指定容器的名称(如不指定，系统会随机分配名称)[CMD] 启动时运行的命令，如果在启动容器是使用CMD，在创建镜像时Dockerfile中的CMD会被覆盖，另外，注意，这个CMD必须是一直运行的一个命令，不然命令结束，container会自动退出</code></pre><ul><li>Dockerfile</li></ul><p>使用Dockerfile将部分启动参数打入镜像:</p><pre><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] #使Container监听指定端口。VOLUME &lt;local_path&gt; #将本地目录映射到容器中(不等同于-v参数)。CMD [&quot;CMD1&quot;, &quot;CMD2&quot;, ...] #启动容器时运行的命令。ENV &lt;key&gt; &lt;value&gt; (or ENV &lt;key&gt;=&lt;value&gt; ...) #指定Container启动后的环境变量。</code></pre><h3 id="2-查看容器状态"><a href="#2-查看容器状态" class="headerlink" title="2. 查看容器状态"></a>2. 查看容器状态</h3><p>启动容器后可以查看所有容器的状态，通过<code>docker ps [-a]</code>:</p><pre><code>$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 5 hours                              nervous_poitras</code></pre><p>可以看到正在运行中的容器，之前启动容器时没有指定名字，由系统分配了一个名字。 <code>-a</code>参数可以看到所有容器(包括已经停止的容器)：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 5 hours                                     nervous_poitrasdb8415d50a86        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 hours ago                       gallant_kilby</code></pre><p>可以看到第二个容器是已经停止的容器。</p><h3 id="3-停止运行的容器"><a href="#3-停止运行的容器" class="headerlink" title="3. 停止运行的容器"></a>3. 停止运行的容器</h3><p>使用<code>docker stop &lt;container_id&gt;</code>来停止正在运行的容器:</p><pre><code>$ docker stop c7dc16321983c7dc16321983$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre><p>使用<code>docker ps</code>可以看到没有在运行的容器了，再使用<code>docker ps -a</code>来看看所有容器：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 seconds ago                       nervous_poitrasdb8415d50a86        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 hours ago                         gallant_kilby</code></pre><p>可以看到有两个已经停止的容器了，如果想把容器再次启动，使用<code>docker start &lt;container_id&gt;</code>即可。 如果启动是使用了<code>--rm</code>参数的话，停止容器后，容器立即被销毁，通过<code>docker ps -a</code>也不会再看到此容器了。</p><h3 id="4-销毁-删除-容器"><a href="#4-销毁-删除-容器" class="headerlink" title="4. 销毁(删除)容器"></a>4. 销毁(删除)容器</h3><p>将已经停止的容器销毁(删除), 有时需要将不再使用的容器销毁，以免占用系统资源, 使用<code>docker rm &lt;container_id&gt;</code>:</p><pre><code>$ docker rm db8415d50a86db8415d50a86$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 minutes ago                       nervous_poitras</code></pre><p>执行命令后，将已经停止的一个容器销毁了。</p><h3 id="5-进入已启动容器的系统"><a href="#5-进入已启动容器的系统" class="headerlink" title="5. 进入已启动容器的系统"></a>5. 进入已启动容器的系统</h3><p>有时需要进入已经启动容器的系统进行一下操作，使用<code>docker exec [option] container_id [CMD]</code>:</p><pre><code>$ docker ps CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 9 seconds                            nervous_poitras$ docker exec -ti c7dc16321983 /bin/bash[root@c7dc16321983 /]#</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前已经介绍了镜像管理，有了镜像，就可以使用镜像来启动容器(应用环境)。&lt;/p&gt;
&lt;h2 id=&quot;容器管理&quot;&gt;&lt;a href=&quot;#容器管理&quot;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(二):镜像管理</title>
    <link href="http://kidnet.github.io/2017/10/29/docker-image-management/"/>
    <id>http://kidnet.github.io/2017/10/29/docker-image-management/</id>
    <published>2017-10-29T07:32:20.000Z</published>
    <updated>2017-11-28T06:06:40.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker的容器是基于镜像的，所有容器是通过制作好的镜像启动的，下面会介绍镜像的管理和容器的管理。</p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><p>Docker的镜像可以通过多种途径获取，获取镜像后将镜像存入本地镜像库中，以供容器使用。</p><h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h3><p>镜像可以从公共镜像库中获取(类似yum源)，也可以自己制作，或导入已有镜像(从别的Docker导出的或OpenVZ一类虚拟化软件中导出的)。</p><ul><li>从公共镜像库中获取镜像</li></ul><p>使用<code>docker pull &lt;image_name&gt;[:tag]</code>命令从公共镜像库中获取镜像: </p><pre><code>$ docker pull centosUsing default tag: latestlatest: Pulling from library/centosd9aaf4d82f24: Pull complete Digest: sha256:4565fe2dd7f4770e825d4bd9c761a81b26e49cc9e3c9631c58cfc3188be9505aStatus: Downloaded newer image for centos:latest</code></pre><p>不指定<code>tag</code>的会自动选择使用<code>latest</code>标签。</p><p>公共镜像库支持查询功能，可以先使用<code>docker search &lt;image_name&gt;</code>查询需要的镜像是否存在:</p><pre><code>$ docker search centosNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                             The official build of CentOS.                   3789      [OK]       ansible/centos7-ansible            Ansible on Centos7                              103                  [OK]jdeathe/centos-ssh                 CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x8...   89                   [OK]tutum/centos                       Simple CentOS docker image with SSH access      33                   imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              31                   [OK]gluster/gluster-centos             Official GlusterFS Image [ CentOS-7 +  Glu...   21                   [OK]kinogmt/centos-ssh                 CentOS with SSH                                 17                   [OK]......</code></pre><ul><li>导入镜像 </li></ul><p>使用<code>docker load &lt; &lt;image_file_name&gt;</code>导入从其他Docker导出的镜像:</p><pre><code>$ docker load &lt; centos-sshd36018b5e9787: Loading layer [==================================================&gt;]  200.1MB/200.1MB56ab33f0cb6c: Loading layer [==================================================&gt;]  61.48MB/61.48MB52d118e898dd: Loading layer [==================================================&gt;]  21.99MB/21.99MB52e44758f62d: Loading layer [==================================================&gt;]  1.678MB/1.678MB6f88bf69d4eb: Loading layer [==================================================&gt;]  1.707MB/1.707MB5afae9f25cde: Loading layer [==================================================&gt;]  1.787MB/1.787MBLoaded image ID: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426    </code></pre><p>使用<code>cat &lt;openvz_image_file_name&gt; | docker import - &lt;image_name&gt;:&lt;tag&gt;</code>导入从虚拟化软件(OpenVZ)导出的镜像:</p><pre><code>$ cat centos-6-x86_64.tar.gz | docker import - centos:6sha256:54152fdb34278505a2007911a211ccd6d1d78dd946522bf797f2cf971efb89cf</code></pre><p>(<a href="https://openvz.org/Download/template/precreated" target="_blank" rel="external">OpenVZ镜像下载地址</a>)</p><h3 id="2-本地镜像"><a href="#2-本地镜像" class="headerlink" title="2. 本地镜像"></a>2. 本地镜像</h3><p>启动容器的镜像都是在本地镜像库中，对本地镜像库可以进行管理(删除，标签管理等)。</p><ul><li>本地镜像列表</li></ul><p>管理本地镜像需要了解本地已存在的镜像:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              6                   54152fdb3427        17 minutes ago      825MBcentos              latest              d123f4e55e12        3 days ago          197MBcentos-sshd         latest              b8c73db541e7        6 months ago        280MB</code></pre><p>本地镜像中会列出镜像名称，id及tag(版本)。</p><ul><li>删除本地镜像</li></ul><p>如果本地镜像过多，有些过时的镜像，或者不再使用的镜像，需要被删除时，可以使用以下命令:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB#docker rmi &lt;image_name&gt;:&lt;tag&gt; $ docker rmi centos-sshd：latestUntagged: centos-sshd:latestDeleted: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426Deleted: sha256:5fdcd47722d29774d897562430801f6d1c168a422bcce5de1a6ace65302f900dDeleted: sha256:4e8a967d0d44bbd801c7787c2f750036988f92f28aeb76feb83293421de32a5dDeleted: sha256:50691d2b55b131e1ee4ccee1981556c631f55bb9f57269ceb00cf71c0b0e13bdDeleted: sha256:a84fc4ac805b0593c8e7a61a4d774f261cc4a4de6db1ff812c02b8524127d91bDeleted: sha256:0f8d19a2914ef598af3cc2dc8861b78b4b0d3b848d4eae97f2c81ba8e9f55015Deleted: sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c#检查镜像是否已被删除(唯一的一个本地镜像已被删除)$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</code></pre><p>如果一个镜像有多个tag的话，只会删除此tag:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         7.2                 b8c73db541e7        6 months ago        280MBcentos-sshd         latest              b8c73db541e7        6 months ago        280MB$ docker rmi centos-sshd：latestUntagged: centos-sshd:latest #提示只是删除了镜像的一个tag$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         7.2                 b8c73db541e7        6 months ago        280MB     </code></pre><p>使用镜像ID删除镜像(无论有多少个tag，都会先删除tag，然后彻底删除镜像):</p><pre><code>#dokcer rmi &lt;image_id&gt;$ docker rmi d123f4e55e12Untagged: centos-sshd:7.2Deleted: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426Deleted: sha256:5fdcd47722d29774d897562430801f6d1c168a422bcce5de1a6ace65302f900dDeleted: sha256:4e8a967d0d44bbd801c7787c2f750036988f92f28aeb76feb83293421de32a5dDeleted: sha256:50691d2b55b131e1ee4ccee1981556c631f55bb9f57269ceb00cf71c0b0e13bdDeleted: sha256:a84fc4ac805b0593c8e7a61a4d774f261cc4a4de6db1ff812c02b8524127d91bDeleted: sha256:0f8d19a2914ef598af3cc2dc8861b78b4b0d3b848d4eae97f2c81ba8e9f55015Deleted: sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c</code></pre><p> *注: 如果此镜像被其他镜像依赖，无法删除(后面会介绍依赖关系)。</p><ul><li>导出镜像</li></ul><p>有时可能需要从一个Docker中导出镜像到另一个Docker中，导出本地镜像的方法如下:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB#docker save &lt;image_id&gt; &gt; &lt;export_image_name&gt;$docker save b8c73db541e7 &gt; centos-sshd$lscentso-sshd</code></pre><h3 id="3-镜像制作"><a href="#3-镜像制作" class="headerlink" title="3. 镜像制作"></a>3. 镜像制作</h3><p>有时标准镜像的内容无法满足我们的需求，这时就需要自己制作镜像，这里介绍的制作镜像的方法是基于已有镜像，或将一个启动的容器提交为一个镜像。</p><ul><li>基于已有镜像制作镜像</li></ul><p>使用Dockerfile基于已有镜像制作新的镜像，一个简单的Dockerfile：</p><pre><code># Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [&quot;python&quot;, &quot;app.py&quot;]</code></pre><p>上面Dockerfile中制作了一个python应用的镜像(Dockerfile中可以同时定义容器的启动的参数，后面会详细介绍)，需要<code>requirements.txt</code>(运行这个python应用需要的模块)和<code>app.py</code>(python应用)，这两个文件需要和Dockerfile在同一个目录中(<code>ADD . /app</code>定义的)：</p><pre><code>$ lsDockerfile        app.py            requirements.txt</code></pre><p>最后使用以下命令制作镜像:</p><pre><code>docker build -t firstapp .</code></pre><p>在本地镜像库可以看到刚刚生成的镜像:</p><pre><code>$ docker imagesREPOSITORY            TAG                 IMAGE IDfirstapp         latest              326387cea398</code></pre><ul><li>基于容器制作镜像</li></ul><p>想对已有镜像做简单修改，或者不习惯于写Dockerfile，可以使用镜像启动一个容器，然后在容器中对系统进行修改，修改后将内容重新提交为一个新的镜像:</p><pre><code>$ docker commit &lt;container_id&gt; &lt;image_name&gt;:[&lt;tag&gt;]</code></pre><h3 id="4-镜像推送"><a href="#4-镜像推送" class="headerlink" title="4. 镜像推送"></a>4. 镜像推送</h3><p>将本地镜像(自己制作的镜像)，推送到镜像库(多用于私有镜像库，如是公共项目提交到公共镜像库)。</p><ul><li>推送到公共镜像库</li></ul><p>将自己制作的镜像，推送到公共镜像库，需要有对应镜像库的权限(登录认证)，才可以推送到对应的镜像库中。</p><p>登录到公共镜像库:</p><pre><code>$ docker loginLogin with yourDocker ID to push and pull images from Docker Hub. If you don&apos;t have a DockerID, head over to https://hub.docker.com tocreate one.Username: test #Your login namePassword:Login Succeeded</code></pre><p>*可以到<a href="http://hub.docker.com" target="_blank" rel="external">Docker公共镜像库</a>创建账号，建立自己的镜像库(类似于github)。</p><p>推送镜像:</p><pre><code>$ docker push &lt;login_name&gt;/&lt;image_name&gt;:&lt;tag&gt;$ docker push test/firstapp:lastThe push refers to arepository [docker.io/test/firstapp]34e7b85d83e4: Pushed last: digest:sha256:dafc45b8b533d5ad5564a3821e9e1a252b58f44e69c6052bddcd00139782ee08     size:529</code></pre><ul><li>推送到私有镜像库</li></ul><p>有时自己的镜像不想被别人看到，这时可以搭建自己的私有镜像库(后续会介绍)，然后将自己的镜像提交到私有的镜像库。</p><p>私有镜像库可以不需要登录(如果需要登录，登录过程和提交到公有镜像库一样)，先给需要提交的镜像设置一个<code>tag</code>，<code>tag</code>中将私有镜像库的地址写入即可(IP，hostname或域名):</p><pre><code>$ docker &lt;image_id&gt; &lt;private_registry_address&gt;/&lt;image_name&gt;:&lt;tag&gt;$ docker tag 34e7b85d83e4 10.236.100.3:5000/firstapp:last$ docker push 10.236.100.3:5000/firstapp:lastrepository [10.236.100.3:5000/firstapp]acce4ec5f074: Pushed5d450a8c7e38: Pushede8fd5087fa08: Pushedcf394a2f01e4: Pushedf16d5ac23cee: Pushed57861a68f43a: Pushed97ca462ad9ee: Pushedlast: digest:sha256:b0851324bac55083172ed2068dfb388acabdce14dffdb9787f4e6c044b524f19     size:1764</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Docker的容器是基于镜像的，所有容器是通过制作好的镜像启动的，下面会介绍镜像的管理和容器的管理。&lt;/p&gt;
&lt;h2 id=&quot;镜像管理&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(一):安装</title>
    <link href="http://kidnet.github.io/2017/09/19/docker-install/"/>
    <id>http://kidnet.github.io/2017/09/19/docker-install/</id>
    <published>2017-09-19T10:04:08.000Z</published>
    <updated>2017-11-28T06:06:27.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。</p><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装:"></a>yum安装:</h2><h3 id="安装docker源"><a href="#安装docker源" class="headerlink" title="安装docker源"></a>安装docker源</h3><p>使用yum安装doucker之前，需要先设置docker的yum源。</p><p>1.安装源需要的包: <code>yum-utils</code>, <code>yum-config-manager</code>, <code>device-mapper-persistent-data</code>, <code>lvm2</code>及<code>devicemapper</code></p><pre><code>$ yum install -y yum-utils \  device-mapper-persistent-data \  lvm2</code></pre><p>2.安装docker源  </p><pre><code>$ yum-config-manager \  --add-repo \  https://download.docker.com/linux/centos/docker-ce.repo</code></pre><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>1.安装最新版本docker</p><pre><code>$ yum install docker-ce</code></pre><p>2.启动docker</p><pre><code>$ systemctl start docker</code></pre><p>3.验证docker是否安装正确</p><pre><code>$ docker run hello-world</code></pre><h2 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h2><h3 id="安装静态二进制"><a href="#安装静态二进制" class="headerlink" title="安装静态二进制"></a>安装静态二进制</h3><p>1.下载静态二进制包。下载地址:<a href="https://download.docker.com/linux/static/stable/x86_64/" target="_blank" rel="external">https://download.docker.com/linux/static/stable/x86_64/</a></p><p>2.解压缩tar包  </p><pre><code>$ tar -xzvf /path/to/&lt;FILE&gt;.tar.gz</code></pre><p>3.将二进制文件拷贝至系统命令目录，如<code>/usr/bin</code>  </p><pre><code>$ cp docker/* /usr/bin/</code></pre><p>4.启动Docker daemon:  </p><pre><code>$ dockerd &amp;</code></pre><p>5.验证docker是否安装正确  </p><pre><code>$ docker run hello-world</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。&lt;/p&gt;
&lt;h2 id=&quot;yum安装&quot;&gt;&lt;a href=&quot;#yum安装
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://kidnet.github.io/2017/09/11/markdown/"/>
    <id>http://kidnet.github.io/2017/09/11/markdown/</id>
    <published>2017-09-11T08:19:20.000Z</published>
    <updated>2017-09-11T08:19:23.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前使用dokuwiki系统做共享文档的平台，接触到了Markdown这种书写格式。最近开始折腾在github上搭建blog，又用到了Markdown，但是好多都忘光了，从头复习一下。Markdown的目标是易读易写，让作者专注于写作，不用太多关心排版的问题,即使不把Markdown格式转化为HTML，可读性依然很强。Markdown格式是可以以纯文档的方式发布，使用标签或是格式指令构成，可以兼容HTML。</p><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>连续的文本组成一个段落，每个段落前后有一个以上的空行。每个段落不能使用空格或制表符来缩进，如果想要缩进只能使用HTML元素，比如：<code>&amp;emsp;</code>/<code>&amp;ensp;</code>/<code>&amp;nbsp;</code>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown格式中可以使用<code>=</code>和<code>-</code>两种底线形式来标注标题，例如：</p><pre><code>这是标题1==========这是标题2----------</code></pre><blockquote><h1 id="这是标题1"><a href="#这是标题1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2"><a href="#这是标题2" class="headerlink" title="这是标题2"></a>这是标题2</h2></blockquote><p>*注:任何数量的<code>=</code>和<code>-</code>都有效果。</p><p>同时，在Markdown格式中，使用1-6个<code>#</code>加一个空格可以标注1-6级的标题，同时可以选择性在最后使用给一个空格加同样数量的<code>#</code>号来闭合。</p><pre><code># 这是标题1## 这是标题2 ######## 这是标题6</code></pre><blockquote><h1 id="这是标题1-1"><a href="#这是标题1-1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2-1"><a href="#这是标题2-1" class="headerlink" title="这是标题2"></a>这是标题2</h2><h6 id="这是标题6"><a href="#这是标题6" class="headerlink" title="这是标题6"></a>这是标题6</h6></blockquote><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>区块引用使用<code>&gt;</code>在每行的开头标记，也可以在每段开头进行标记，在区块引用中可以进行嵌套，例如：</p><pre><code>&gt; 这是一个区块引用的示例，&gt; 在每行的行的行首使用&quot;&gt;&quot;来标记区块。</code></pre><blockquote><p>这是一个区块引用的示例，<br>在每行的行的行首使用”&gt;”来标记区块。</p></blockquote><p>（这里分隔一下示例，看的更清晰一些。）</p><pre><code>&gt; 当然也可以在每段的段的段首标记，本段都是在区块引用中。&gt; &gt; 这是一个嵌套的区块引用。</code></pre><blockquote><p>当然也可以在每段的段的段首标记，<br>本段都是在区块引用中。</p><blockquote><p>这是一个嵌套的区块引用   </p></blockquote></blockquote><p>在区块引用中可以使用其它Markdown语法，包括标题、列表、代码区块等，这些就不在这演示了。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown支持有序列表和无序列表。<br>无序列表使用<code>*</code>、<code>+</code>或<code>-</code>作为标记，例如:</p><pre><code>* 序列内容1* 序列内容2* 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>等同于<code>+</code>:</p><pre><code>+ 序列内容1+ 序列内容2+ 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3   </li></ul></blockquote><p>等同于<code>-</code>:</p><pre><code>- 序列内容1- 序列内容2- 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>有序列表使用数字后加一个<code>.</code>的形式(数字可以不按顺序或是同一个数字):</p><pre><code>1. 排序12. 排序23. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>同一个数字：</p><pre><code>1. 排序11. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序1</li><li>排序1</li></ol></blockquote><p>数字乱序：</p><pre><code>3. 排序19. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>从示例中看到以上三种标记形式达到的效果是一样的，但是为了不转换成HTML时的可读性，还是尽量使用顺序数字标记。</p><p>如果在列表中分段、使用区块引用和代码区块等，需要在这些标记前使用1-3个空格来标记是在列表中，例如:</p><pre><code>* 这是第一个列表中的第一段   这是第一个列表中的第二段* 这是第二个列表   &gt; 这是第二个列表中的区块引用*这是第三个列表        这是第三个列表中的代码区块</code></pre><blockquote><ul><li><p>这是第一个列表中的第一段</p><p>这是第一个列表中的第二段</p></li><li><p>这是第二个列表</p><blockquote><p>这是第二个列表中的区块引用</p></blockquote></li><li><p>这是第三个列表</p><pre><code>&lt;html&gt;这是第三个列表中的代码区块&lt;/html&gt;</code></pre></li></ul></blockquote><p>###代码区块<br>如果想要写程序代码在文档中，直接在代码前加入4个空格就进入了代码区块中，所有代码区块中都会按照输入原样输出，上面已经使用了很多代码区块，这里就不在演示了。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以使用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来插入一个分割线，此行内不能有任何其他的元素，可以在每个符号间插入空格，效果是一样，例如：</p><pre><code>* * **********- - -————————————</code></pre><blockquote><hr></blockquote><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown格式中支持两种形式的链接语法：行内式和参考式。两种形式的链接文字都使用<code>[]</code>来标记。如果想在链接上加入title文字，组要使用<code>&quot;&quot;</code>把title文字包起来，例如：</p><pre><code>这是一个[示例链接](http://test.com/ &quot;test&quot;)有title。[这是一个链接](http://test.com/)没有title。</code></pre><blockquote><p>这是一个<a href="http://test.com/" title="test" target="_blank" rel="external">示例链接</a>有title。<br><a href="http://test.com/" target="_blank" rel="external">这是一个链接</a>没有title。</p></blockquote><p>如果链接本地资源(同一主机下的资源)，可以使用相对路径：</p><pre><code>同一主机下的[资源](/resource/)。</code></pre><blockquote><p>同一主机下的<a href="/resource/">资源</a>。</p></blockquote><p>参考式链接是在链接文字的方括号后再接一个方括号，在第二个方括号里要填入一个辨识链接的标记，然后在文档任意处把这个链接的内容定义出来，例如：</p><pre><code>这是一个参考式的[链接示例][id](可以选择性在链接和标识间加入空格。)[id]: http://test.com/ &quot;Optional Title Here&quot;以下这两种形式与上面这种形式相同：[id]: http://test.com/ &apos;Optional Title Here&apos;[id]: http://test.com/ (Optional Title Here)链接地址可以使用&lt;&gt;括起来：[id]: &lt;http://test.com/&gt; &quot;Optional Title Here&quot;</code></pre><blockquote><p>这是一个参考式的[链接示例]<a href="可以选择性在链接和标识间加入空格。">id</a></p><p>[id]: <a href="http://test.com/" target="_blank" rel="external">http://test.com/</a> “Optional Title Here”</p></blockquote><p>链接辨别标签可以有字母、数字、空白和标点符号，但不区分大小写, 以下两个链接是相同的:</p><pre><code>[link][a][link][A]</code></pre><p>参考式链接还有一种隐式链接功能，可以省略链接标记，这种情况下，链接标记等同于链接文字，使用隐式链接只要在链接文邹后加上<code>[]</code>即可，比如：</p><pre><code>[Link][][Link]: http://test.com/</code></pre><p>使用参考式链接的好处是使得文档结构简单，使阅读文档时更加清晰。可以让文档更像是转换成HTML后的结构，可以以把一些标记相关的元数据转移到文档最后，不但可以增加链接，还可以让阅读文档时不被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown可以使用<code>*</code>和<code>_</code>作为标记强调符号，被<code>*</code>和<code>_</code>包围的字词会被转换为斜体(一个符号)和粗体(两个符号)，例如：</p><pre><code>*em***strong**_em___strong__</code></pre><blockquote><p><em>em</em><br><strong>strong</strong><br><em>em</em><br><strong>strong</strong></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果在一行内标记一小段的代码，可以使用<code>`` </code>括起来，例如:</p><pre><code>使用`&lt;html&gt;`标签时，可以把它变成代码段。</code></pre><blockquote><p>使用<code>&lt;html&gt;</code>标签时，可以把它变成代码段。</p></blockquote><p>如果想标记<code>` </code>为代码段，需要在<code>`` </code>括起来，并在<code>` </code>前后加入空格;如果在<code>`` </code>中可以加文字需要使用<code>`` `` </code>(<code>`test` </code>)，例如：</p><pre><code>如果想标记` ` `为代码段，需要在` `` `括起来，并在` ` `前后加入空格;如果在` `` `中可以加文字需要使用` `` `` `(`` `test` ``)</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown中使用类似标记链接的语法来标记图片，同样可以使用行内式和参考式。<br>行内式的图片语法是:</p><pre><code>![Alt text](/path/img.jpg)![Alt test](/path/img.jpg &quot;Optional title&quot;)</code></pre><p>参考式的图片语法是:</p><pre><code>![Alt test][id][id]: url/path/image &quot;Optional title attribute&quot;</code></pre><h2 id="其它语法"><a href="#其它语法" class="headerlink" title="其它语法"></a>其它语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在Markdown语法中可以使用<code>-</code>、<code>|</code>和<code>:</code>来画出表格，<code>-</code>代表横线，<code>|</code>代表竖线，<code>:-----:</code>代表横线上的内容居中，例如：</p><pre><code>|Title1      |Title2    |Title3 ||------------|:--------:|:-----:||Content1    |Content2  |Content3|</code></pre><blockquote><table><thead><tr><th>Title1</th><th style="text-align:center">Title2</th><th style="text-align:center">Title3</th></tr></thead><tbody><tr><td>Content1</td><td style="text-align:center">Content2</td><td style="text-align:center">Content3</td></tr></tbody></table></blockquote><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown中支持简单的自动链接形式来出来网址和电子邮箱，使用<code>&lt;&gt;</code>括起来即可，Markdown会自动将它装换成链接形式，例如:</p><pre><code>&lt;http://test.com/&gt;&lt;test@test.com&gt;</code></pre><blockquote><p><a href="http://test.com/" target="_blank" rel="external">http://test.com/</a><br><a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#116;&#x65;&#x73;&#116;&#64;&#116;&#101;&#x73;&#x74;&#46;&#x63;&#111;&#109;">&#116;&#x65;&#x73;&#116;&#64;&#116;&#101;&#x73;&#x74;&#46;&#x63;&#111;&#109;</a></p></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown中可以利用<code>\</code>来转义语法中有特殊意义的符号，例如:在文章中就是想加入<code>*</code>，不想进行强调，可以在<code>*</code>前加入<code>\</code>:</p><pre><code>\*只想在文章中加入`*`\*</code></pre><blockquote><p>*只想在文章中加入<code>*</code>*</p></blockquote><p>Markdown中支持以下符号前加<code>\</code>来转义:</p><blockquote><p><code>\</code>     反斜线<br><code>` </code>   反引号<br><code>*</code>     星号<br><code>_</code>     下划线<br><code>{}</code>    花括号<br><code>[]</code>    方括号<br><code>()</code>    圆括号<br><code>+</code>      加号<br><code>-</code>      减号<br><code>.</code>      英文句号<br><code>!</code>      叹号</p></blockquote><h3 id="Markdown书写软件"><a href="#Markdown书写软件" class="headerlink" title="Markdown书写软件"></a>Markdown书写软件</h3><p>Markdown本身是一种标记性语法，上面提到过，即使不转换成HTML语言可读性也很强，所以任何文本工具都可以使用Markdown语法，有些文本工具可以安装一些插件达到语法高亮的效果，这里就不一一细说了。还有一些软件是可以一边使用Markdown语法书写，同时能看到转换为HTML后的效果，即所见即所得，如:MarkdownPad、马克飞象(Chrome浏览器插件)、Mou等，还有许多在线的书写工具。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文是根据<a href="http://wowubuntu.com/markdown" target="_blank" rel="external">wowubuntu</a>文章，并根据自己的一些理解加以修改而编写的, 一切版权问题依照原作者声明。</p><p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown语法项目(英文)地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://kidnet.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>带有超时设置的subprocess</title>
    <link href="http://kidnet.github.io/2017/09/08/subprocess_with_timeout/"/>
    <id>http://kidnet.github.io/2017/09/08/subprocess_with_timeout/</id>
    <published>2017-09-08T07:50:36.000Z</published>
    <updated>2017-09-13T01:54:54.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频繁调用的定时任务来说，会产生很多卡死的进程(实际中遇到过很多子进程卡死，导致系统资源耗尽，宕机)。为解决这个问题，重新对subprocess封装，加入对调用命令执行超时的处理。</p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><h3 id="重新封装SubWork类"><a href="#重新封装SubWork类" class="headerlink" title="重新封装SubWork类"></a>重新封装SubWork类</h3><p>对subprocess重新封装，定义一些默认属性。</p><pre><code>class SubWork(Object):    def __init__(self):                                                                                                                                           &quot;&quot;&quot;    Default None                                                               &quot;&quot;&quot;                                                                       self._Popen = None                                                         self._pid = None           #子进程PID                                                       self._return_code = None   #执行命令返回值                                               self._cwd = None           #执行目录                                               self._start_time = None    #子进程开始执行的时间戳</code></pre><h3 id="调用命令的内部方法"><a href="#调用命令的内部方法" class="headerlink" title="调用命令的内部方法"></a>调用命令的内部方法</h3><p>这里定义了一个内部方法，用于使用subprocess调用系统命令，并做超时处理。</p><ol><li>subprocess接收命令格式为一个list，所以使用shlex.split()进行命令切分。此方法接收4个参数：命令，标准输出，标准错误和执行目录。</li><li>超时处理，在调用<code>subprocess.Popen()</code>方法后，先获取当前时间戳，然后循环判断，是否程序正常退出(<code>poll()</code>方法获取子进程状态)并且是在超时时间之内，这里用这个循环来代替<code>wait()</code>方法来阻塞进程，并判断超时。如果超过超时时间，方法继续执行，获取进程执行返回的状态(此时可能子进程并未执行完毕)，再次判断子进程是否退出，如在此处还未退出，执行<code>terminate()</code>方法，给子进程发送信号，退出子进程，等待1秒，再次判断进程是否退出，如还未退出证明进程未正常相应<code>terminate()</code>发出的信号，此时使用<code>kill()</code>方法，发出<code>SIGKILL</code>信号，强制退出子进程。</li><li>最终获取子进程退出的状态。</li></ol><p>代码如下:</p><pre><code>def _run(self):    #Run cmd.    #Split command string.    cmd = shlex.split(self._cmd)    self._Popen = subprocess.Popen(args=cmd,                                   stdout=self._stdout_fd,                                   stderr=self._stderr_fd,                                   cwd=self._cwd)    self._pid = self._Popen.pid    self._start_time = time.time()    while (self._Popen.poll() == None and            (time.time() - self._start_time) &lt; self._timeout):        time.sleep(1)    _r_code = self._Popen.poll()    # If child process has not exited yet, terminate it.    if self._Popen.poll() == None:        self._Popen.terminate()        _r_code = 254    # Wait for the child process to exit.    time.sleep(1)    # If child process has not been terminated yet, kill it.    if self._Popen.poll() == None:        self._Popen.kill()        _r_code = 255    self._return_code = _r_code</code></pre><h3 id="对外的方法"><a href="#对外的方法" class="headerlink" title="对外的方法"></a>对外的方法</h3><p>外部调用的方法<code>start()</code>，使用此方法进行执行命令的调用。接收命令，超时时间，标准输入，标准输出，标准错误，是否使用tty(是否将结果输出到终端)，是否使用时间戳(返回结果中打印开始的时间)。此方法主要是调用内部执行命令的方法(_run())，然后对输出进行格式化。</p><pre><code>def start(self,          cmd,          timeout=5*60*60,          stdin=None,          stdout=None,          stderr=None,          tty=False,          timestamp=False):    self._cmd = cmd    self._stdin = stdin    self._stdout = stdout    self._stderr = stderr    self._timeout = timeout    self._is_tty = tty    self._timestamp = timestamp    #Init output.    info = None    err = None    if self._timestamp:        start_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())        file_start = &quot;Start Time: &quot; + start_time + &quot;\n&quot;    else:        file_start = &quot;&quot;        file_end = &quot;&quot;    try:        #Init the file handle of output.        if self._is_tty:            self._stdout_fd = None            self._stderr_fd = None        elif (self._stdout is None or            self._stderr is None or            self._stdout == self._stderr):            self._stdout_fd = tempfile.TemporaryFile()            self._stderr_fd = tempfile.TemporaryFile()        else:            self._stdout_fd = self._create_handler(self._stdout)            self._stderr_fd = self._create_handler(self._stderr)            self._stdout_fd.write(file_start)            self._stdout_fd.flush()            self._stderr_fd.write(file_start)            self._stderr_fd.flush()        self._run()        if self._timestamp:            end_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())            file_end = &quot;End Time: &quot; + end_time + &quot;\n&quot;        #Write and Read output content.        if not self._is_tty:            self._stdout_fd.write(file_end)            self._stderr_fd.write(file_end)            self._stdout_fd.flush()            self._stderr_fd.flush()            self._stdout_fd.seek(0)            self._stderr_fd.seek(0)            info = file_start + self._stdout_fd.read() + file_end            err = file_start + self._stderr_fd.read() + file_end    finally:        #Close file handle.        if not self._is_tty:            self._stdout_fd.close()            self._stderr_fd.close()    return {&quot;code&quot;:self._return_code,            &quot;stdout&quot;:info,            &quot;stderr&quot;:err            }</code></pre><p>  这里输出分为3种类型：</p><ol><li>直接输出到终端，设置tty=True即可，就是直接打印到终端。</li><li>输出到临时文件中，如果tty=False，并且没有输入指定的log文件（stdout和stderr），某块会自动创建一个临时文件来记录日志。</li><li>输出到指定日志中，设置了输出日志，会将命令执行的标准输出和标准错误输出到指定日志文件中（实时输出）。</li></ol><p>*注意: 如果设置使用输出到tty，最终start()方法只会返回命令执行的状态码，不会返回执行结果（已经输出到终端），使用临时文件作为日志或指定输出日志文件，最终start()方法会最终将日志返回给调用的程序。</p><h3 id="对日志处理的方法"><a href="#对日志处理的方法" class="headerlink" title="对日志处理的方法"></a>对日志处理的方法</h3><p>创建日志文件，初始化日志句柄。</p><pre><code>#Create file handle.def _create_handler(self, filename):    if isinstance(filename, file):        return filename    elif isinstance(filename, basestring):        path = os.path.dirname(filename)        timestamp = time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime())        if not os.path.exists(path):            os.makedirs(path)        elif os.path.exists(filename) and not os.path.isfile(filename):            backup_name = filename + timestamp            os.rename(filename, backup_name)        fd = open(filename, &apos;a+b&apos;)        return fd    else:        raise &quot;The type of \&apos;filename\&apos; must be \&apos;file\&apos; or \&apos;basestring\&apos;&quot;</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>SubWork</code>使用方法如下:</p><pre><code>import SubWorkcmd = &quot;/bin/ls /tmp&quot;worker = SubWork()res = worker.start(cmd, 300， &quot;/tmp/stdout.log&quot;, &quot;/tmp/stderr.log&quot;)print res</code></pre><p>这里会执行<code>/bin/ls /tmp</code>命令，超时时间300秒，将执行的标准输出实时输出到<code>/tmp/stdout.log</code>中，将输出的标准错误实时输出到<code>/tmp/stderr.log</code> 中，最终<code>res</code>变量中会有命令执行的状态码和命令执行的输出结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频
      
    
    </summary>
    
      <category term="Python" scheme="http://kidnet.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidnet.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
