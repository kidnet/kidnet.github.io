<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kidnet.github.io/"/>
  <updated>2017-11-28T09:10:46.467Z</updated>
  <id>http://kidnet.github.io/</id>
  
  <author>
    <name>Jason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker系列(五):私有仓库(二)</title>
    <link href="http://kidnet.github.io/2017/11/28/docker-registry-management/"/>
    <id>http://kidnet.github.io/2017/11/28/docker-registry-management/</id>
    <published>2017-11-28T07:31:02.000Z</published>
    <updated>2017-11-28T09:10:46.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一篇讲了使用Registry搭建私有的镜像库，对Registry的管理暂时只能是有API来进行，本篇来介绍使用API管理Registry镜像库。</p><h2 id="Registry镜像的管理"><a href="#Registry镜像的管理" class="headerlink" title="Registry镜像的管理"></a>Registry镜像的管理</h2><h3 id="1-镜像查询"><a href="#1-镜像查询" class="headerlink" title="1. 镜像查询"></a>1. 镜像查询</h3><p>前面已经说到过Registry v2需要通过API进行查询, 对于需要证书及鉴权的Registry通过以下方式查询:</p><pre><code>$ curl --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/_catalog  {&quot;repositories&quot;:[&quot;registry&quot;]}</code></pre><p>可以查看每个镜像的详细信息：</p><pre><code>$ curl -i -X GET -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/registry/manifests/2HTTP/1.1 200 OKContent-Length: 1364Content-Type: application/vnd.docker.distribution.manifest.v2+jsonDocker-Content-Digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6Docker-Distribution-Api-Version: registry/2.0Etag: &quot;sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6&quot;Date: Thu, 09 Nov 2017 22:09:42 GMT{   &quot;schemaVersion&quot;: 2,   &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,   &quot;config&quot;: {      &quot;mediaType&quot;: &quot;application/vnd.docker.container.image.v1+json&quot;,      &quot;size&quot;: 3165,      &quot;digest&quot;: &quot;sha256:a07e3f32a779aa924fd47f6797d4d5c93061c50c0eb97d464f08365a3a30200b&quot;   },   &quot;layers&quot;: [      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 2385012,         &quot;digest&quot;: &quot;sha256:49388a8c9c86a6f56d228954eede699c64fce6c671a989e3e21c391859694645&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 2027027,         &quot;digest&quot;: &quot;sha256:e4d43608dd22de7d12f17ae419ce146094e047e1a739d644e3fcb647f9379bdb&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 6265374,         &quot;digest&quot;: &quot;sha256:3a41740f900cbba03b223c025f03632db1284d85a696677bca8d6375cdf6040b&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 371,         &quot;digest&quot;: &quot;sha256:e16ef4b766841014d6a902f034f0f67698bcbebc1b4c36ff3574d3730e79e2ee&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 213,         &quot;digest&quot;: &quot;sha256:65f212f7c77805418cb85461d93a522c1bf4eebac73009ccd23ac2159ac33dad&quot;      }   ]}</code></pre><p>对于2.3或之前的版本，要使用:指定<code>Accept: application/vnd.docker.distribution.manifest.v2+json</code>头。</p><h3 id="2-镜像删除"><a href="#2-镜像删除" class="headerlink" title="2. 镜像删除"></a>2. 镜像删除</h3><p>对于Registry库中镜像的删除，通过API只能删除镜像的信息，具体的镜像的Layer实际还存在。</p><pre><code>$ curl -i -X DELETE -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \   https://10.0.2.15:5000/v2/registry/manifests/sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6   HTTP/1.1 202 AcceptedDocker-Distribution-Api-Version: registry/2.0Date: Fri, 10 Nov 2017 03:46:09 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8</code></pre><p>这时查看镜像信息显示为未知镜像:</p><pre><code>$ curl -i -X GET -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/registry/manifests/2                                                                            HTTP/1.1 404 Not FoundContent-Type: application/json; charset=utf-8Docker-Distribution-Api-Version: registry/2.0Date: Fri, 10 Nov 2017 03:47:51 GMTContent-Length: 91{&quot;errors&quot;:[{&quot;code&quot;:&quot;MANIFEST_UNKNOWN&quot;,&quot;message&quot;:&quot;manifest unknown&quot;,&quot;detail&quot;:{&quot;Tag&quot;:&quot;2&quot;}}]}</code></pre><p>但再次上传相同镜像的时候，所有Layer提示已经存在:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Layer already exists a2717186d7dd: Layer already exists 656c7684d0bd: Layer already exists 7683d4fcdf4e: Layer already exists ef763da74d91: Layer already exists 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>Docker官方文档中描述的API删除镜像其实是软删除，只是解除信息关联，并没有在真正删除镜像，建议调用API删除成功后到镜像存储目录直接删除该镜像所有信息。</p><p>调用删除API之前，在<code>config.yml</code>中需要增加允许删除的配置:</p><pre><code>$ vim /etc/docker-distribution/registry/config.yml... ...storage:    ... ...    delete:        enabled: true</code></pre><p>增加配置后重启服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;上一篇讲了使用Registry搭建私有的镜像库，对Registry的管理暂时只能是有API来进行，本篇来介绍使用API管理Registry镜
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(四):私有仓库(一)</title>
    <link href="http://kidnet.github.io/2017/11/23/docker-registry/"/>
    <id>http://kidnet.github.io/2017/11/23/docker-registry/</id>
    <published>2017-11-23T07:30:45.000Z</published>
    <updated>2017-11-28T06:38:09.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些私有镜像不方便传输到公共镜像库中，或者内网环境，可以搭建一个私有Registry作为镜像仓库。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>Registry是用于存储和交付Docker镜像的系统。 和本地镜像管理中存储的镜像一样，可以使用不同的标签版本。</p><h3 id="1-使用docker-distribution启动Registry"><a href="#1-使用docker-distribution启动Registry" class="headerlink" title="1. 使用docker-distribution启动Registry"></a>1. 使用<code>docker-distribution</code>启动Registry</h3><p>可以直接安装docker组件distribution来启动Registry。</p><ul><li>安装</li></ul><p>对于CentOS系统，直接使用<code>yum</code>安装即可:</p><pre><code>$ yum install docker-distribution</code></pre><ul><li>启动</li></ul><p>通过<code>systemctl</code>启动Registry服务:</p><pre><code>$ systemctl start docker-distribution</code></pre><ul><li>配置说明</li></ul><p>安装好后的Registry的配置文件可以正常启动应用，修改<code>/etc/docker-distrbution/registry/config.yml</code>文件来修改默认配置:</p><pre><code>version: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registry  #镜像文件存储的目录http:    addr: :5000 #对外服务的端口</code></pre><p>后面会继续说明一些用到的配置。</p><h3 id="2-使用已有的镜像启动Registry"><a href="#2-使用已有的镜像启动Registry" class="headerlink" title="2. 使用已有的镜像启动Registry"></a>2. 使用已有的镜像启动Registry</h3><p>官方文档都是通过下载已经配置好的Registry的镜像，通过容器启动此镜像，来提供Registry的服务。</p><ul><li>下载官方镜像</li></ul><p>直接拉取官方镜像:</p><pre><code>$ docker pull registry:22: Pulling from library/registry49388a8c9c86: Pull complete e4d43608dd22: Pull complete 3a41740f900c: Pull complete e16ef4b76684: Pull complete 65f212f7c778: Pull complete Digest: sha256:d837de65fd9bdb81d74055f1dc9cc9154ad5d8d5328f42f57f273000c402c76dStatus: Downloaded newer image for registry:2</code></pre><ul><li>通过镜像启动Registry服务</li></ul><p>通过官方镜像启动容器:</p><pre><code>$ docker run -d -p 5000:5000 --name registry registry:24199973ca1c7511fd608da534570375023fa69715948b13f4d9b3a3c277d3536$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES4199973ca1c7        registry:2          &quot;/entrypoint.sh /e...&quot;   5 seconds ago       Up 4 seconds        0.0.0.0:5000-&gt;5000/tcp   registry</code></pre><p>其实启动容器时如果没有对应的镜像，会自动下载:</p><pre><code>$ docker run -d -p 5000:5000 --name registry registry:2Unable to find image &apos;registry:2&apos; locally #提示在本地镜像库中没有找到镜像2: Pulling from library/registry          #开始从公共镜像库下载镜像49388a8c9c86: Pull complete e4d43608dd22: Pull complete 3a41740f900c: Pull complete e16ef4b76684: Pull complete 65f212f7c778: Pull complete Digest: sha256:d837de65fd9bdb81d74055f1dc9cc9154ad5d8d5328f42f57f273000c402c76dStatus: Downloaded newer image for registry:2  #镜像下载完成6dabd62f77e8e2079bed029599aea96b65a551bcdb517a4adb24630828dea761 #启动容器$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEregistry            2                   a07e3f32a779        5 days ago          33.3MB$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES6dabd62f77e8        registry:2          &quot;/entrypoint.sh /e...&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:5000-&gt;5000/tcp   registry</code></pre><p>使用容器启动Registry时注意将存储镜像的目录挂载到本地硬盘，如果存储镜像在容器中，容器销毁时，所有镜像也一起销毁:</p><pre><code>$ docker run -d -p 5000:5000 --name registry -v /mnt/registry:/var/lib/registry registry:2</code></pre><h3 id="3-访问无验证的Registry"><a href="#3-访问无验证的Registry" class="headerlink" title="3. 访问无验证的Registry"></a>3. 访问无验证的Registry</h3><p>默认的docker client访问无认证的Registry可能会出现错误：</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: http: server gave HTTP response to HTTPS client</code></pre><p>docker client客户端默认需要访问<code>https</code>的地址，需要增加配置，重启docker:</p><pre><code>$ echo &quot;{\&quot;insecure-registries\&quot;:[\&quot;10.0.2.15:5000\&quot;]}&quot; &gt;&gt; /etc/docker/daemon.json$ systemctl restart docker</code></pre><p>重启后重新推送镜像: </p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Pushed a2717186d7dd: Pushed 656c7684d0bd: Pushed 7683d4fcdf4e: Pushed ef763da74d91: Pushed 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>如果是通过二进制程序启动的docker，直接在启动时增加参数即可:</p><pre><code>$ dockerd --insecure-registry 10.0.2.15:5000 &amp; #如已启动docker，请先停止已启动的进程</code></pre><h3 id="4-查看私有库中的镜像"><a href="#4-查看私有库中的镜像" class="headerlink" title="4. 查看私有库中的镜像"></a>4. 查看私有库中的镜像</h3><p>Registry没有图形界面，只能通过命令访问接口:</p><pre><code>$ curl http://10.0.2.15/v2/_catalog{&quot;repositories&quot;:[&quot;registry&quot;]}</code></pre><h3 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h3><p>以上2种配置启动Registry的方法，对比来说第一种方法(直接安装<code>docker-distribution</code>包)更为方便简洁，后期也较好维护(官网只有第二种方法，根据情况选择适合自己的方法来启动Registry)。</p><h2 id="安全的Registry"><a href="#安全的Registry" class="headerlink" title="安全的Registry"></a>安全的Registry</h2><p>Docker官方是推荐采用带有认证的Registry，传输采用tls。</p><h3 id="1-制作自签署证书"><a href="#1-制作自签署证书" class="headerlink" title="1. 制作自签署证书"></a>1. 制作自签署证书</h3><p>制作证书前需要在<code>openssl.cnf</code>配置中加入证书绑定的域名(或主机名或IP)。否则推送镜像时会差生以下错误:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: x509: cannot validate certificate for 10.0.2.15 because it doesn&apos;t contain any IP SANs</code></pre><p>修改配置文件，加入IP:</p><pre><code>$ cp /etc/pki/tls/openssl.cnf /tmp/$ vim /tmp/openssl.cnf......[v3_ca]subjectAltName = IP: 10.0.2.15</code></pre><p>修改后保存退出即可。继续使用<code>openssl</code>来制作自签署的证书，注意需要指定刚才修改的<code>openssl.cnf</code>配置文件:</p><pre><code>$ mkdir /etc/docker-distribution/registry/certs$ cd /etc/docker-distribution/registry/certs$ openssl req -newkey rsa:2048 -nodes -sha256 -keyout domain.key -x509 -days 365 -out domain.crt -config /tmp/openssl.cnfGenerating a 2048 bit RSA private key.............+++...............................+++writing new private key to &apos;domain.key&apos;-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:BJLocality Name (eg, city) [Default City]:BJOrganization Name (eg, company) [Default Company Ltd]:ZLOrganizational Unit Name (eg, section) []:ZLCommon Name (eg, your name or your server&apos;s hostname) []:registryEmail Address []:$ lsdomain.crt  domain.key</code></pre><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>修改Registry的配置文件，添加<code>tls</code>证书:</p><pre><code>$ vim /etc/docker-distribution/registry/config.ymlversion: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registryhttp:    addr: :5000    #增加以下tls的配置    tls:        certificate: /etc/docker-distribution/registry/certs/domain.crt        key: /etc/docker-distribution/registry/certs/domain.key</code></pre><p>重启Registry服务:</p><pre><code>$ systemctl restart docker-distribution</code></pre><h3 id="3-客户端证书配置"><a href="#3-客户端证书配置" class="headerlink" title="3. 客户端证书配置"></a>3. 客户端证书配置</h3><p>Registry服务配置好后，需要将证书配置到客户端，否则会产生以下错误：</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: x509: cannot validate certificate for 10.0.2.15 because it doesn&apos;t contain any IP SANs</code></pre><p>将证书配置到客户端，并重启客户端:</p><pre><code>$ mkdir -p /etc/docker/certs.d/10.0.2.15:5000# 注意，本文档测试时客户端与私有库是同一台服务器，以下这个证书应该是拷贝到真实的客户端服务器中。$ cp /etc/docker-distribution/registry/certs/domain.crt /etc/docker/certs.d/10.0.2.15\:5000/ca.crt$ systemctl restart docker</code></pre><p>测试是否正常访问私有镜像库:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Pushed a2717186d7dd: Pushed 656c7684d0bd: Pushed 7683d4fcdf4e: Pushed ef763da74d91: Pushed 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><h2 id="Registry鉴权管理"><a href="#Registry鉴权管理" class="headerlink" title="Registry鉴权管理"></a>Registry鉴权管理</h2><p>Registry提供了基础的鉴权方式，可以像公有镜像库一样先登录，再提交镜像。</p><h3 id="1-生成鉴权密码文件"><a href="#1-生成鉴权密码文件" class="headerlink" title="1. 生成鉴权密码文件"></a>1. 生成鉴权密码文件</h3><p>在Registry服务器上，增加一个<code>admin</code>用户，密码为<code>admin123</code>:</p><pre><code>$ mkdir /etc/docker-distribution/registry/auth$ docker run --entrypoint htpasswd registry:2 -Bbn admin admin123 &gt; /etc/docker-distribution/registry/auth/htpasswd</code></pre><h3 id="2-修改配置并重启服务"><a href="#2-修改配置并重启服务" class="headerlink" title="2. 修改配置并重启服务"></a>2. 修改配置并重启服务</h3><p>增加对应配置:</p><pre><code>$ vim /etc/docker-distribution/registry/config.ymlversion: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registryhttp:    addr: :5000    tls:        certificate: /etc/docker-distribution/registry/certs/domain.crt        key: /etc/docker-distribution/registry/certs/domain.key#增加以下配置:    auth:    htpasswd:        realm: basic-realm        path: /etc/docker-distribution/registry/auth/htpasswd</code></pre><p>重启服务:</p><pre><code>$ systemctl restart docker-distribution</code></pre><p>测试推送镜像:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2                                                                                 The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Preparing a2717186d7dd: Preparing 656c7684d0bd: Preparing 7683d4fcdf4e: Preparing ef763da74d91: Preparing no basic auth credentials</code></pre><p>推送失败，尝试登录后再次推送:</p><pre><code>$ docker login 10.0.2.15:5000Username: adminPassword: Login Succeeded$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Layer already exists a2717186d7dd: Layer already exists 656c7684d0bd: Layer already exists 7683d4fcdf4e: Layer already exists ef763da74d91: Layer already exists 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>成功登录后，推送镜像成功(因之前已推送过此镜像，所以提示镜像已存在)。</p><h2 id="使用容器启动的Registry的安全和鉴权配置"><a href="#使用容器启动的Registry的安全和鉴权配置" class="headerlink" title="使用容器启动的Registry的安全和鉴权配置"></a>使用容器启动的Registry的安全和鉴权配置</h2><p>使用容器启动的Registry可以通过多种方法进行配置：</p><ul><li>使用Dockerfile将修改好的配置文件、证书及密码文件打入启动镜像。</li></ul><p>如Dockerfile加入下列几行后重新制作镜像:    </p><pre><code>COPY config.yml /etc/docker/registry/config.ymlCOPY domain.crt /etc/docker/registry/domain.crtCOPY domain.key /etc/docker/registry/domain.keyCOPY htpasswd /etc/docker/registry/htpasswd</code></pre><ul><li>将修改好的配置文件、证书及密码文件的目录挂载到镜像对应目录。</li></ul><p>启动镜像时将配置目录重新挂载:</p><pre><code>$ docker run -d -p 5000:5000 --name registry \  -v /mnt/registry:/var/lib/registry \  -v /config:/etc/docker/registry \  registry:2</code></pre><ul><li>启动容器时使用特定环境变量指定修改。</li></ul><p>启动容器是通过环境变量也可以修改Registry的配置: </p><pre><code>$ docker run -d -p 5000:5000 --restart=always --name registry \-v `pwd`/auth:/auth \-e &quot;REGISTRY_AUTH=htpasswd&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \-v `pwd`/data:/var/lib/registry \-v `pwd`/certs:/certs \-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \-e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \registry:2</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;有些私有镜像不方便传输到公共镜像库中，或者内网环境，可以搭建一个私有Registry作为镜像仓库。&lt;/p&gt;
&lt;h2 id=&quot;Docker-R
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(三):容器管理</title>
    <link href="http://kidnet.github.io/2017/11/22/docker-container-management/"/>
    <id>http://kidnet.github.io/2017/11/22/docker-container-management/</id>
    <published>2017-11-22T02:59:11.000Z</published>
    <updated>2017-11-28T06:06:53.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前已经介绍了镜像管理，有了镜像，就可以使用镜像来启动容器(应用环境)。</p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>Docker容器基于已有的镜像启动，下面介绍对于容器的管理。</p><h3 id="1-容器启动"><a href="#1-容器启动" class="headerlink" title="1. 容器启动"></a>1. 容器启动</h3><p>选择好镜像后就可以启动容器，启动容器时可以选择多种参数，也可以将需要的参数(部分)定义到Dockerfile，直接打入镜像(但启动时使用的参数会覆盖镜像中已定义好的参数。)。</p><ul><li>使用参数启动容器</li></ul><p>使用<code>docker run [Options] image_name[:image_tag] [CMD]</code>基于选定镜像启动容器: </p><pre><code>$ docker images #Display imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB$ docker run -d centos-sshd /sbin/init #Start containerc7dc163219834374a02e4ee7c91da202a12c847dc3e51a741762af12c7fca919</code></pre><p>这样就使用<code>centos-sshd</code>镜像启动了一个容器。</p><ul><li>常用参数说明</li></ul><p>以下是启动容器时经常使用的一些参数:</p><pre><code>-p 端口映射，&lt;local_ip&gt;:&lt;local_port&gt;:&lt;container_port&gt;-v 挂载本地目录, &lt;local_path&gt;:&lt;container_path&gt;-d 以分离模式(detached mode)启动（简单理解为后台运行）-t 分配一个伪终端(pseudo-tty)-i 打开STDIN(没用-a指定的话)-e 在container中增加一个环境变量(ENV)--privileged 允许container访问所有device(例如 cgruop)--rm 退出容器时自动删除(销毁)容器--name 指定容器的名称(如不指定，系统会随机分配名称)[CMD] 启动时运行的命令，如果在启动容器是使用CMD，在创建镜像时Dockerfile中的CMD会被覆盖，另外，注意，这个CMD必须是一直运行的一个命令，不然命令结束，container会自动退出</code></pre><ul><li>Dockerfile</li></ul><p>使用Dockerfile将部分启动参数打入镜像:</p><pre><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] #使Container监听指定端口。VOLUME &lt;local_path&gt; #将本地目录映射到容器中(不等同于-v参数)。CMD [&quot;CMD1&quot;, &quot;CMD2&quot;, ...] #启动容器时运行的命令。ENV &lt;key&gt; &lt;value&gt; (or ENV &lt;key&gt;=&lt;value&gt; ...) #指定Container启动后的环境变量。</code></pre><h3 id="2-查看容器状态"><a href="#2-查看容器状态" class="headerlink" title="2. 查看容器状态"></a>2. 查看容器状态</h3><p>启动容器后可以查看所有容器的状态，通过<code>docker ps [-a]</code>:</p><pre><code>$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 5 hours                              nervous_poitras</code></pre><p>可以看到正在运行中的容器，之前启动容器时没有指定名字，由系统分配了一个名字。 <code>-a</code>参数可以看到所有容器(包括已经停止的容器)：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 5 hours                                     nervous_poitrasdb8415d50a86        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 hours ago                       gallant_kilby</code></pre><p>可以看到第二个容器是已经停止的容器。</p><h3 id="3-停止运行的容器"><a href="#3-停止运行的容器" class="headerlink" title="3. 停止运行的容器"></a>3. 停止运行的容器</h3><p>使用<code>docker stop &lt;container_id&gt;</code>来停止正在运行的容器:</p><pre><code>$ docker stop c7dc16321983c7dc16321983$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre><p>使用<code>docker ps</code>可以看到没有在运行的容器了，再使用<code>docker ps -a</code>来看看所有容器：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 seconds ago                       nervous_poitrasdb8415d50a86        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 hours ago                         gallant_kilby</code></pre><p>可以看到有两个已经停止的容器了，如果想把容器再次启动，使用<code>docker start &lt;container_id&gt;</code>即可。 如果启动是使用了<code>--rm</code>参数的话，停止容器后，容器立即被销毁，通过<code>docker ps -a</code>也不会再看到此容器了。</p><h3 id="4-销毁-删除-容器"><a href="#4-销毁-删除-容器" class="headerlink" title="4. 销毁(删除)容器"></a>4. 销毁(删除)容器</h3><p>将已经停止的容器销毁(删除), 有时需要将不再使用的容器销毁，以免占用系统资源, 使用<code>docker rm &lt;container_id&gt;</code>:</p><pre><code>$ docker rm db8415d50a86db8415d50a86$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 minutes ago                       nervous_poitras</code></pre><p>执行命令后，将已经停止的一个容器销毁了。</p><h3 id="5-进入已启动容器的系统"><a href="#5-进入已启动容器的系统" class="headerlink" title="5. 进入已启动容器的系统"></a>5. 进入已启动容器的系统</h3><p>有时需要进入已经启动容器的系统进行一下操作，使用<code>docker exec [option] container_id [CMD]</code>:</p><pre><code>$ docker ps CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 9 seconds                            nervous_poitras$ docker exec -ti c7dc16321983 /bin/bash[root@c7dc16321983 /]#</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前已经介绍了镜像管理，有了镜像，就可以使用镜像来启动容器(应用环境)。&lt;/p&gt;
&lt;h2 id=&quot;容器管理&quot;&gt;&lt;a href=&quot;#容器管理&quot;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(二):镜像管理</title>
    <link href="http://kidnet.github.io/2017/10/29/docker-image-management/"/>
    <id>http://kidnet.github.io/2017/10/29/docker-image-management/</id>
    <published>2017-10-29T07:32:20.000Z</published>
    <updated>2017-11-28T06:06:40.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker的容器是基于镜像的，所有容器是通过制作好的镜像启动的，下面会介绍镜像的管理和容器的管理。</p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><p>Docker的镜像可以通过多种途径获取，获取镜像后将镜像存入本地镜像库中，以供容器使用。</p><h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h3><p>镜像可以从公共镜像库中获取(类似yum源)，也可以自己制作，或导入已有镜像(从别的Docker导出的或OpenVZ一类虚拟化软件中导出的)。</p><ul><li>从公共镜像库中获取镜像</li></ul><p>使用<code>docker pull &lt;image_name&gt;[:tag]</code>命令从公共镜像库中获取镜像: </p><pre><code>$ docker pull centosUsing default tag: latestlatest: Pulling from library/centosd9aaf4d82f24: Pull complete Digest: sha256:4565fe2dd7f4770e825d4bd9c761a81b26e49cc9e3c9631c58cfc3188be9505aStatus: Downloaded newer image for centos:latest</code></pre><p>不指定<code>tag</code>的会自动选择使用<code>latest</code>标签。</p><p>公共镜像库支持查询功能，可以先使用<code>docker search &lt;image_name&gt;</code>查询需要的镜像是否存在:</p><pre><code>$ docker search centosNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                             The official build of CentOS.                   3789      [OK]       ansible/centos7-ansible            Ansible on Centos7                              103                  [OK]jdeathe/centos-ssh                 CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x8...   89                   [OK]tutum/centos                       Simple CentOS docker image with SSH access      33                   imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              31                   [OK]gluster/gluster-centos             Official GlusterFS Image [ CentOS-7 +  Glu...   21                   [OK]kinogmt/centos-ssh                 CentOS with SSH                                 17                   [OK]......</code></pre><ul><li>导入镜像 </li></ul><p>使用<code>docker load &lt; &lt;image_file_name&gt;</code>导入从其他Docker导出的镜像:</p><pre><code>$ docker load &lt; centos-sshd36018b5e9787: Loading layer [==================================================&gt;]  200.1MB/200.1MB56ab33f0cb6c: Loading layer [==================================================&gt;]  61.48MB/61.48MB52d118e898dd: Loading layer [==================================================&gt;]  21.99MB/21.99MB52e44758f62d: Loading layer [==================================================&gt;]  1.678MB/1.678MB6f88bf69d4eb: Loading layer [==================================================&gt;]  1.707MB/1.707MB5afae9f25cde: Loading layer [==================================================&gt;]  1.787MB/1.787MBLoaded image ID: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426    </code></pre><p>使用<code>cat &lt;openvz_image_file_name&gt; | docker import - &lt;image_name&gt;:&lt;tag&gt;</code>导入从虚拟化软件(OpenVZ)导出的镜像:</p><pre><code>$ cat centos-6-x86_64.tar.gz | docker import - centos:6sha256:54152fdb34278505a2007911a211ccd6d1d78dd946522bf797f2cf971efb89cf</code></pre><p>(<a href="https://openvz.org/Download/template/precreated" target="_blank" rel="external">OpenVZ镜像下载地址</a>)</p><h3 id="2-本地镜像"><a href="#2-本地镜像" class="headerlink" title="2. 本地镜像"></a>2. 本地镜像</h3><p>启动容器的镜像都是在本地镜像库中，对本地镜像库可以进行管理(删除，标签管理等)。</p><ul><li>本地镜像列表</li></ul><p>管理本地镜像需要了解本地已存在的镜像:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              6                   54152fdb3427        17 minutes ago      825MBcentos              latest              d123f4e55e12        3 days ago          197MBcentos-sshd         latest              b8c73db541e7        6 months ago        280MB</code></pre><p>本地镜像中会列出镜像名称，id及tag(版本)。</p><ul><li>删除本地镜像</li></ul><p>如果本地镜像过多，有些过时的镜像，或者不再使用的镜像，需要被删除时，可以使用以下命令:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB#docker rmi &lt;image_name&gt;:&lt;tag&gt; $ docker rmi centos-sshd：latestUntagged: centos-sshd:latestDeleted: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426Deleted: sha256:5fdcd47722d29774d897562430801f6d1c168a422bcce5de1a6ace65302f900dDeleted: sha256:4e8a967d0d44bbd801c7787c2f750036988f92f28aeb76feb83293421de32a5dDeleted: sha256:50691d2b55b131e1ee4ccee1981556c631f55bb9f57269ceb00cf71c0b0e13bdDeleted: sha256:a84fc4ac805b0593c8e7a61a4d774f261cc4a4de6db1ff812c02b8524127d91bDeleted: sha256:0f8d19a2914ef598af3cc2dc8861b78b4b0d3b848d4eae97f2c81ba8e9f55015Deleted: sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c#检查镜像是否已被删除(唯一的一个本地镜像已被删除)$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</code></pre><p>如果一个镜像有多个tag的话，只会删除此tag:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         7.2                 b8c73db541e7        6 months ago        280MBcentos-sshd         latest              b8c73db541e7        6 months ago        280MB$ docker rmi centos-sshd：latestUntagged: centos-sshd:latest #提示只是删除了镜像的一个tag$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         7.2                 b8c73db541e7        6 months ago        280MB     </code></pre><p>使用镜像ID删除镜像(无论有多少个tag，都会先删除tag，然后彻底删除镜像):</p><pre><code>#dokcer rmi &lt;image_id&gt;$ docker rmi d123f4e55e12Untagged: centos-sshd:7.2Deleted: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426Deleted: sha256:5fdcd47722d29774d897562430801f6d1c168a422bcce5de1a6ace65302f900dDeleted: sha256:4e8a967d0d44bbd801c7787c2f750036988f92f28aeb76feb83293421de32a5dDeleted: sha256:50691d2b55b131e1ee4ccee1981556c631f55bb9f57269ceb00cf71c0b0e13bdDeleted: sha256:a84fc4ac805b0593c8e7a61a4d774f261cc4a4de6db1ff812c02b8524127d91bDeleted: sha256:0f8d19a2914ef598af3cc2dc8861b78b4b0d3b848d4eae97f2c81ba8e9f55015Deleted: sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c</code></pre><p> *注: 如果此镜像被其他镜像依赖，无法删除(后面会介绍依赖关系)。</p><ul><li>导出镜像</li></ul><p>有时可能需要从一个Docker中导出镜像到另一个Docker中，导出本地镜像的方法如下:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB#docker save &lt;image_id&gt; &gt; &lt;export_image_name&gt;$docker save b8c73db541e7 &gt; centos-sshd$lscentso-sshd</code></pre><h3 id="3-镜像制作"><a href="#3-镜像制作" class="headerlink" title="3. 镜像制作"></a>3. 镜像制作</h3><p>有时标准镜像的内容无法满足我们的需求，这时就需要自己制作镜像，这里介绍的制作镜像的方法是基于已有镜像，或将一个启动的容器提交为一个镜像。</p><ul><li>基于已有镜像制作镜像</li></ul><p>使用Dockerfile基于已有镜像制作新的镜像，一个简单的Dockerfile：</p><pre><code># Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [&quot;python&quot;, &quot;app.py&quot;]</code></pre><p>上面Dockerfile中制作了一个python应用的镜像(Dockerfile中可以同时定义容器的启动的参数，后面会详细介绍)，需要<code>requirements.txt</code>(运行这个python应用需要的模块)和<code>app.py</code>(python应用)，这两个文件需要和Dockerfile在同一个目录中(<code>ADD . /app</code>定义的)：</p><pre><code>$ lsDockerfile        app.py            requirements.txt</code></pre><p>最后使用以下命令制作镜像:</p><pre><code>docker build -t firstapp .</code></pre><p>在本地镜像库可以看到刚刚生成的镜像:</p><pre><code>$ docker imagesREPOSITORY            TAG                 IMAGE IDfirstapp         latest              326387cea398</code></pre><ul><li>基于容器制作镜像</li></ul><p>想对已有镜像做简单修改，或者不习惯于写Dockerfile，可以使用镜像启动一个容器，然后在容器中对系统进行修改，修改后将内容重新提交为一个新的镜像:</p><pre><code>$ docker commit &lt;container_id&gt; &lt;image_name&gt;:[&lt;tag&gt;]</code></pre><h3 id="4-镜像推送"><a href="#4-镜像推送" class="headerlink" title="4. 镜像推送"></a>4. 镜像推送</h3><p>将本地镜像(自己制作的镜像)，推送到镜像库(多用于私有镜像库，如是公共项目提交到公共镜像库)。</p><ul><li>推送到公共镜像库</li></ul><p>将自己制作的镜像，推送到公共镜像库，需要有对应镜像库的权限(登录认证)，才可以推送到对应的镜像库中。</p><p>登录到公共镜像库:</p><pre><code>$ docker loginLogin with yourDocker ID to push and pull images from Docker Hub. If you don&apos;t have a DockerID, head over to https://hub.docker.com tocreate one.Username: test #Your login namePassword:Login Succeeded</code></pre><p>*可以到<a href="http://hub.docker.com" target="_blank" rel="external">Docker公共镜像库</a>创建账号，建立自己的镜像库(类似于github)。</p><p>推送镜像:</p><pre><code>$ docker push &lt;login_name&gt;/&lt;image_name&gt;:&lt;tag&gt;$ docker push test/firstapp:lastThe push refers to arepository [docker.io/test/firstapp]34e7b85d83e4: Pushed last: digest:sha256:dafc45b8b533d5ad5564a3821e9e1a252b58f44e69c6052bddcd00139782ee08     size:529</code></pre><ul><li>推送到私有镜像库</li></ul><p>有时自己的镜像不想被别人看到，这时可以搭建自己的私有镜像库(后续会介绍)，然后将自己的镜像提交到私有的镜像库。</p><p>私有镜像库可以不需要登录(如果需要登录，登录过程和提交到公有镜像库一样)，先给需要提交的镜像设置一个<code>tag</code>，<code>tag</code>中将私有镜像库的地址写入即可(IP，hostname或域名):</p><pre><code>$ docker &lt;image_id&gt; &lt;private_registry_address&gt;/&lt;image_name&gt;:&lt;tag&gt;$ docker tag 34e7b85d83e4 10.236.100.3:5000/firstapp:last$ docker push 10.236.100.3:5000/firstapp:lastrepository [10.236.100.3:5000/firstapp]acce4ec5f074: Pushed5d450a8c7e38: Pushede8fd5087fa08: Pushedcf394a2f01e4: Pushedf16d5ac23cee: Pushed57861a68f43a: Pushed97ca462ad9ee: Pushedlast: digest:sha256:b0851324bac55083172ed2068dfb388acabdce14dffdb9787f4e6c044b524f19     size:1764</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Docker的容器是基于镜像的，所有容器是通过制作好的镜像启动的，下面会介绍镜像的管理和容器的管理。&lt;/p&gt;
&lt;h2 id=&quot;镜像管理&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(一):安装</title>
    <link href="http://kidnet.github.io/2017/09/19/docker-install/"/>
    <id>http://kidnet.github.io/2017/09/19/docker-install/</id>
    <published>2017-09-19T10:04:08.000Z</published>
    <updated>2017-11-28T06:06:27.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。</p><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装:"></a>yum安装:</h2><h3 id="安装docker源"><a href="#安装docker源" class="headerlink" title="安装docker源"></a>安装docker源</h3><p>使用yum安装doucker之前，需要先设置docker的yum源。</p><p>1.安装源需要的包: <code>yum-utils</code>, <code>yum-config-manager</code>, <code>device-mapper-persistent-data</code>, <code>lvm2</code>及<code>devicemapper</code></p><pre><code>$ yum install -y yum-utils \  device-mapper-persistent-data \  lvm2</code></pre><p>2.安装docker源  </p><pre><code>$ yum-config-manager \  --add-repo \  https://download.docker.com/linux/centos/docker-ce.repo</code></pre><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>1.安装最新版本docker</p><pre><code>$ yum install docker-ce</code></pre><p>2.启动docker</p><pre><code>$ systemctl start docker</code></pre><p>3.验证docker是否安装正确</p><pre><code>$ docker run hello-world</code></pre><h2 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h2><h3 id="安装静态二进制"><a href="#安装静态二进制" class="headerlink" title="安装静态二进制"></a>安装静态二进制</h3><p>1.下载静态二进制包。下载地址:<a href="https://download.docker.com/linux/static/stable/x86_64/" target="_blank" rel="external">https://download.docker.com/linux/static/stable/x86_64/</a></p><p>2.解压缩tar包  </p><pre><code>$ tar -xzvf /path/to/&lt;FILE&gt;.tar.gz</code></pre><p>3.将二进制文件拷贝至系统命令目录，如<code>/usr/bin</code>  </p><pre><code>$ cp docker/* /usr/bin/</code></pre><p>4.启动Docker daemon:  </p><pre><code>$ dockerd &amp;</code></pre><p>5.验证docker是否安装正确  </p><pre><code>$ docker run hello-world</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。&lt;/p&gt;
&lt;h2 id=&quot;yum安装&quot;&gt;&lt;a href=&quot;#yum安装
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://kidnet.github.io/2017/09/11/markdown/"/>
    <id>http://kidnet.github.io/2017/09/11/markdown/</id>
    <published>2017-09-11T08:19:20.000Z</published>
    <updated>2017-09-11T08:19:23.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前使用dokuwiki系统做共享文档的平台，接触到了Markdown这种书写格式。最近开始折腾在github上搭建blog，又用到了Markdown，但是好多都忘光了，从头复习一下。Markdown的目标是易读易写，让作者专注于写作，不用太多关心排版的问题,即使不把Markdown格式转化为HTML，可读性依然很强。Markdown格式是可以以纯文档的方式发布，使用标签或是格式指令构成，可以兼容HTML。</p><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>连续的文本组成一个段落，每个段落前后有一个以上的空行。每个段落不能使用空格或制表符来缩进，如果想要缩进只能使用HTML元素，比如：<code>&amp;emsp;</code>/<code>&amp;ensp;</code>/<code>&amp;nbsp;</code>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown格式中可以使用<code>=</code>和<code>-</code>两种底线形式来标注标题，例如：</p><pre><code>这是标题1==========这是标题2----------</code></pre><blockquote><h1 id="这是标题1"><a href="#这是标题1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2"><a href="#这是标题2" class="headerlink" title="这是标题2"></a>这是标题2</h2></blockquote><p>*注:任何数量的<code>=</code>和<code>-</code>都有效果。</p><p>同时，在Markdown格式中，使用1-6个<code>#</code>加一个空格可以标注1-6级的标题，同时可以选择性在最后使用给一个空格加同样数量的<code>#</code>号来闭合。</p><pre><code># 这是标题1## 这是标题2 ######## 这是标题6</code></pre><blockquote><h1 id="这是标题1-1"><a href="#这是标题1-1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2-1"><a href="#这是标题2-1" class="headerlink" title="这是标题2"></a>这是标题2</h2><h6 id="这是标题6"><a href="#这是标题6" class="headerlink" title="这是标题6"></a>这是标题6</h6></blockquote><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>区块引用使用<code>&gt;</code>在每行的开头标记，也可以在每段开头进行标记，在区块引用中可以进行嵌套，例如：</p><pre><code>&gt; 这是一个区块引用的示例，&gt; 在每行的行的行首使用&quot;&gt;&quot;来标记区块。</code></pre><blockquote><p>这是一个区块引用的示例，<br>在每行的行的行首使用”&gt;”来标记区块。</p></blockquote><p>（这里分隔一下示例，看的更清晰一些。）</p><pre><code>&gt; 当然也可以在每段的段的段首标记，本段都是在区块引用中。&gt; &gt; 这是一个嵌套的区块引用。</code></pre><blockquote><p>当然也可以在每段的段的段首标记，<br>本段都是在区块引用中。</p><blockquote><p>这是一个嵌套的区块引用   </p></blockquote></blockquote><p>在区块引用中可以使用其它Markdown语法，包括标题、列表、代码区块等，这些就不在这演示了。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown支持有序列表和无序列表。<br>无序列表使用<code>*</code>、<code>+</code>或<code>-</code>作为标记，例如:</p><pre><code>* 序列内容1* 序列内容2* 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>等同于<code>+</code>:</p><pre><code>+ 序列内容1+ 序列内容2+ 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3   </li></ul></blockquote><p>等同于<code>-</code>:</p><pre><code>- 序列内容1- 序列内容2- 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>有序列表使用数字后加一个<code>.</code>的形式(数字可以不按顺序或是同一个数字):</p><pre><code>1. 排序12. 排序23. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>同一个数字：</p><pre><code>1. 排序11. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序1</li><li>排序1</li></ol></blockquote><p>数字乱序：</p><pre><code>3. 排序19. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>从示例中看到以上三种标记形式达到的效果是一样的，但是为了不转换成HTML时的可读性，还是尽量使用顺序数字标记。</p><p>如果在列表中分段、使用区块引用和代码区块等，需要在这些标记前使用1-3个空格来标记是在列表中，例如:</p><pre><code>* 这是第一个列表中的第一段   这是第一个列表中的第二段* 这是第二个列表   &gt; 这是第二个列表中的区块引用*这是第三个列表        这是第三个列表中的代码区块</code></pre><blockquote><ul><li><p>这是第一个列表中的第一段</p><p>这是第一个列表中的第二段</p></li><li><p>这是第二个列表</p><blockquote><p>这是第二个列表中的区块引用</p></blockquote></li><li><p>这是第三个列表</p><pre><code>&lt;html&gt;这是第三个列表中的代码区块&lt;/html&gt;</code></pre></li></ul></blockquote><p>###代码区块<br>如果想要写程序代码在文档中，直接在代码前加入4个空格就进入了代码区块中，所有代码区块中都会按照输入原样输出，上面已经使用了很多代码区块，这里就不在演示了。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以使用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来插入一个分割线，此行内不能有任何其他的元素，可以在每个符号间插入空格，效果是一样，例如：</p><pre><code>* * **********- - -————————————</code></pre><blockquote><hr></blockquote><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown格式中支持两种形式的链接语法：行内式和参考式。两种形式的链接文字都使用<code>[]</code>来标记。如果想在链接上加入title文字，组要使用<code>&quot;&quot;</code>把title文字包起来，例如：</p><pre><code>这是一个[示例链接](http://test.com/ &quot;test&quot;)有title。[这是一个链接](http://test.com/)没有title。</code></pre><blockquote><p>这是一个<a href="http://test.com/" title="test" target="_blank" rel="external">示例链接</a>有title。<br><a href="http://test.com/" target="_blank" rel="external">这是一个链接</a>没有title。</p></blockquote><p>如果链接本地资源(同一主机下的资源)，可以使用相对路径：</p><pre><code>同一主机下的[资源](/resource/)。</code></pre><blockquote><p>同一主机下的<a href="/resource/">资源</a>。</p></blockquote><p>参考式链接是在链接文字的方括号后再接一个方括号，在第二个方括号里要填入一个辨识链接的标记，然后在文档任意处把这个链接的内容定义出来，例如：</p><pre><code>这是一个参考式的[链接示例][id](可以选择性在链接和标识间加入空格。)[id]: http://test.com/ &quot;Optional Title Here&quot;以下这两种形式与上面这种形式相同：[id]: http://test.com/ &apos;Optional Title Here&apos;[id]: http://test.com/ (Optional Title Here)链接地址可以使用&lt;&gt;括起来：[id]: &lt;http://test.com/&gt; &quot;Optional Title Here&quot;</code></pre><blockquote><p>这是一个参考式的[链接示例]<a href="可以选择性在链接和标识间加入空格。">id</a></p><p>[id]: <a href="http://test.com/" target="_blank" rel="external">http://test.com/</a> “Optional Title Here”</p></blockquote><p>链接辨别标签可以有字母、数字、空白和标点符号，但不区分大小写, 以下两个链接是相同的:</p><pre><code>[link][a][link][A]</code></pre><p>参考式链接还有一种隐式链接功能，可以省略链接标记，这种情况下，链接标记等同于链接文字，使用隐式链接只要在链接文邹后加上<code>[]</code>即可，比如：</p><pre><code>[Link][][Link]: http://test.com/</code></pre><p>使用参考式链接的好处是使得文档结构简单，使阅读文档时更加清晰。可以让文档更像是转换成HTML后的结构，可以以把一些标记相关的元数据转移到文档最后，不但可以增加链接，还可以让阅读文档时不被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown可以使用<code>*</code>和<code>_</code>作为标记强调符号，被<code>*</code>和<code>_</code>包围的字词会被转换为斜体(一个符号)和粗体(两个符号)，例如：</p><pre><code>*em***strong**_em___strong__</code></pre><blockquote><p><em>em</em><br><strong>strong</strong><br><em>em</em><br><strong>strong</strong></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果在一行内标记一小段的代码，可以使用<code>`` </code>括起来，例如:</p><pre><code>使用`&lt;html&gt;`标签时，可以把它变成代码段。</code></pre><blockquote><p>使用<code>&lt;html&gt;</code>标签时，可以把它变成代码段。</p></blockquote><p>如果想标记<code>` </code>为代码段，需要在<code>`` </code>括起来，并在<code>` </code>前后加入空格;如果在<code>`` </code>中可以加文字需要使用<code>`` `` </code>(<code>`test` </code>)，例如：</p><pre><code>如果想标记` ` `为代码段，需要在` `` `括起来，并在` ` `前后加入空格;如果在` `` `中可以加文字需要使用` `` `` `(`` `test` ``)</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown中使用类似标记链接的语法来标记图片，同样可以使用行内式和参考式。<br>行内式的图片语法是:</p><pre><code>![Alt text](/path/img.jpg)![Alt test](/path/img.jpg &quot;Optional title&quot;)</code></pre><p>参考式的图片语法是:</p><pre><code>![Alt test][id][id]: url/path/image &quot;Optional title attribute&quot;</code></pre><h2 id="其它语法"><a href="#其它语法" class="headerlink" title="其它语法"></a>其它语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在Markdown语法中可以使用<code>-</code>、<code>|</code>和<code>:</code>来画出表格，<code>-</code>代表横线，<code>|</code>代表竖线，<code>:-----:</code>代表横线上的内容居中，例如：</p><pre><code>|Title1      |Title2    |Title3 ||------------|:--------:|:-----:||Content1    |Content2  |Content3|</code></pre><blockquote><table><thead><tr><th>Title1</th><th style="text-align:center">Title2</th><th style="text-align:center">Title3</th></tr></thead><tbody><tr><td>Content1</td><td style="text-align:center">Content2</td><td style="text-align:center">Content3</td></tr></tbody></table></blockquote><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown中支持简单的自动链接形式来出来网址和电子邮箱，使用<code>&lt;&gt;</code>括起来即可，Markdown会自动将它装换成链接形式，例如:</p><pre><code>&lt;http://test.com/&gt;&lt;test@test.com&gt;</code></pre><blockquote><p><a href="http://test.com/" target="_blank" rel="external">http://test.com/</a><br><a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x74;&#101;&#115;&#116;&#x40;&#116;&#x65;&#115;&#x74;&#x2e;&#99;&#x6f;&#109;">&#x74;&#101;&#115;&#116;&#x40;&#116;&#x65;&#115;&#x74;&#x2e;&#99;&#x6f;&#109;</a></p></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown中可以利用<code>\</code>来转义语法中有特殊意义的符号，例如:在文章中就是想加入<code>*</code>，不想进行强调，可以在<code>*</code>前加入<code>\</code>:</p><pre><code>\*只想在文章中加入`*`\*</code></pre><blockquote><p>*只想在文章中加入<code>*</code>*</p></blockquote><p>Markdown中支持以下符号前加<code>\</code>来转义:</p><blockquote><p><code>\</code>     反斜线<br><code>` </code>   反引号<br><code>*</code>     星号<br><code>_</code>     下划线<br><code>{}</code>    花括号<br><code>[]</code>    方括号<br><code>()</code>    圆括号<br><code>+</code>      加号<br><code>-</code>      减号<br><code>.</code>      英文句号<br><code>!</code>      叹号</p></blockquote><h3 id="Markdown书写软件"><a href="#Markdown书写软件" class="headerlink" title="Markdown书写软件"></a>Markdown书写软件</h3><p>Markdown本身是一种标记性语法，上面提到过，即使不转换成HTML语言可读性也很强，所以任何文本工具都可以使用Markdown语法，有些文本工具可以安装一些插件达到语法高亮的效果，这里就不一一细说了。还有一些软件是可以一边使用Markdown语法书写，同时能看到转换为HTML后的效果，即所见即所得，如:MarkdownPad、马克飞象(Chrome浏览器插件)、Mou等，还有许多在线的书写工具。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文是根据<a href="http://wowubuntu.com/markdown" target="_blank" rel="external">wowubuntu</a>文章，并根据自己的一些理解加以修改而编写的, 一切版权问题依照原作者声明。</p><p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown语法项目(英文)地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://kidnet.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>带有超时设置的subprocess</title>
    <link href="http://kidnet.github.io/2017/09/08/subprocess_with_timeout/"/>
    <id>http://kidnet.github.io/2017/09/08/subprocess_with_timeout/</id>
    <published>2017-09-08T07:50:36.000Z</published>
    <updated>2017-09-13T01:54:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频繁调用的定时任务来说，会产生很多卡死的进程(实际中遇到过很多子进程卡死，导致系统资源耗尽，宕机)。为解决这个问题，重新对subprocess封装，加入对调用命令执行超时的处理。</p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><h3 id="重新封装SubWork类"><a href="#重新封装SubWork类" class="headerlink" title="重新封装SubWork类"></a>重新封装SubWork类</h3><p>对subprocess重新封装，定义一些默认属性。</p><pre><code>class SubWork(Object):    def __init__(self):                                                                                                                                           &quot;&quot;&quot;    Default None                                                               &quot;&quot;&quot;                                                                       self._Popen = None                                                         self._pid = None           #子进程PID                                                       self._return_code = None   #执行命令返回值                                               self._cwd = None           #执行目录                                               self._start_time = None    #子进程开始执行的时间戳</code></pre><h3 id="调用命令的内部方法"><a href="#调用命令的内部方法" class="headerlink" title="调用命令的内部方法"></a>调用命令的内部方法</h3><p>这里定义了一个内部方法，用于使用subprocess调用系统命令，并做超时处理。</p><ol><li>subprocess接收命令格式为一个list，所以使用shlex.split()进行命令切分。此方法接收4个参数：命令，标准输出，标准错误和执行目录。</li><li>超时处理，在调用<code>subprocess.Popen()</code>方法后，先获取当前时间戳，然后循环判断，是否程序正常退出(<code>poll()</code>方法获取子进程状态)并且是在超时时间之内，这里用这个循环来代替<code>wait()</code>方法来阻塞进程，并判断超时。如果超过超时时间，方法继续执行，获取进程执行返回的状态(此时可能子进程并未执行完毕)，再次判断子进程是否退出，如在此处还未退出，执行<code>terminate()</code>方法，给子进程发送信号，退出子进程，等待1秒，再次判断进程是否退出，如还未退出证明进程未正常相应<code>terminate()</code>发出的信号，此时使用<code>kill()</code>方法，发出<code>SIGKILL</code>信号，强制退出子进程。</li><li>最终获取子进程退出的状态。</li></ol><p>代码如下:</p><pre><code>def _run(self):    #Run cmd.    #Split command string.    cmd = shlex.split(self._cmd)    self._Popen = subprocess.Popen(args=cmd,                                   stdout=self._stdout_fd,                                   stderr=self._stderr_fd,                                   cwd=self._cwd)    self._pid = self._Popen.pid    self._start_time = time.time()    while (self._Popen.poll() == None and            (time.time() - self._start_time) &lt; self._timeout):        time.sleep(1)    _r_code = self._Popen.poll()    # If child process has not exited yet, terminate it.    if self._Popen.poll() == None:        self._Popen.terminate()        _r_code = 254    # Wait for the child process to exit.    time.sleep(1)    # If child process has not been terminated yet, kill it.    if self._Popen.poll() == None:        self._Popen.kill()        _r_code = 255    self._return_code = _r_code</code></pre><h3 id="对外的方法"><a href="#对外的方法" class="headerlink" title="对外的方法"></a>对外的方法</h3><p>外部调用的方法<code>start()</code>，使用此方法进行执行命令的调用。接收命令，超时时间，标准输入，标准输出，标准错误，是否使用tty(是否将结果输出到终端)，是否使用时间戳(返回结果中打印开始的时间)。此方法主要是调用内部执行命令的方法(_run())，然后对输出进行格式化。</p><pre><code>def start(self,          cmd,          timeout=5*60*60,          stdin=None,          stdout=None,          stderr=None,          tty=False,          timestamp=False):    self._cmd = cmd    self._stdin = stdin    self._stdout = stdout    self._stderr = stderr    self._timeout = timeout    self._is_tty = tty    self._timestamp = timestamp    #Init output.    info = None    err = None    if self._timestamp:        start_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())        file_start = &quot;Start Time: &quot; + start_time + &quot;\n&quot;    else:        file_start = &quot;&quot;        file_end = &quot;&quot;    try:        #Init the file handle of output.        if self._is_tty:            self._stdout_fd = None            self._stderr_fd = None        elif (self._stdout is None or            self._stderr is None or            self._stdout == self._stderr):            self._stdout_fd = tempfile.TemporaryFile()            self._stderr_fd = tempfile.TemporaryFile()        else:            self._stdout_fd = self._create_handler(self._stdout)            self._stderr_fd = self._create_handler(self._stderr)            self._stdout_fd.write(file_start)            self._stdout_fd.flush()            self._stderr_fd.write(file_start)            self._stderr_fd.flush()        self._run()        if self._timestamp:            end_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())            file_end = &quot;End Time: &quot; + end_time + &quot;\n&quot;        #Write and Read output content.        if not self._is_tty:            self._stdout_fd.write(file_end)            self._stderr_fd.write(file_end)            self._stdout_fd.flush()            self._stderr_fd.flush()            self._stdout_fd.seek(0)            self._stderr_fd.seek(0)            info = file_start + self._stdout_fd.read() + file_end            err = file_start + self._stderr_fd.read() + file_end    finally:        #Close file handle.        if not self._is_tty:            self._stdout_fd.close()            self._stderr_fd.close()    return {&quot;code&quot;:self._return_code,            &quot;stdout&quot;:info,            &quot;stderr&quot;:err            }</code></pre><p>  这里输出分为3种类型：</p><ol><li>直接输出到终端，设置tty=True即可，就是直接打印到终端。</li><li>输出到临时文件中，如果tty=False，并且没有输入指定的log文件（stdout和stderr），某块会自动创建一个临时文件来记录日志。</li><li>输出到指定日志中，设置了输出日志，会将命令执行的标准输出和标准错误输出到指定日志文件中（实时输出）。</li></ol><p>*注意: 如果设置使用输出到tty，最终start()方法只会返回命令执行的状态码，不会返回执行结果（已经输出到终端），使用临时文件作为日志或指定输出日志文件，最终start()方法会最终将日志返回给调用的程序。</p><h3 id="对日志处理的方法"><a href="#对日志处理的方法" class="headerlink" title="对日志处理的方法"></a>对日志处理的方法</h3><p>创建日志文件，初始化日志句柄。</p><pre><code>#Create file handle.def _create_handler(self, filename):    if isinstance(filename, file):        return filename    elif isinstance(filename, basestring):        path = os.path.dirname(filename)        timestamp = time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime())        if not os.path.exists(path):            os.makedirs(path)        elif os.path.exists(filename) and not os.path.isfile(filename):            backup_name = filename + timestamp            os.rename(filename, backup_name)        fd = open(filename, &apos;a+b&apos;)        return fd    else:        raise &quot;The type of \&apos;filename\&apos; must be \&apos;file\&apos; or \&apos;basestring\&apos;&quot;</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>SubWork</code>使用方法如下:</p><pre><code>import SubWorkcmd = &quot;/bin/ls /tmp&quot;worker = SubWork()res = worker.start(cmd, 300， &quot;/tmp/stdout.log&quot;, &quot;/tmp/stderr.log&quot;)print res</code></pre><p>这里会执行<code>/bin/ls /tmp</code>命令，超时时间300秒，将执行的标准输出实时输出到<code>/tmp/stdout.log</code>中，将输出的标准错误实时输出到<code>/tmp/stderr.log</code> 中，最终<code>res</code>变量中会有命令执行的状态码和命令执行的输出结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频
      
    
    </summary>
    
      <category term="Python" scheme="http://kidnet.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidnet.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
