<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kidnet.github.io/"/>
  <updated>2017-12-05T10:09:01.187Z</updated>
  <id>http://kidnet.github.io/</id>
  
  <author>
    <name>Jason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker系列(四):Harbor(一)</title>
    <link href="http://kidnet.github.io/2017/11/29/docker-harbor/"/>
    <id>http://kidnet.github.io/2017/11/29/docker-harbor/</id>
    <published>2017-11-29T03:06:22.000Z</published>
    <updated>2017-12-05T10:09:01.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Registry只能通过API进行管理，然而第三方开发了一些开源的平台来作为私有镜像库管理(类似于github)，可以对用户、权限、镜像库及镜像进行管理，并且有图形化的界面，方便使用。</p><h2 id="开源管理平台"><a href="#开源管理平台" class="headerlink" title="开源管理平台"></a>开源管理平台</h2><p>开源的私有库的管理平台不是很多(可能是我没找到)，主要看到2个，一个是SUSE的<a href="http://port.us.org" target="_blank" rel="external">Portus</a>，另一个是VMWare的<a href="https://vmware.github.io/harbor" target="_blank" rel="external">Harbor</a>。这里只介绍Harbor的部署及应用。</p><h2 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h2><p>Harbor是用于存储和分发Docker镜像的企业级Registry服务器，具有以下功能和特性: </p><ul><li>基于角色的权限控制: 用户和docker镜像库通过”项目”关联在一起，一个用户在同一个命名空间下可以有不同的权限。</li><li>镜像复制: 多个Registry实例之间可以进行镜像复制，可以用于负载均衡，高可用及混合多用的场景。</li><li>用户图形化接口: 用户可以通过图形化界面更轻松的浏览和搜索docker仓库，管理项目和命名空间。</li><li>支持AD/LDAP： Harbor支持商业的AD/LDAP的用户认证及管理。</li><li>审计: 所有对于镜像库的操作都是可以被追踪的并可以被审计。</li><li>国际化: 已经支持英语、中文、德语、日语和俄语。</li><li>RESTful API: Harbor大部分的管理操作已经提供了RESTful API。</li><li>部署方便: 提供了在线和离线的安装方式。</li></ul><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><ul><li>在线安装包: 在线安装包会从Docker公共库下载Harbor的镜像，因此在线安装包会很小。</li><li>离线安装包: 如果主机无法连接到互联网，可以使用离线安装包，离线安装包包含了每一个镜像的构建，所以这个安装包会很大。</li></ul><p><a href="https://github.com/vmware/harbor/releases" target="_blank" rel="external">官方安装包下载地址</a></p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>Harbor是使用镜像通过Docker容器部署的，因此需要系统支持Docker。主机需要Python，Docker及Docker Compose。</p><ul><li>Python版本需要2.7版本或更高版本。</li><li>Dockery引擎需要1.10或更高版本。(<a href="https://kidnet.github.io/2017/09/19/docker-install/">Docker安装</a>)</li><li>Docker Compose需要1.6.0或更高版本。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装过程为以下几步:</p><ul><li>下载安装包；</li><li>配置<code>harbor.cfg</code>;</li><li>运行<code>install.sh</code>安装并运行Harbor;</li></ul><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h3><p>从官方发布地址下载安装包，选择在线或离线的安装包。使用<code>tar</code>命令解压缩这个包。(本文档都是使用离线包进行安装。)</p><p>在线包:</p><pre><code>$ tar -xzvf harbor-online-installer-&lt;version&gt;.tgz</code></pre><p>离线包:</p><pre><code>$ tar -xzvf harbor-offline-installer-&lt;version&gt;.tgz</code></pre><h3 id="2-配置Harbor"><a href="#2-配置Harbor" class="headerlink" title="2. 配置Harbor"></a>2. 配置Harbor</h3><p><code>harbor.cfg</code>中包含了配置项。</p><p>在<code>harbor.cfg</code>中有2部分配置项，必须配置和可选配置。</p><ul><li>必须配置: 这些配置是必须在配置文件中进行配置的。如果用户更新<code>harbor.cfg</code>中的这些配置将且运行<code>install.sh</code>脚本的时候会重新安装Harbor，这些配置将会立即生效。</li><li>可选配置: 这些配置是可选的，用户可以使用这些默认的配置，也可以在启动Harbor后通过Web UI进行配置。如果可选配置在<code>harbor.cfg</code>中更新了，这些配置只在Harbor第一次启动的时候生效。之后在<code>harbor.cfg</code>中更新这些配置就不会生效了。</li></ul><p><strong>注意</strong>: 如果选择通过UI来配置可选项，需要确认Harbor已经启动后，再去进行配置。在可选配置中，有一个特殊的配置项，<code>auth_mode</code>必须在注册用户或创建新用户之前配置成需要的认证模式。如果系统中已经存在用户(admin用户除外)，<code>auth_mode</code>是不能被修改的。</p><h4 id="必须配置项"><a href="#必须配置项" class="headerlink" title="必须配置项:"></a>必须配置项:</h4><ul><li><strong>hostname</strong>: 运行Harbor的服务器的hostname，用于访问UI和提供Registry服务。 这个配置可以是IP地址或者是域名，<code>10.0.100.2</code>或者<code>test-harbor.test.com</code>。不要使用<code>localhost</code>或者<code>127.0.0.1</code>，因为Registry服务需要被其它客户端访问。</li><li><strong>ui_url_protocol</strong>: (值可以是<strong>http</strong>或者<strong>https</strong>，默认为<strong>http</strong>)这个协议用于访问UI和token/notification服务。如果认证被启用，这个配置必须是<em>https</em>。设置https协议后面会有文档详细说明。</li><li><strong>db_passwd</strong>: MySQL数据库root的密码，用于<strong>db_auth</strong>。</li><li><strong>max_job_wokers</strong>: (默认值为3) 这个作业服务器启动复制进程的数量。 每个镜像的复制作业会有1个进程同步1个库的所有标签到远程目标。 增加这个数值可以启动多个进程同时进行复制作业。但是，因为每个进程会消耗一定的网络/CPU/IO资源，请根据主机硬件资源谨慎设置这个配置。</li><li><strong>customize_crt</strong>：(<strong>on</strong> 或者 <strong>off</strong>, 默认为<strong>on</strong>) 当这个配置项为 <strong>on</strong>时，安装脚本会创建用于生成/验证库的<code>token</code>的私钥和根证书。 当私钥和根证书是通过其它来源提供时(从第三方机构购买的证书)设置此配置项为 <strong>off</strong> 。</li><li><strong>ssl_cert</strong>: SSL证书(<code>cert</code>）的路径, 仅当协议设置为<code>https</code>时这个配置项会被应用。</li><li><strong>ssl_cert_key</strong>: SSL私钥(<code>key</code>)的路径, 仅当协议设置为<code>https</code>时这个配置项会被应用。</li><li><strong>secretkey_path</strong>: 在复制规则中用于加解密一个远程库的密码的私钥(<code>key</code>)的路径。</li><li><strong>log_rotate_count</strong>: 日志文件被轮转 <strong>log_rotate_count</strong> 次后被删除。 如果这个配置项是<code>0</code>，旧的日志不会被轮转，而是直接删除。 </li><li><strong>log_rotate_size</strong>: 只有当日志文件增长到大于 <strong>log_rotate_size</strong> (字节)时，日志文件才会被轮转。如果这个值后面跟随<code>k</code>，这个值被认为是<code>KB</code>; 如果是<code>M</code>， 就被认为是<code>MB</code>;如果是<code>G</code>，就被认为是<code>GB</code>。所以，这个值是<code>100</code>、 <code>100K</code>、 <code>100M</code>和<code>100G</code>都是合法的。</li></ul><h4 id="可选配置项"><a href="#可选配置项" class="headerlink" title="可选配置项:"></a>可选配置项:</h4><ul><li><strong>Email settings</strong>: 这个配置项用于给用户发送密码重置邮件。注意，SSL连接默认是不启用的，如果你的SMTP服务器需要SSL，并且不支持<code>STARTTLS</code>，需要通过设置 <strong>email_ssl = true</strong> 来支持SSL。如果email服务器使用了一个自签名证书或者未授权的证书，需要配置 <strong>email_insecure = true</strong> 。 对于”email_identity”的详细描述请查看<a href="https://tools.ietf.org/rfc/rfc2595.txt" target="_blank" rel="external">rfc2595</a>。</li></ul><p>例:</p><pre><code>email_server = smtp.mydomain.comemail_server_port = 25email_identity =email_username = sample_admin@mydomain.comemail_password = abcemail_from = admin sample_admin@mydomain.comemail_ssl = falseemail_insecure = falseemail_server = smtp.mydomain.comemail_server_port = 25email_identity =email_username = sample_admin@mydomain.comemail_password = abcemail_from = admin sample_admin@mydomain.comemail_ssl = falseemail_insecure = false</code></pre><ul><li><strong>harbor_admin_password</strong> : 管理员初始密码。 这个密码仅仅是第一次安装并启动Harbor时有效。 之后再次启动时这个配将会被忽略，管理员密码在UI中可以被修改。注意， 默认的用户名/密码是 <strong>admin/Harbor12345</strong>。</li><li><strong>auth_mode</strong>: 认证模式。默认为 <strong>db_auth</strong> , 认证信息存储到数据库中。对于LDAP认证， 需要设置 <strong>ldap_auth</strong> 。</li></ul><p><strong>注意</strong>: 当升级已有的Harbor实例的时候，在升级启动新版本的Harbor之前确认 <strong>auth_mode</strong> 配置与<code>harbor.cfg</code>中的配置相同。否者，已有用户无法在升级后登录系统。</p><ul><li><strong>ldap_url</strong>: LDAP服务的URL(如: <code>ldaps://ldap.yourdomain.com</code>)。 仅当 <strong>auth_mode</strong> 选项被设置为ldap_auth时，此配置项生效。</li><li><strong>ldap_searchdn</strong>: 一个有搜索LDAP/AD服务器权限的用户的DN(如: `uid=admin,ou=people,dc=yourdomain,dc=com)。</li><li><strong>ldap_search_pwd</strong>: <strong>ldap_searchdn</strong>配置指定的用户的密码。</li><li><strong>ldap_basedn</strong>: 查找用户的基础DN，如: <code>ou=people,dc=yourdomain,dc=com</code>。仅当 <strong>auth_mode</strong> 选项被设置为ldap_auth时，此配置项生效。</li><li><strong>ldap_filter</strong>: 用于搜索用户的查询过滤器(如: <code>objectClass=person</code>)。</li><li><strong>ldap_uid</strong>: 这个属性用于在LDAP检索过程中去匹配用户，可以是uid, cn, email或者其它的属性。</li><li><strong>ldap_scope</strong>: 搜索用户的范围，值及含义为: 1-LDAP_SCOPE_BASE, 2-LDAP_SCOPE_NOLEVEL, 3-LDAP_SCOPE_SUBTREE。默认为3。</li><li><strong>self_registration</strong>: (<strong>on</strong> 或 <strong>off</strong>。默认为 <strong>on</strong>) 是否允许用户自己进行注册。当不允许用户自助注册时， 新用户只能由管理员来创建， 在Harbor中只有一个管理员可以创建新用户。 _注意:当 <strong>atuh_mode</strong>被设置为 <strong>ldap_auth</strong> 时，用户自助注册的功能会自动被关闭，这个配置项将被忽略。_</li><li><strong>token_expiration</strong>: token服务创建的token超时的时间(分钟), 默认为30分钟。</li><li><strong>project_creation_restriction</strong>: 这个配置项控制用户是否有权限去创建项目。默认每个人都可以创建项目，设置为”adminonly”为只有管理员可以创建项目。</li></ul><h4 id="配置存储-可选项"><a href="#配置存储-可选项" class="headerlink" title="配置存储(可选项)"></a>配置存储(可选项)</h4><p>默认情况下，Harbor会将镜像存储到本地文件系统。 但在某些环境中，你可能考虑使用其他的后端存储来代替本地文件系统，比如: S3, OpenStack Swift, Ceph等。 你可以通过更新配置文件<code>common/templates/registry/config.yml</code>中<code>storage</code>这个配置段来更改后端存储。例如，你使用OpenStack Swift作为你后端的存储，这个配置段的配置如下：</p><pre><code>storage:  swift:    username: admin    password: ADMIN_PASS    authurl: http://keystone_addr:35357/v3/auth    tenant: admin    domain: default    region: regionOne    container: docker_images</code></pre><p><em>注意: 对于镜像库的后端存储的详细信息请参见: <a href="https://docs.docker.com/registry/configuration/" target="_blank" rel="external">Docker Registry配置说明</a></em></p><h4 id="完成安装并启动Harbor"><a href="#完成安装并启动Harbor" class="headerlink" title="完成安装并启动Harbor"></a>完成安装并启动Harbor</h4><p>完成 <strong>harbor.cfg</strong> 与存储配置(可选配置项)的配置， 使用<code>install.sh</code>脚本完成安装并启动。注意，对于在线安装可能要花费一些时间从Docker hub下载镜像。 Harbor需要使用Docker Compose启动，请在运行<code>install.sh</code>脚本前安装，请参考: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="external">Docker Compose安装说明</a>。</p><pre><code>$ ./install.sh[Step 0]: checking installation environment ...Note: docker version: 17.06.2Note: docker-compose version: 1.17.0[Step 1]: loading Harbor images ...c5c1f3d43c8b: Loading layer [==================================================&gt;]  135.4MB/135.4MB62f93b2c84e5: Loading layer [==================================================&gt;]  72.99MB/72.99MB72842e5a36df: Loading layer [==================================================&gt;]  3.584kB/3.584kB478e65478cba: Loading layer [==================================================&gt;]  3.072kB/3.072kB59b789abf78f: Loading layer [==================================================&gt;]  4.096kB/4.096kB004c30d5e900: Loading layer [==================================================&gt;]  3.584kB/3.584kB30c3b4c78f76: Loading layer [==================================================&gt;]  10.24kB/10.24kBLoaded image: vmware/harbor-log:v1.3.0-rc1454c81edbd3b: Loading layer [==================================================&gt;]  135.2MB/135.2MBbab81b4d4981: Loading layer [==================================================&gt;]  463.7MB/463.7MB5735a75e540c: Loading layer [==================================================&gt;]  9.216kB/9.216kB44394f38b0c9: Loading layer [==================================================&gt;]  9.216kB/9.216kB13775ef23512: Loading layer [==================================================&gt;]   7.68kB/7.68kB9d8d34eb8c97: Loading layer [==================================================&gt;]  1.536kB/1.536kB94af0237e276: Loading layer [==================================================&gt;]  9.216kB/9.216kBf1a95e05d345: Loading layer [==================================================&gt;]   2.56kB/2.56kB3ca7ba769253: Loading layer [==================================================&gt;]  3.072kB/3.072kBLoaded image: vmware/harbor-db:v1.3.0-rc1e4813ce65d72: Loading layer [==================================================&gt;]  23.21MB/23.21MB3491428eff72: Loading layer [==================================================&gt;]  18.33MB/18.33MB22355de6ca70: Loading layer [==================================================&gt;]  18.33MB/18.33MBLoaded image: vmware/harbor-jobservice:v1.3.0-rc111a7546bc950: Loading layer [==================================================&gt;]  90.74MB/90.74MBcd2cb03dfead: Loading layer [==================================================&gt;]  12.16MB/12.16MBfdcb5fa28b07: Loading layer [==================================================&gt;]   17.3MB/17.3MBeef410f82bbe: Loading layer [==================================================&gt;]  15.87kB/15.87kB938e5e2a4bad: Loading layer [==================================================&gt;]  3.072kB/3.072kB558c91f2870a: Loading layer [==================================================&gt;]  3.072kB/3.072kBLoaded image: vmware/notary-photon:server-0.5.10e1b40dbb3d2: Loading layer [==================================================&gt;]  10.95MB/10.95MB58127bdab8e5: Loading layer [==================================================&gt;]   17.3MB/17.3MB2e3e9ac4492d: Loading layer [==================================================&gt;]  15.87kB/15.87kBbd6c57401b0f: Loading layer [==================================================&gt;]  3.072kB/3.072kB08a6f4315b6a: Loading layer [==================================================&gt;]  3.072kB/3.072kBLoaded image: vmware/notary-photon:signer-0.5.1e99db1275091: Loading layer [==================================================&gt;]  395.4MB/395.4MB051e4ee23882: Loading layer [==================================================&gt;]  9.216kB/9.216kB6cca4437b6f6: Loading layer [==================================================&gt;]  9.216kB/9.216kB1d48fc08c8bc: Loading layer [==================================================&gt;]   7.68kB/7.68kB0419724fd942: Loading layer [==================================================&gt;]  1.536kB/1.536kB92ce53616a73: Loading layer [==================================================&gt;]  599.2MB/599.2MB2004244b53a2: Loading layer [==================================================&gt;]  74.24kB/74.24kBLoaded image: vmware/harbor-db-migrator:1.3c116153f561a: Loading layer [==================================================&gt;]  23.21MB/23.21MBd82c9a7f1bce: Loading layer [==================================================&gt;]  7.071MB/7.071MB75e273c18f2a: Loading layer [==================================================&gt;]  7.071MB/7.071MBLoaded image: vmware/harbor-adminserver:v1.3.0-rc1Loaded image: vmware/photon:1.0Loaded image: vmware/mariadb-photon:10.2.10eecd294cdc4d: Loading layer [==================================================&gt;]  23.21MB/23.21MB848ebb86cbdd: Loading layer [==================================================&gt;]  22.71MB/22.71MB75c57475cadf: Loading layer [==================================================&gt;]  7.168kB/7.168kB3dd4619c78ff: Loading layer [==================================================&gt;]  5.381MB/5.381MB757114e3e191: Loading layer [==================================================&gt;]   22.7MB/22.7MBLoaded image: vmware/harbor-ui:v1.3.0-rc1cd0c2ef5af40: Loading layer [==================================================&gt;]  72.46MB/72.46MBLoaded image: vmware/nginx-photon:1.11.137280dd18d4e6: Loading layer [==================================================&gt;]  90.74MB/90.74MB29de07437cda: Loading layer [==================================================&gt;]  2.048kB/2.048kBbf435791a668: Loading layer [==================================================&gt;]  2.048kB/2.048kBea6923ed1a8e: Loading layer [==================================================&gt;]  2.048kB/2.048kBb39969acb12a: Loading layer [==================================================&gt;]  3.072kB/3.072kBa07efc1d5b07: Loading layer [==================================================&gt;]   22.8MB/22.8MBLoaded image: vmware/registry:2.6.2-photonfe75aea3eba7: Loading layer [==================================================&gt;]  221.3MB/221.3MB 50b4cd38d514: Loading layer [==================================================&gt;]  10.75MB/10.75MB5ffc09e42afb: Loading layer [==================================================&gt;]  2.048kB/2.048kBee0b77dfb8f1: Loading layer [==================================================&gt;]  48.13kB/48.13kBf1f5fc6c106a: Loading layer [==================================================&gt;]   10.8MB/10.8MBLoaded image: vmware/clair:v2.0.1-photon418e636d0b27: Loading layer [==================================================&gt;]  161.5MB/161.5MBfb804e98cb47: Loading layer [==================================================&gt;]  6.656kB/6.656kBd961645df25c: Loading layer [==================================================&gt;]  6.656kB/6.656kBLoaded image: vmware/postgresql:9.6.5-photon[Step 2]: preparing environment ...Generated and saved secret to file: /data/secretkeyGenerated configuration file: ./common/config/nginx/nginx.confGenerated configuration file: ./common/config/adminserver/envGenerated configuration file: ./common/config/ui/envGenerated configuration file: ./common/config/registry/config.ymlGenerated configuration file: ./common/config/db/envGenerated configuration file: ./common/config/jobservice/envGenerated configuration file: ./common/config/log/logrotate.conf Generated configuration file: ./common/config/jobservice/app.confGenerated configuration file: ./common/config/ui/app.confGenerated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crtThe configuration files are ready, please use docker-compose to start the service.[Step 3]: checking existing instance of Harbor ...[Step 4]: starting Harbor ...Creating network &quot;harbor_harbor&quot; with the default driverCreating harbor-log ... Creating harbor-log ... doneCreating harbor-adminserver ... Creating registry ... Creating harbor-db ... Creating harbor-adminserverCreating harbor-dbCreating registry ... doneCreating harbor-db ... doneCreating harbor-ui ... doneCreating harbor-jobservice ... Creating nginx ... Creating harbor-jobserviceCreating nginx ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://reg.youerdomain.com. For more details, please visit https://github.com/vmware/harbor .</code></pre><p>如果所有组件都已经开始工作，你可以启动浏览器访问管理页面”<a href="http://reg.yourdomain.com" target="_blank" rel="external">http://reg.yourdomain.com</a>“ 。 注意，默认的管理员用户名/密码是admin/Harbor12345。</p><p>登录到管理页面并创建一个新的工程，如<code>myproject</code>。之后可用用docker命令登录并推送image(默认的Registry的服务监听在80端口)。</p><p>具体登录及推送过程和使用Docker Registry一样，不再具体演示了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Registry只能通过API进行管理，然而第三方开发了一些开源的平台来作为私有镜像库管理(类似于github)，可以对用户、权限、镜像库及
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(五):私有仓库(二)</title>
    <link href="http://kidnet.github.io/2017/11/28/docker-registry-management/"/>
    <id>http://kidnet.github.io/2017/11/28/docker-registry-management/</id>
    <published>2017-11-28T07:31:02.000Z</published>
    <updated>2017-11-28T09:10:46.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一篇讲了使用Registry搭建私有的镜像库，对Registry的管理暂时只能是有API来进行，本篇来介绍使用API管理Registry镜像库。</p><h2 id="Registry镜像的管理"><a href="#Registry镜像的管理" class="headerlink" title="Registry镜像的管理"></a>Registry镜像的管理</h2><h3 id="1-镜像查询"><a href="#1-镜像查询" class="headerlink" title="1. 镜像查询"></a>1. 镜像查询</h3><p>前面已经说到过Registry v2需要通过API进行查询, 对于需要证书及鉴权的Registry通过以下方式查询:</p><pre><code>$ curl --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/_catalog  {&quot;repositories&quot;:[&quot;registry&quot;]}</code></pre><p>可以查看每个镜像的详细信息：</p><pre><code>$ curl -i -X GET -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/registry/manifests/2HTTP/1.1 200 OKContent-Length: 1364Content-Type: application/vnd.docker.distribution.manifest.v2+jsonDocker-Content-Digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6Docker-Distribution-Api-Version: registry/2.0Etag: &quot;sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6&quot;Date: Thu, 09 Nov 2017 22:09:42 GMT{   &quot;schemaVersion&quot;: 2,   &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,   &quot;config&quot;: {      &quot;mediaType&quot;: &quot;application/vnd.docker.container.image.v1+json&quot;,      &quot;size&quot;: 3165,      &quot;digest&quot;: &quot;sha256:a07e3f32a779aa924fd47f6797d4d5c93061c50c0eb97d464f08365a3a30200b&quot;   },   &quot;layers&quot;: [      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 2385012,         &quot;digest&quot;: &quot;sha256:49388a8c9c86a6f56d228954eede699c64fce6c671a989e3e21c391859694645&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 2027027,         &quot;digest&quot;: &quot;sha256:e4d43608dd22de7d12f17ae419ce146094e047e1a739d644e3fcb647f9379bdb&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 6265374,         &quot;digest&quot;: &quot;sha256:3a41740f900cbba03b223c025f03632db1284d85a696677bca8d6375cdf6040b&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 371,         &quot;digest&quot;: &quot;sha256:e16ef4b766841014d6a902f034f0f67698bcbebc1b4c36ff3574d3730e79e2ee&quot;      },      {         &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,         &quot;size&quot;: 213,         &quot;digest&quot;: &quot;sha256:65f212f7c77805418cb85461d93a522c1bf4eebac73009ccd23ac2159ac33dad&quot;      }   ]}</code></pre><p>对于2.3或之前的版本，要使用:指定<code>Accept: application/vnd.docker.distribution.manifest.v2+json</code>头。</p><h3 id="2-镜像删除"><a href="#2-镜像删除" class="headerlink" title="2. 镜像删除"></a>2. 镜像删除</h3><p>对于Registry库中镜像的删除，通过API只能删除镜像的信息，具体的镜像的Layer实际还存在。</p><pre><code>$ curl -i -X DELETE -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \   https://10.0.2.15:5000/v2/registry/manifests/sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6   HTTP/1.1 202 AcceptedDocker-Distribution-Api-Version: registry/2.0Date: Fri, 10 Nov 2017 03:46:09 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8</code></pre><p>这时查看镜像信息显示为未知镜像:</p><pre><code>$ curl -i -X GET -H &quot;Accept: application/vnd.docker.distribution.manifest.v2+json&quot; \  --cacert /etc/docker/certs.d/10.0.2.15\:5000/ca.crt \  --basic --user admin:admin123 \  https://10.0.2.15:5000/v2/registry/manifests/2                                                                            HTTP/1.1 404 Not FoundContent-Type: application/json; charset=utf-8Docker-Distribution-Api-Version: registry/2.0Date: Fri, 10 Nov 2017 03:47:51 GMTContent-Length: 91{&quot;errors&quot;:[{&quot;code&quot;:&quot;MANIFEST_UNKNOWN&quot;,&quot;message&quot;:&quot;manifest unknown&quot;,&quot;detail&quot;:{&quot;Tag&quot;:&quot;2&quot;}}]}</code></pre><p>但再次上传相同镜像的时候，所有Layer提示已经存在:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Layer already exists a2717186d7dd: Layer already exists 656c7684d0bd: Layer already exists 7683d4fcdf4e: Layer already exists ef763da74d91: Layer already exists 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>Docker官方文档中描述的API删除镜像其实是软删除，只是解除信息关联，并没有在真正删除镜像，建议调用API删除成功后到镜像存储目录直接删除该镜像所有信息。</p><p>调用删除API之前，在<code>config.yml</code>中需要增加允许删除的配置:</p><pre><code>$ vim /etc/docker-distribution/registry/config.yml... ...storage:    ... ...    delete:        enabled: true</code></pre><p>增加配置后重启服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;上一篇讲了使用Registry搭建私有的镜像库，对Registry的管理暂时只能是有API来进行，本篇来介绍使用API管理Registry镜
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(四):私有仓库(一)</title>
    <link href="http://kidnet.github.io/2017/11/23/docker-registry/"/>
    <id>http://kidnet.github.io/2017/11/23/docker-registry/</id>
    <published>2017-11-23T07:30:45.000Z</published>
    <updated>2017-11-28T06:38:09.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些私有镜像不方便传输到公共镜像库中，或者内网环境，可以搭建一个私有Registry作为镜像仓库。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>Registry是用于存储和交付Docker镜像的系统。 和本地镜像管理中存储的镜像一样，可以使用不同的标签版本。</p><h3 id="1-使用docker-distribution启动Registry"><a href="#1-使用docker-distribution启动Registry" class="headerlink" title="1. 使用docker-distribution启动Registry"></a>1. 使用<code>docker-distribution</code>启动Registry</h3><p>可以直接安装docker组件distribution来启动Registry。</p><ul><li>安装</li></ul><p>对于CentOS系统，直接使用<code>yum</code>安装即可:</p><pre><code>$ yum install docker-distribution</code></pre><ul><li>启动</li></ul><p>通过<code>systemctl</code>启动Registry服务:</p><pre><code>$ systemctl start docker-distribution</code></pre><ul><li>配置说明</li></ul><p>安装好后的Registry的配置文件可以正常启动应用，修改<code>/etc/docker-distrbution/registry/config.yml</code>文件来修改默认配置:</p><pre><code>version: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registry  #镜像文件存储的目录http:    addr: :5000 #对外服务的端口</code></pre><p>后面会继续说明一些用到的配置。</p><h3 id="2-使用已有的镜像启动Registry"><a href="#2-使用已有的镜像启动Registry" class="headerlink" title="2. 使用已有的镜像启动Registry"></a>2. 使用已有的镜像启动Registry</h3><p>官方文档都是通过下载已经配置好的Registry的镜像，通过容器启动此镜像，来提供Registry的服务。</p><ul><li>下载官方镜像</li></ul><p>直接拉取官方镜像:</p><pre><code>$ docker pull registry:22: Pulling from library/registry49388a8c9c86: Pull complete e4d43608dd22: Pull complete 3a41740f900c: Pull complete e16ef4b76684: Pull complete 65f212f7c778: Pull complete Digest: sha256:d837de65fd9bdb81d74055f1dc9cc9154ad5d8d5328f42f57f273000c402c76dStatus: Downloaded newer image for registry:2</code></pre><ul><li>通过镜像启动Registry服务</li></ul><p>通过官方镜像启动容器:</p><pre><code>$ docker run -d -p 5000:5000 --name registry registry:24199973ca1c7511fd608da534570375023fa69715948b13f4d9b3a3c277d3536$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES4199973ca1c7        registry:2          &quot;/entrypoint.sh /e...&quot;   5 seconds ago       Up 4 seconds        0.0.0.0:5000-&gt;5000/tcp   registry</code></pre><p>其实启动容器时如果没有对应的镜像，会自动下载:</p><pre><code>$ docker run -d -p 5000:5000 --name registry registry:2Unable to find image &apos;registry:2&apos; locally #提示在本地镜像库中没有找到镜像2: Pulling from library/registry          #开始从公共镜像库下载镜像49388a8c9c86: Pull complete e4d43608dd22: Pull complete 3a41740f900c: Pull complete e16ef4b76684: Pull complete 65f212f7c778: Pull complete Digest: sha256:d837de65fd9bdb81d74055f1dc9cc9154ad5d8d5328f42f57f273000c402c76dStatus: Downloaded newer image for registry:2  #镜像下载完成6dabd62f77e8e2079bed029599aea96b65a551bcdb517a4adb24630828dea761 #启动容器$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEregistry            2                   a07e3f32a779        5 days ago          33.3MB$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES6dabd62f77e8        registry:2          &quot;/entrypoint.sh /e...&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:5000-&gt;5000/tcp   registry</code></pre><p>使用容器启动Registry时注意将存储镜像的目录挂载到本地硬盘，如果存储镜像在容器中，容器销毁时，所有镜像也一起销毁:</p><pre><code>$ docker run -d -p 5000:5000 --name registry -v /mnt/registry:/var/lib/registry registry:2</code></pre><h3 id="3-访问无验证的Registry"><a href="#3-访问无验证的Registry" class="headerlink" title="3. 访问无验证的Registry"></a>3. 访问无验证的Registry</h3><p>默认的docker client访问无认证的Registry可能会出现错误：</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: http: server gave HTTP response to HTTPS client</code></pre><p>docker client客户端默认需要访问<code>https</code>的地址，需要增加配置，重启docker:</p><pre><code>$ echo &quot;{\&quot;insecure-registries\&quot;:[\&quot;10.0.2.15:5000\&quot;]}&quot; &gt;&gt; /etc/docker/daemon.json$ systemctl restart docker</code></pre><p>重启后重新推送镜像: </p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Pushed a2717186d7dd: Pushed 656c7684d0bd: Pushed 7683d4fcdf4e: Pushed ef763da74d91: Pushed 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>如果是通过二进制程序启动的docker，直接在启动时增加参数即可:</p><pre><code>$ dockerd --insecure-registry 10.0.2.15:5000 &amp; #如已启动docker，请先停止已启动的进程</code></pre><h3 id="4-查看私有库中的镜像"><a href="#4-查看私有库中的镜像" class="headerlink" title="4. 查看私有库中的镜像"></a>4. 查看私有库中的镜像</h3><p>Registry没有图形界面，只能通过命令访问接口:</p><pre><code>$ curl http://10.0.2.15/v2/_catalog{&quot;repositories&quot;:[&quot;registry&quot;]}</code></pre><h3 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h3><p>以上2种配置启动Registry的方法，对比来说第一种方法(直接安装<code>docker-distribution</code>包)更为方便简洁，后期也较好维护(官网只有第二种方法，根据情况选择适合自己的方法来启动Registry)。</p><h2 id="安全的Registry"><a href="#安全的Registry" class="headerlink" title="安全的Registry"></a>安全的Registry</h2><p>Docker官方是推荐采用带有认证的Registry，传输采用tls。</p><h3 id="1-制作自签署证书"><a href="#1-制作自签署证书" class="headerlink" title="1. 制作自签署证书"></a>1. 制作自签署证书</h3><p>制作证书前需要在<code>openssl.cnf</code>配置中加入证书绑定的域名(或主机名或IP)。否则推送镜像时会差生以下错误:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: x509: cannot validate certificate for 10.0.2.15 because it doesn&apos;t contain any IP SANs</code></pre><p>修改配置文件，加入IP:</p><pre><code>$ cp /etc/pki/tls/openssl.cnf /tmp/$ vim /tmp/openssl.cnf......[v3_ca]subjectAltName = IP: 10.0.2.15</code></pre><p>修改后保存退出即可。继续使用<code>openssl</code>来制作自签署的证书，注意需要指定刚才修改的<code>openssl.cnf</code>配置文件:</p><pre><code>$ mkdir /etc/docker-distribution/registry/certs$ cd /etc/docker-distribution/registry/certs$ openssl req -newkey rsa:2048 -nodes -sha256 -keyout domain.key -x509 -days 365 -out domain.crt -config /tmp/openssl.cnfGenerating a 2048 bit RSA private key.............+++...............................+++writing new private key to &apos;domain.key&apos;-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:BJLocality Name (eg, city) [Default City]:BJOrganization Name (eg, company) [Default Company Ltd]:ZLOrganizational Unit Name (eg, section) []:ZLCommon Name (eg, your name or your server&apos;s hostname) []:registryEmail Address []:$ lsdomain.crt  domain.key</code></pre><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>修改Registry的配置文件，添加<code>tls</code>证书:</p><pre><code>$ vim /etc/docker-distribution/registry/config.ymlversion: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registryhttp:    addr: :5000    #增加以下tls的配置    tls:        certificate: /etc/docker-distribution/registry/certs/domain.crt        key: /etc/docker-distribution/registry/certs/domain.key</code></pre><p>重启Registry服务:</p><pre><code>$ systemctl restart docker-distribution</code></pre><h3 id="3-客户端证书配置"><a href="#3-客户端证书配置" class="headerlink" title="3. 客户端证书配置"></a>3. 客户端证书配置</h3><p>Registry服务配置好后，需要将证书配置到客户端，否则会产生以下错误：</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]Get https://10.0.2.15:5000/v2/: x509: cannot validate certificate for 10.0.2.15 because it doesn&apos;t contain any IP SANs</code></pre><p>将证书配置到客户端，并重启客户端:</p><pre><code>$ mkdir -p /etc/docker/certs.d/10.0.2.15:5000# 注意，本文档测试时客户端与私有库是同一台服务器，以下这个证书应该是拷贝到真实的客户端服务器中。$ cp /etc/docker-distribution/registry/certs/domain.crt /etc/docker/certs.d/10.0.2.15\:5000/ca.crt$ systemctl restart docker</code></pre><p>测试是否正常访问私有镜像库:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Pushed a2717186d7dd: Pushed 656c7684d0bd: Pushed 7683d4fcdf4e: Pushed ef763da74d91: Pushed 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><h2 id="Registry鉴权管理"><a href="#Registry鉴权管理" class="headerlink" title="Registry鉴权管理"></a>Registry鉴权管理</h2><p>Registry提供了基础的鉴权方式，可以像公有镜像库一样先登录，再提交镜像。</p><h3 id="1-生成鉴权密码文件"><a href="#1-生成鉴权密码文件" class="headerlink" title="1. 生成鉴权密码文件"></a>1. 生成鉴权密码文件</h3><p>在Registry服务器上，增加一个<code>admin</code>用户，密码为<code>admin123</code>:</p><pre><code>$ mkdir /etc/docker-distribution/registry/auth$ docker run --entrypoint htpasswd registry:2 -Bbn admin admin123 &gt; /etc/docker-distribution/registry/auth/htpasswd</code></pre><h3 id="2-修改配置并重启服务"><a href="#2-修改配置并重启服务" class="headerlink" title="2. 修改配置并重启服务"></a>2. 修改配置并重启服务</h3><p>增加对应配置:</p><pre><code>$ vim /etc/docker-distribution/registry/config.ymlversion: 0.1log:  fields:    service: registrystorage:    cache:        layerinfo: inmemory    filesystem:        rootdirectory: /var/lib/registryhttp:    addr: :5000    tls:        certificate: /etc/docker-distribution/registry/certs/domain.crt        key: /etc/docker-distribution/registry/certs/domain.key#增加以下配置:    auth:    htpasswd:        realm: basic-realm        path: /etc/docker-distribution/registry/auth/htpasswd</code></pre><p>重启服务:</p><pre><code>$ systemctl restart docker-distribution</code></pre><p>测试推送镜像:</p><pre><code>$ docker push 10.0.2.15:5000/registry:2                                                                                 The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Preparing a2717186d7dd: Preparing 656c7684d0bd: Preparing 7683d4fcdf4e: Preparing ef763da74d91: Preparing no basic auth credentials</code></pre><p>推送失败，尝试登录后再次推送:</p><pre><code>$ docker login 10.0.2.15:5000Username: adminPassword: Login Succeeded$ docker push 10.0.2.15:5000/registry:2The push refers to a repository [10.0.2.15:5000/registry]3c133a51bc00: Layer already exists a2717186d7dd: Layer already exists 656c7684d0bd: Layer already exists 7683d4fcdf4e: Layer already exists ef763da74d91: Layer already exists 2: digest: sha256:435db1be85c6c10b2f506516aa14d8c485c1f1bd5f4a941a637808b085f294b6 size: 1364</code></pre><p>成功登录后，推送镜像成功(因之前已推送过此镜像，所以提示镜像已存在)。</p><h2 id="使用容器启动的Registry的安全和鉴权配置"><a href="#使用容器启动的Registry的安全和鉴权配置" class="headerlink" title="使用容器启动的Registry的安全和鉴权配置"></a>使用容器启动的Registry的安全和鉴权配置</h2><p>使用容器启动的Registry可以通过多种方法进行配置：</p><ul><li>使用Dockerfile将修改好的配置文件、证书及密码文件打入启动镜像。</li></ul><p>如Dockerfile加入下列几行后重新制作镜像:    </p><pre><code>COPY config.yml /etc/docker/registry/config.ymlCOPY domain.crt /etc/docker/registry/domain.crtCOPY domain.key /etc/docker/registry/domain.keyCOPY htpasswd /etc/docker/registry/htpasswd</code></pre><ul><li>将修改好的配置文件、证书及密码文件的目录挂载到镜像对应目录。</li></ul><p>启动镜像时将配置目录重新挂载:</p><pre><code>$ docker run -d -p 5000:5000 --name registry \  -v /mnt/registry:/var/lib/registry \  -v /config:/etc/docker/registry \  registry:2</code></pre><ul><li>启动容器时使用特定环境变量指定修改。</li></ul><p>启动容器是通过环境变量也可以修改Registry的配置: </p><pre><code>$ docker run -d -p 5000:5000 --restart=always --name registry \-v `pwd`/auth:/auth \-e &quot;REGISTRY_AUTH=htpasswd&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \-v `pwd`/data:/var/lib/registry \-v `pwd`/certs:/certs \-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \-e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \registry:2</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;有些私有镜像不方便传输到公共镜像库中，或者内网环境，可以搭建一个私有Registry作为镜像仓库。&lt;/p&gt;
&lt;h2 id=&quot;Docker-R
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(三):容器管理</title>
    <link href="http://kidnet.github.io/2017/11/22/docker-container-management/"/>
    <id>http://kidnet.github.io/2017/11/22/docker-container-management/</id>
    <published>2017-11-22T02:59:11.000Z</published>
    <updated>2017-11-28T06:06:53.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前已经介绍了镜像管理，有了镜像，就可以使用镜像来启动容器(应用环境)。</p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>Docker容器基于已有的镜像启动，下面介绍对于容器的管理。</p><h3 id="1-容器启动"><a href="#1-容器启动" class="headerlink" title="1. 容器启动"></a>1. 容器启动</h3><p>选择好镜像后就可以启动容器，启动容器时可以选择多种参数，也可以将需要的参数(部分)定义到Dockerfile，直接打入镜像(但启动时使用的参数会覆盖镜像中已定义好的参数。)。</p><ul><li>使用参数启动容器</li></ul><p>使用<code>docker run [Options] image_name[:image_tag] [CMD]</code>基于选定镜像启动容器: </p><pre><code>$ docker images #Display imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB$ docker run -d centos-sshd /sbin/init #Start containerc7dc163219834374a02e4ee7c91da202a12c847dc3e51a741762af12c7fca919</code></pre><p>这样就使用<code>centos-sshd</code>镜像启动了一个容器。</p><ul><li>常用参数说明</li></ul><p>以下是启动容器时经常使用的一些参数:</p><pre><code>-p 端口映射，&lt;local_ip&gt;:&lt;local_port&gt;:&lt;container_port&gt;-v 挂载本地目录, &lt;local_path&gt;:&lt;container_path&gt;-d 以分离模式(detached mode)启动（简单理解为后台运行）-t 分配一个伪终端(pseudo-tty)-i 打开STDIN(没用-a指定的话)-e 在container中增加一个环境变量(ENV)--privileged 允许container访问所有device(例如 cgruop)--rm 退出容器时自动删除(销毁)容器--name 指定容器的名称(如不指定，系统会随机分配名称)[CMD] 启动时运行的命令，如果在启动容器是使用CMD，在创建镜像时Dockerfile中的CMD会被覆盖，另外，注意，这个CMD必须是一直运行的一个命令，不然命令结束，container会自动退出</code></pre><ul><li>Dockerfile</li></ul><p>使用Dockerfile将部分启动参数打入镜像:</p><pre><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] #使Container监听指定端口。VOLUME &lt;local_path&gt; #将本地目录映射到容器中(不等同于-v参数)。CMD [&quot;CMD1&quot;, &quot;CMD2&quot;, ...] #启动容器时运行的命令。ENV &lt;key&gt; &lt;value&gt; (or ENV &lt;key&gt;=&lt;value&gt; ...) #指定Container启动后的环境变量。</code></pre><h3 id="2-查看容器状态"><a href="#2-查看容器状态" class="headerlink" title="2. 查看容器状态"></a>2. 查看容器状态</h3><p>启动容器后可以查看所有容器的状态，通过<code>docker ps [-a]</code>:</p><pre><code>$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 5 hours                              nervous_poitras</code></pre><p>可以看到正在运行中的容器，之前启动容器时没有指定名字，由系统分配了一个名字。 <code>-a</code>参数可以看到所有容器(包括已经停止的容器)：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 5 hours                                     nervous_poitrasdb8415d50a86        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 hours ago                       gallant_kilby</code></pre><p>可以看到第二个容器是已经停止的容器。</p><h3 id="3-停止运行的容器"><a href="#3-停止运行的容器" class="headerlink" title="3. 停止运行的容器"></a>3. 停止运行的容器</h3><p>使用<code>docker stop &lt;container_id&gt;</code>来停止正在运行的容器:</p><pre><code>$ docker stop c7dc16321983c7dc16321983$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre><p>使用<code>docker ps</code>可以看到没有在运行的容器了，再使用<code>docker ps -a</code>来看看所有容器：</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 seconds ago                       nervous_poitrasdb8415d50a86        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 hours ago                         gallant_kilby</code></pre><p>可以看到有两个已经停止的容器了，如果想把容器再次启动，使用<code>docker start &lt;container_id&gt;</code>即可。 如果启动是使用了<code>--rm</code>参数的话，停止容器后，容器立即被销毁，通过<code>docker ps -a</code>也不会再看到此容器了。</p><h3 id="4-销毁-删除-容器"><a href="#4-销毁-删除-容器" class="headerlink" title="4. 销毁(删除)容器"></a>4. 销毁(删除)容器</h3><p>将已经停止的容器销毁(删除), 有时需要将不再使用的容器销毁，以免占用系统资源, 使用<code>docker rm &lt;container_id&gt;</code>:</p><pre><code>$ docker rm db8415d50a86db8415d50a86$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Exited (137) 5 minutes ago                       nervous_poitras</code></pre><p>执行命令后，将已经停止的一个容器销毁了。</p><h3 id="5-进入已启动容器的系统"><a href="#5-进入已启动容器的系统" class="headerlink" title="5. 进入已启动容器的系统"></a>5. 进入已启动容器的系统</h3><p>有时需要进入已经启动容器的系统进行一下操作，使用<code>docker exec [option] container_id [CMD]</code>:</p><pre><code>$ docker ps CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc7dc16321983        centos-sshd         &quot;/sbin/init&quot;        5 hours ago         Up 9 seconds                            nervous_poitras$ docker exec -ti c7dc16321983 /bin/bash[root@c7dc16321983 /]#</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前已经介绍了镜像管理，有了镜像，就可以使用镜像来启动容器(应用环境)。&lt;/p&gt;
&lt;h2 id=&quot;容器管理&quot;&gt;&lt;a href=&quot;#容器管理&quot;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(二):镜像管理</title>
    <link href="http://kidnet.github.io/2017/10/29/docker-image-management/"/>
    <id>http://kidnet.github.io/2017/10/29/docker-image-management/</id>
    <published>2017-10-29T07:32:20.000Z</published>
    <updated>2017-11-28T06:06:40.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker的容器是基于镜像的，所有容器是通过制作好的镜像启动的，下面会介绍镜像的管理和容器的管理。</p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><p>Docker的镜像可以通过多种途径获取，获取镜像后将镜像存入本地镜像库中，以供容器使用。</p><h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h3><p>镜像可以从公共镜像库中获取(类似yum源)，也可以自己制作，或导入已有镜像(从别的Docker导出的或OpenVZ一类虚拟化软件中导出的)。</p><ul><li>从公共镜像库中获取镜像</li></ul><p>使用<code>docker pull &lt;image_name&gt;[:tag]</code>命令从公共镜像库中获取镜像: </p><pre><code>$ docker pull centosUsing default tag: latestlatest: Pulling from library/centosd9aaf4d82f24: Pull complete Digest: sha256:4565fe2dd7f4770e825d4bd9c761a81b26e49cc9e3c9631c58cfc3188be9505aStatus: Downloaded newer image for centos:latest</code></pre><p>不指定<code>tag</code>的会自动选择使用<code>latest</code>标签。</p><p>公共镜像库支持查询功能，可以先使用<code>docker search &lt;image_name&gt;</code>查询需要的镜像是否存在:</p><pre><code>$ docker search centosNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                             The official build of CentOS.                   3789      [OK]       ansible/centos7-ansible            Ansible on Centos7                              103                  [OK]jdeathe/centos-ssh                 CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x8...   89                   [OK]tutum/centos                       Simple CentOS docker image with SSH access      33                   imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              31                   [OK]gluster/gluster-centos             Official GlusterFS Image [ CentOS-7 +  Glu...   21                   [OK]kinogmt/centos-ssh                 CentOS with SSH                                 17                   [OK]......</code></pre><ul><li>导入镜像 </li></ul><p>使用<code>docker load &lt; &lt;image_file_name&gt;</code>导入从其他Docker导出的镜像:</p><pre><code>$ docker load &lt; centos-sshd36018b5e9787: Loading layer [==================================================&gt;]  200.1MB/200.1MB56ab33f0cb6c: Loading layer [==================================================&gt;]  61.48MB/61.48MB52d118e898dd: Loading layer [==================================================&gt;]  21.99MB/21.99MB52e44758f62d: Loading layer [==================================================&gt;]  1.678MB/1.678MB6f88bf69d4eb: Loading layer [==================================================&gt;]  1.707MB/1.707MB5afae9f25cde: Loading layer [==================================================&gt;]  1.787MB/1.787MBLoaded image ID: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426    </code></pre><p>使用<code>cat &lt;openvz_image_file_name&gt; | docker import - &lt;image_name&gt;:&lt;tag&gt;</code>导入从虚拟化软件(OpenVZ)导出的镜像:</p><pre><code>$ cat centos-6-x86_64.tar.gz | docker import - centos:6sha256:54152fdb34278505a2007911a211ccd6d1d78dd946522bf797f2cf971efb89cf</code></pre><p>(<a href="https://openvz.org/Download/template/precreated" target="_blank" rel="external">OpenVZ镜像下载地址</a>)</p><h3 id="2-本地镜像"><a href="#2-本地镜像" class="headerlink" title="2. 本地镜像"></a>2. 本地镜像</h3><p>启动容器的镜像都是在本地镜像库中，对本地镜像库可以进行管理(删除，标签管理等)。</p><ul><li>本地镜像列表</li></ul><p>管理本地镜像需要了解本地已存在的镜像:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos              6                   54152fdb3427        17 minutes ago      825MBcentos              latest              d123f4e55e12        3 days ago          197MBcentos-sshd         latest              b8c73db541e7        6 months ago        280MB</code></pre><p>本地镜像中会列出镜像名称，id及tag(版本)。</p><ul><li>删除本地镜像</li></ul><p>如果本地镜像过多，有些过时的镜像，或者不再使用的镜像，需要被删除时，可以使用以下命令:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB#docker rmi &lt;image_name&gt;:&lt;tag&gt; $ docker rmi centos-sshd：latestUntagged: centos-sshd:latestDeleted: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426Deleted: sha256:5fdcd47722d29774d897562430801f6d1c168a422bcce5de1a6ace65302f900dDeleted: sha256:4e8a967d0d44bbd801c7787c2f750036988f92f28aeb76feb83293421de32a5dDeleted: sha256:50691d2b55b131e1ee4ccee1981556c631f55bb9f57269ceb00cf71c0b0e13bdDeleted: sha256:a84fc4ac805b0593c8e7a61a4d774f261cc4a4de6db1ff812c02b8524127d91bDeleted: sha256:0f8d19a2914ef598af3cc2dc8861b78b4b0d3b848d4eae97f2c81ba8e9f55015Deleted: sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c#检查镜像是否已被删除(唯一的一个本地镜像已被删除)$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</code></pre><p>如果一个镜像有多个tag的话，只会删除此tag:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         7.2                 b8c73db541e7        6 months ago        280MBcentos-sshd         latest              b8c73db541e7        6 months ago        280MB$ docker rmi centos-sshd：latestUntagged: centos-sshd:latest #提示只是删除了镜像的一个tag$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         7.2                 b8c73db541e7        6 months ago        280MB     </code></pre><p>使用镜像ID删除镜像(无论有多少个tag，都会先删除tag，然后彻底删除镜像):</p><pre><code>#dokcer rmi &lt;image_id&gt;$ docker rmi d123f4e55e12Untagged: centos-sshd:7.2Deleted: sha256:b8c73db541e787c15f8acdb892cebc41a00e8a1b257b02aa9b0be921f58d6426Deleted: sha256:5fdcd47722d29774d897562430801f6d1c168a422bcce5de1a6ace65302f900dDeleted: sha256:4e8a967d0d44bbd801c7787c2f750036988f92f28aeb76feb83293421de32a5dDeleted: sha256:50691d2b55b131e1ee4ccee1981556c631f55bb9f57269ceb00cf71c0b0e13bdDeleted: sha256:a84fc4ac805b0593c8e7a61a4d774f261cc4a4de6db1ff812c02b8524127d91bDeleted: sha256:0f8d19a2914ef598af3cc2dc8861b78b4b0d3b848d4eae97f2c81ba8e9f55015Deleted: sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c</code></pre><p> *注: 如果此镜像被其他镜像依赖，无法删除(后面会介绍依赖关系)。</p><ul><li>导出镜像</li></ul><p>有时可能需要从一个Docker中导出镜像到另一个Docker中，导出本地镜像的方法如下:</p><pre><code>$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEcentos-sshd         latest              b8c73db541e7        6 months ago        280MB#docker save &lt;image_id&gt; &gt; &lt;export_image_name&gt;$docker save b8c73db541e7 &gt; centos-sshd$lscentso-sshd</code></pre><h3 id="3-镜像制作"><a href="#3-镜像制作" class="headerlink" title="3. 镜像制作"></a>3. 镜像制作</h3><p>有时标准镜像的内容无法满足我们的需求，这时就需要自己制作镜像，这里介绍的制作镜像的方法是基于已有镜像，或将一个启动的容器提交为一个镜像。</p><ul><li>基于已有镜像制作镜像</li></ul><p>使用Dockerfile基于已有镜像制作新的镜像，一个简单的Dockerfile：</p><pre><code># Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [&quot;python&quot;, &quot;app.py&quot;]</code></pre><p>上面Dockerfile中制作了一个python应用的镜像(Dockerfile中可以同时定义容器的启动的参数，后面会详细介绍)，需要<code>requirements.txt</code>(运行这个python应用需要的模块)和<code>app.py</code>(python应用)，这两个文件需要和Dockerfile在同一个目录中(<code>ADD . /app</code>定义的)：</p><pre><code>$ lsDockerfile        app.py            requirements.txt</code></pre><p>最后使用以下命令制作镜像:</p><pre><code>docker build -t firstapp .</code></pre><p>在本地镜像库可以看到刚刚生成的镜像:</p><pre><code>$ docker imagesREPOSITORY            TAG                 IMAGE IDfirstapp         latest              326387cea398</code></pre><ul><li>基于容器制作镜像</li></ul><p>想对已有镜像做简单修改，或者不习惯于写Dockerfile，可以使用镜像启动一个容器，然后在容器中对系统进行修改，修改后将内容重新提交为一个新的镜像:</p><pre><code>$ docker commit &lt;container_id&gt; &lt;image_name&gt;:[&lt;tag&gt;]</code></pre><h3 id="4-镜像推送"><a href="#4-镜像推送" class="headerlink" title="4. 镜像推送"></a>4. 镜像推送</h3><p>将本地镜像(自己制作的镜像)，推送到镜像库(多用于私有镜像库，如是公共项目提交到公共镜像库)。</p><ul><li>推送到公共镜像库</li></ul><p>将自己制作的镜像，推送到公共镜像库，需要有对应镜像库的权限(登录认证)，才可以推送到对应的镜像库中。</p><p>登录到公共镜像库:</p><pre><code>$ docker loginLogin with yourDocker ID to push and pull images from Docker Hub. If you don&apos;t have a DockerID, head over to https://hub.docker.com tocreate one.Username: test #Your login namePassword:Login Succeeded</code></pre><p>*可以到<a href="http://hub.docker.com" target="_blank" rel="external">Docker公共镜像库</a>创建账号，建立自己的镜像库(类似于github)。</p><p>推送镜像:</p><pre><code>$ docker push &lt;login_name&gt;/&lt;image_name&gt;:&lt;tag&gt;$ docker push test/firstapp:lastThe push refers to arepository [docker.io/test/firstapp]34e7b85d83e4: Pushed last: digest:sha256:dafc45b8b533d5ad5564a3821e9e1a252b58f44e69c6052bddcd00139782ee08     size:529</code></pre><ul><li>推送到私有镜像库</li></ul><p>有时自己的镜像不想被别人看到，这时可以搭建自己的私有镜像库(后续会介绍)，然后将自己的镜像提交到私有的镜像库。</p><p>私有镜像库可以不需要登录(如果需要登录，登录过程和提交到公有镜像库一样)，先给需要提交的镜像设置一个<code>tag</code>，<code>tag</code>中将私有镜像库的地址写入即可(IP，hostname或域名):</p><pre><code>$ docker &lt;image_id&gt; &lt;private_registry_address&gt;/&lt;image_name&gt;:&lt;tag&gt;$ docker tag 34e7b85d83e4 10.236.100.3:5000/firstapp:last$ docker push 10.236.100.3:5000/firstapp:lastrepository [10.236.100.3:5000/firstapp]acce4ec5f074: Pushed5d450a8c7e38: Pushede8fd5087fa08: Pushedcf394a2f01e4: Pushedf16d5ac23cee: Pushed57861a68f43a: Pushed97ca462ad9ee: Pushedlast: digest:sha256:b0851324bac55083172ed2068dfb388acabdce14dffdb9787f4e6c044b524f19     size:1764</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Docker的容器是基于镜像的，所有容器是通过制作好的镜像启动的，下面会介绍镜像的管理和容器的管理。&lt;/p&gt;
&lt;h2 id=&quot;镜像管理&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker系列(一):安装</title>
    <link href="http://kidnet.github.io/2017/09/19/docker-install/"/>
    <id>http://kidnet.github.io/2017/09/19/docker-install/</id>
    <published>2017-09-19T10:04:08.000Z</published>
    <updated>2017-11-28T06:06:27.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。</p><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装:"></a>yum安装:</h2><h3 id="安装docker源"><a href="#安装docker源" class="headerlink" title="安装docker源"></a>安装docker源</h3><p>使用yum安装doucker之前，需要先设置docker的yum源。</p><p>1.安装源需要的包: <code>yum-utils</code>, <code>yum-config-manager</code>, <code>device-mapper-persistent-data</code>, <code>lvm2</code>及<code>devicemapper</code></p><pre><code>$ yum install -y yum-utils \  device-mapper-persistent-data \  lvm2</code></pre><p>2.安装docker源  </p><pre><code>$ yum-config-manager \  --add-repo \  https://download.docker.com/linux/centos/docker-ce.repo</code></pre><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>1.安装最新版本docker</p><pre><code>$ yum install docker-ce</code></pre><p>2.启动docker</p><pre><code>$ systemctl start docker</code></pre><p>3.验证docker是否安装正确</p><pre><code>$ docker run hello-world</code></pre><h2 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h2><h3 id="安装静态二进制"><a href="#安装静态二进制" class="headerlink" title="安装静态二进制"></a>安装静态二进制</h3><p>1.下载静态二进制包。下载地址:<a href="https://download.docker.com/linux/static/stable/x86_64/" target="_blank" rel="external">https://download.docker.com/linux/static/stable/x86_64/</a></p><p>2.解压缩tar包  </p><pre><code>$ tar -xzvf /path/to/&lt;FILE&gt;.tar.gz</code></pre><p>3.将二进制文件拷贝至系统命令目录，如<code>/usr/bin</code>  </p><pre><code>$ cp docker/* /usr/bin/</code></pre><p>4.启动Docker daemon:  </p><pre><code>$ dockerd &amp;</code></pre><p>5.验证docker是否安装正确  </p><pre><code>$ docker run hello-world</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在公司内部搭建Docker作为测试环境，准备将搭建的过程记录下来。&lt;/p&gt;
&lt;h2 id=&quot;yum安装&quot;&gt;&lt;a href=&quot;#yum安装
      
    
    </summary>
    
    
      <category term="docker" scheme="http://kidnet.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://kidnet.github.io/2017/09/11/markdown/"/>
    <id>http://kidnet.github.io/2017/09/11/markdown/</id>
    <published>2017-09-11T08:19:20.000Z</published>
    <updated>2017-09-11T08:19:23.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前使用dokuwiki系统做共享文档的平台，接触到了Markdown这种书写格式。最近开始折腾在github上搭建blog，又用到了Markdown，但是好多都忘光了，从头复习一下。Markdown的目标是易读易写，让作者专注于写作，不用太多关心排版的问题,即使不把Markdown格式转化为HTML，可读性依然很强。Markdown格式是可以以纯文档的方式发布，使用标签或是格式指令构成，可以兼容HTML。</p><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>连续的文本组成一个段落，每个段落前后有一个以上的空行。每个段落不能使用空格或制表符来缩进，如果想要缩进只能使用HTML元素，比如：<code>&amp;emsp;</code>/<code>&amp;ensp;</code>/<code>&amp;nbsp;</code>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown格式中可以使用<code>=</code>和<code>-</code>两种底线形式来标注标题，例如：</p><pre><code>这是标题1==========这是标题2----------</code></pre><blockquote><h1 id="这是标题1"><a href="#这是标题1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2"><a href="#这是标题2" class="headerlink" title="这是标题2"></a>这是标题2</h2></blockquote><p>*注:任何数量的<code>=</code>和<code>-</code>都有效果。</p><p>同时，在Markdown格式中，使用1-6个<code>#</code>加一个空格可以标注1-6级的标题，同时可以选择性在最后使用给一个空格加同样数量的<code>#</code>号来闭合。</p><pre><code># 这是标题1## 这是标题2 ######## 这是标题6</code></pre><blockquote><h1 id="这是标题1-1"><a href="#这是标题1-1" class="headerlink" title="这是标题1"></a>这是标题1</h1><h2 id="这是标题2-1"><a href="#这是标题2-1" class="headerlink" title="这是标题2"></a>这是标题2</h2><h6 id="这是标题6"><a href="#这是标题6" class="headerlink" title="这是标题6"></a>这是标题6</h6></blockquote><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>区块引用使用<code>&gt;</code>在每行的开头标记，也可以在每段开头进行标记，在区块引用中可以进行嵌套，例如：</p><pre><code>&gt; 这是一个区块引用的示例，&gt; 在每行的行的行首使用&quot;&gt;&quot;来标记区块。</code></pre><blockquote><p>这是一个区块引用的示例，<br>在每行的行的行首使用”&gt;”来标记区块。</p></blockquote><p>（这里分隔一下示例，看的更清晰一些。）</p><pre><code>&gt; 当然也可以在每段的段的段首标记，本段都是在区块引用中。&gt; &gt; 这是一个嵌套的区块引用。</code></pre><blockquote><p>当然也可以在每段的段的段首标记，<br>本段都是在区块引用中。</p><blockquote><p>这是一个嵌套的区块引用   </p></blockquote></blockquote><p>在区块引用中可以使用其它Markdown语法，包括标题、列表、代码区块等，这些就不在这演示了。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown支持有序列表和无序列表。<br>无序列表使用<code>*</code>、<code>+</code>或<code>-</code>作为标记，例如:</p><pre><code>* 序列内容1* 序列内容2* 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>等同于<code>+</code>:</p><pre><code>+ 序列内容1+ 序列内容2+ 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3   </li></ul></blockquote><p>等同于<code>-</code>:</p><pre><code>- 序列内容1- 序列内容2- 序列内容3</code></pre><blockquote><ul><li>序列内容1</li><li>序列内容2</li><li>序列内容3</li></ul></blockquote><p>有序列表使用数字后加一个<code>.</code>的形式(数字可以不按顺序或是同一个数字):</p><pre><code>1. 排序12. 排序23. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>同一个数字：</p><pre><code>1. 排序11. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序1</li><li>排序1</li></ol></blockquote><p>数字乱序：</p><pre><code>3. 排序19. 排序21. 排序3</code></pre><blockquote><ol><li>排序1</li><li>排序2</li><li>排序3</li></ol></blockquote><p>从示例中看到以上三种标记形式达到的效果是一样的，但是为了不转换成HTML时的可读性，还是尽量使用顺序数字标记。</p><p>如果在列表中分段、使用区块引用和代码区块等，需要在这些标记前使用1-3个空格来标记是在列表中，例如:</p><pre><code>* 这是第一个列表中的第一段   这是第一个列表中的第二段* 这是第二个列表   &gt; 这是第二个列表中的区块引用*这是第三个列表        这是第三个列表中的代码区块</code></pre><blockquote><ul><li><p>这是第一个列表中的第一段</p><p>这是第一个列表中的第二段</p></li><li><p>这是第二个列表</p><blockquote><p>这是第二个列表中的区块引用</p></blockquote></li><li><p>这是第三个列表</p><pre><code>&lt;html&gt;这是第三个列表中的代码区块&lt;/html&gt;</code></pre></li></ul></blockquote><p>###代码区块<br>如果想要写程序代码在文档中，直接在代码前加入4个空格就进入了代码区块中，所有代码区块中都会按照输入原样输出，上面已经使用了很多代码区块，这里就不在演示了。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以使用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来插入一个分割线，此行内不能有任何其他的元素，可以在每个符号间插入空格，效果是一样，例如：</p><pre><code>* * **********- - -————————————</code></pre><blockquote><hr></blockquote><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown格式中支持两种形式的链接语法：行内式和参考式。两种形式的链接文字都使用<code>[]</code>来标记。如果想在链接上加入title文字，组要使用<code>&quot;&quot;</code>把title文字包起来，例如：</p><pre><code>这是一个[示例链接](http://test.com/ &quot;test&quot;)有title。[这是一个链接](http://test.com/)没有title。</code></pre><blockquote><p>这是一个<a href="http://test.com/" title="test" target="_blank" rel="external">示例链接</a>有title。<br><a href="http://test.com/" target="_blank" rel="external">这是一个链接</a>没有title。</p></blockquote><p>如果链接本地资源(同一主机下的资源)，可以使用相对路径：</p><pre><code>同一主机下的[资源](/resource/)。</code></pre><blockquote><p>同一主机下的<a href="/resource/">资源</a>。</p></blockquote><p>参考式链接是在链接文字的方括号后再接一个方括号，在第二个方括号里要填入一个辨识链接的标记，然后在文档任意处把这个链接的内容定义出来，例如：</p><pre><code>这是一个参考式的[链接示例][id](可以选择性在链接和标识间加入空格。)[id]: http://test.com/ &quot;Optional Title Here&quot;以下这两种形式与上面这种形式相同：[id]: http://test.com/ &apos;Optional Title Here&apos;[id]: http://test.com/ (Optional Title Here)链接地址可以使用&lt;&gt;括起来：[id]: &lt;http://test.com/&gt; &quot;Optional Title Here&quot;</code></pre><blockquote><p>这是一个参考式的[链接示例]<a href="可以选择性在链接和标识间加入空格。">id</a></p><p>[id]: <a href="http://test.com/" target="_blank" rel="external">http://test.com/</a> “Optional Title Here”</p></blockquote><p>链接辨别标签可以有字母、数字、空白和标点符号，但不区分大小写, 以下两个链接是相同的:</p><pre><code>[link][a][link][A]</code></pre><p>参考式链接还有一种隐式链接功能，可以省略链接标记，这种情况下，链接标记等同于链接文字，使用隐式链接只要在链接文邹后加上<code>[]</code>即可，比如：</p><pre><code>[Link][][Link]: http://test.com/</code></pre><p>使用参考式链接的好处是使得文档结构简单，使阅读文档时更加清晰。可以让文档更像是转换成HTML后的结构，可以以把一些标记相关的元数据转移到文档最后，不但可以增加链接，还可以让阅读文档时不被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown可以使用<code>*</code>和<code>_</code>作为标记强调符号，被<code>*</code>和<code>_</code>包围的字词会被转换为斜体(一个符号)和粗体(两个符号)，例如：</p><pre><code>*em***strong**_em___strong__</code></pre><blockquote><p><em>em</em><br><strong>strong</strong><br><em>em</em><br><strong>strong</strong></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果在一行内标记一小段的代码，可以使用<code>`` </code>括起来，例如:</p><pre><code>使用`&lt;html&gt;`标签时，可以把它变成代码段。</code></pre><blockquote><p>使用<code>&lt;html&gt;</code>标签时，可以把它变成代码段。</p></blockquote><p>如果想标记<code>` </code>为代码段，需要在<code>`` </code>括起来，并在<code>` </code>前后加入空格;如果在<code>`` </code>中可以加文字需要使用<code>`` `` </code>(<code>`test` </code>)，例如：</p><pre><code>如果想标记` ` `为代码段，需要在` `` `括起来，并在` ` `前后加入空格;如果在` `` `中可以加文字需要使用` `` `` `(`` `test` ``)</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown中使用类似标记链接的语法来标记图片，同样可以使用行内式和参考式。<br>行内式的图片语法是:</p><pre><code>![Alt text](/path/img.jpg)![Alt test](/path/img.jpg &quot;Optional title&quot;)</code></pre><p>参考式的图片语法是:</p><pre><code>![Alt test][id][id]: url/path/image &quot;Optional title attribute&quot;</code></pre><h2 id="其它语法"><a href="#其它语法" class="headerlink" title="其它语法"></a>其它语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在Markdown语法中可以使用<code>-</code>、<code>|</code>和<code>:</code>来画出表格，<code>-</code>代表横线，<code>|</code>代表竖线，<code>:-----:</code>代表横线上的内容居中，例如：</p><pre><code>|Title1      |Title2    |Title3 ||------------|:--------:|:-----:||Content1    |Content2  |Content3|</code></pre><blockquote><table><thead><tr><th>Title1</th><th style="text-align:center">Title2</th><th style="text-align:center">Title3</th></tr></thead><tbody><tr><td>Content1</td><td style="text-align:center">Content2</td><td style="text-align:center">Content3</td></tr></tbody></table></blockquote><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown中支持简单的自动链接形式来出来网址和电子邮箱，使用<code>&lt;&gt;</code>括起来即可，Markdown会自动将它装换成链接形式，例如:</p><pre><code>&lt;http://test.com/&gt;&lt;test@test.com&gt;</code></pre><blockquote><p><a href="http://test.com/" target="_blank" rel="external">http://test.com/</a><br><a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x74;&#x65;&#x73;&#116;&#64;&#x74;&#x65;&#115;&#x74;&#46;&#99;&#111;&#x6d;">&#x74;&#x65;&#x73;&#116;&#64;&#x74;&#x65;&#115;&#x74;&#46;&#99;&#111;&#x6d;</a></p></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown中可以利用<code>\</code>来转义语法中有特殊意义的符号，例如:在文章中就是想加入<code>*</code>，不想进行强调，可以在<code>*</code>前加入<code>\</code>:</p><pre><code>\*只想在文章中加入`*`\*</code></pre><blockquote><p>*只想在文章中加入<code>*</code>*</p></blockquote><p>Markdown中支持以下符号前加<code>\</code>来转义:</p><blockquote><p><code>\</code>     反斜线<br><code>` </code>   反引号<br><code>*</code>     星号<br><code>_</code>     下划线<br><code>{}</code>    花括号<br><code>[]</code>    方括号<br><code>()</code>    圆括号<br><code>+</code>      加号<br><code>-</code>      减号<br><code>.</code>      英文句号<br><code>!</code>      叹号</p></blockquote><h3 id="Markdown书写软件"><a href="#Markdown书写软件" class="headerlink" title="Markdown书写软件"></a>Markdown书写软件</h3><p>Markdown本身是一种标记性语法，上面提到过，即使不转换成HTML语言可读性也很强，所以任何文本工具都可以使用Markdown语法，有些文本工具可以安装一些插件达到语法高亮的效果，这里就不一一细说了。还有一些软件是可以一边使用Markdown语法书写，同时能看到转换为HTML后的效果，即所见即所得，如:MarkdownPad、马克飞象(Chrome浏览器插件)、Mou等，还有许多在线的书写工具。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文是根据<a href="http://wowubuntu.com/markdown" target="_blank" rel="external">wowubuntu</a>文章，并根据自己的一些理解加以修改而编写的, 一切版权问题依照原作者声明。</p><p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown语法项目(英文)地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://kidnet.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>带有超时设置的subprocess</title>
    <link href="http://kidnet.github.io/2017/09/08/subprocess_with_timeout/"/>
    <id>http://kidnet.github.io/2017/09/08/subprocess_with_timeout/</id>
    <published>2017-09-08T07:50:36.000Z</published>
    <updated>2017-09-13T01:54:54.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频繁调用的定时任务来说，会产生很多卡死的进程(实际中遇到过很多子进程卡死，导致系统资源耗尽，宕机)。为解决这个问题，重新对subprocess封装，加入对调用命令执行超时的处理。</p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><h3 id="重新封装SubWork类"><a href="#重新封装SubWork类" class="headerlink" title="重新封装SubWork类"></a>重新封装SubWork类</h3><p>对subprocess重新封装，定义一些默认属性。</p><pre><code>class SubWork(Object):    def __init__(self):                                                                                                                                           &quot;&quot;&quot;    Default None                                                               &quot;&quot;&quot;                                                                       self._Popen = None                                                         self._pid = None           #子进程PID                                                       self._return_code = None   #执行命令返回值                                               self._cwd = None           #执行目录                                               self._start_time = None    #子进程开始执行的时间戳</code></pre><h3 id="调用命令的内部方法"><a href="#调用命令的内部方法" class="headerlink" title="调用命令的内部方法"></a>调用命令的内部方法</h3><p>这里定义了一个内部方法，用于使用subprocess调用系统命令，并做超时处理。</p><ol><li>subprocess接收命令格式为一个list，所以使用shlex.split()进行命令切分。此方法接收4个参数：命令，标准输出，标准错误和执行目录。</li><li>超时处理，在调用<code>subprocess.Popen()</code>方法后，先获取当前时间戳，然后循环判断，是否程序正常退出(<code>poll()</code>方法获取子进程状态)并且是在超时时间之内，这里用这个循环来代替<code>wait()</code>方法来阻塞进程，并判断超时。如果超过超时时间，方法继续执行，获取进程执行返回的状态(此时可能子进程并未执行完毕)，再次判断子进程是否退出，如在此处还未退出，执行<code>terminate()</code>方法，给子进程发送信号，退出子进程，等待1秒，再次判断进程是否退出，如还未退出证明进程未正常相应<code>terminate()</code>发出的信号，此时使用<code>kill()</code>方法，发出<code>SIGKILL</code>信号，强制退出子进程。</li><li>最终获取子进程退出的状态。</li></ol><p>代码如下:</p><pre><code>def _run(self):    #Run cmd.    #Split command string.    cmd = shlex.split(self._cmd)    self._Popen = subprocess.Popen(args=cmd,                                   stdout=self._stdout_fd,                                   stderr=self._stderr_fd,                                   cwd=self._cwd)    self._pid = self._Popen.pid    self._start_time = time.time()    while (self._Popen.poll() == None and            (time.time() - self._start_time) &lt; self._timeout):        time.sleep(1)    _r_code = self._Popen.poll()    # If child process has not exited yet, terminate it.    if self._Popen.poll() == None:        self._Popen.terminate()        _r_code = 254    # Wait for the child process to exit.    time.sleep(1)    # If child process has not been terminated yet, kill it.    if self._Popen.poll() == None:        self._Popen.kill()        _r_code = 255    self._return_code = _r_code</code></pre><h3 id="对外的方法"><a href="#对外的方法" class="headerlink" title="对外的方法"></a>对外的方法</h3><p>外部调用的方法<code>start()</code>，使用此方法进行执行命令的调用。接收命令，超时时间，标准输入，标准输出，标准错误，是否使用tty(是否将结果输出到终端)，是否使用时间戳(返回结果中打印开始的时间)。此方法主要是调用内部执行命令的方法(_run())，然后对输出进行格式化。</p><pre><code>def start(self,          cmd,          timeout=5*60*60,          stdin=None,          stdout=None,          stderr=None,          tty=False,          timestamp=False):    self._cmd = cmd    self._stdin = stdin    self._stdout = stdout    self._stderr = stderr    self._timeout = timeout    self._is_tty = tty    self._timestamp = timestamp    #Init output.    info = None    err = None    if self._timestamp:        start_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())        file_start = &quot;Start Time: &quot; + start_time + &quot;\n&quot;    else:        file_start = &quot;&quot;        file_end = &quot;&quot;    try:        #Init the file handle of output.        if self._is_tty:            self._stdout_fd = None            self._stderr_fd = None        elif (self._stdout is None or            self._stderr is None or            self._stdout == self._stderr):            self._stdout_fd = tempfile.TemporaryFile()            self._stderr_fd = tempfile.TemporaryFile()        else:            self._stdout_fd = self._create_handler(self._stdout)            self._stderr_fd = self._create_handler(self._stderr)            self._stdout_fd.write(file_start)            self._stdout_fd.flush()            self._stderr_fd.write(file_start)            self._stderr_fd.flush()        self._run()        if self._timestamp:            end_time = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime())            file_end = &quot;End Time: &quot; + end_time + &quot;\n&quot;        #Write and Read output content.        if not self._is_tty:            self._stdout_fd.write(file_end)            self._stderr_fd.write(file_end)            self._stdout_fd.flush()            self._stderr_fd.flush()            self._stdout_fd.seek(0)            self._stderr_fd.seek(0)            info = file_start + self._stdout_fd.read() + file_end            err = file_start + self._stderr_fd.read() + file_end    finally:        #Close file handle.        if not self._is_tty:            self._stdout_fd.close()            self._stderr_fd.close()    return {&quot;code&quot;:self._return_code,            &quot;stdout&quot;:info,            &quot;stderr&quot;:err            }</code></pre><p>  这里输出分为3种类型：</p><ol><li>直接输出到终端，设置tty=True即可，就是直接打印到终端。</li><li>输出到临时文件中，如果tty=False，并且没有输入指定的log文件（stdout和stderr），某块会自动创建一个临时文件来记录日志。</li><li>输出到指定日志中，设置了输出日志，会将命令执行的标准输出和标准错误输出到指定日志文件中（实时输出）。</li></ol><p>*注意: 如果设置使用输出到tty，最终start()方法只会返回命令执行的状态码，不会返回执行结果（已经输出到终端），使用临时文件作为日志或指定输出日志文件，最终start()方法会最终将日志返回给调用的程序。</p><h3 id="对日志处理的方法"><a href="#对日志处理的方法" class="headerlink" title="对日志处理的方法"></a>对日志处理的方法</h3><p>创建日志文件，初始化日志句柄。</p><pre><code>#Create file handle.def _create_handler(self, filename):    if isinstance(filename, file):        return filename    elif isinstance(filename, basestring):        path = os.path.dirname(filename)        timestamp = time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime())        if not os.path.exists(path):            os.makedirs(path)        elif os.path.exists(filename) and not os.path.isfile(filename):            backup_name = filename + timestamp            os.rename(filename, backup_name)        fd = open(filename, &apos;a+b&apos;)        return fd    else:        raise &quot;The type of \&apos;filename\&apos; must be \&apos;file\&apos; or \&apos;basestring\&apos;&quot;</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>SubWork</code>使用方法如下:</p><pre><code>import SubWorkcmd = &quot;/bin/ls /tmp&quot;worker = SubWork()res = worker.start(cmd, 300， &quot;/tmp/stdout.log&quot;, &quot;/tmp/stderr.log&quot;)print res</code></pre><p>这里会执行<code>/bin/ls /tmp</code>命令，超时时间300秒，将执行的标准输出实时输出到<code>/tmp/stdout.log</code>中，将输出的标准错误实时输出到<code>/tmp/stderr.log</code> 中，最终<code>res</code>变量中会有命令执行的状态码和命令执行的输出结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用subprocess模块时，总是遇到调用调用系统命令后，子进程执行完后没有退出，造成卡死在系统中。虽然遇到的几率不是很频繁，但是对于频
      
    
    </summary>
    
      <category term="Python" scheme="http://kidnet.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://kidnet.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
